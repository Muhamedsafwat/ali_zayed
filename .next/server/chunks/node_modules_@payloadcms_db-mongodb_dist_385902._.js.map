{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/connect.ts"],"sourcesContent":["import type { ConnectOptions } from 'mongoose'\nimport type { Connect } from 'payload'\n\nimport mongoose from 'mongoose'\nimport { defaultBeginTransaction } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nexport const connect: Connect = async function connect(\n  this: MongooseAdapter,\n  options = {\n    hotReload: false,\n  },\n) {\n  const { hotReload } = options\n\n  if (this.url === false) {\n    return\n  }\n\n  if (typeof this.url !== 'string') {\n    throw new Error('Error: missing MongoDB connection URL.')\n  }\n\n  const urlToConnect = this.url\n\n  const connectionOptions: { useFacet: undefined } & ConnectOptions = {\n    autoIndex: true,\n    ...this.connectOptions,\n    useFacet: undefined,\n  }\n\n  if (hotReload) {\n    connectionOptions.autoIndex = false\n  }\n\n  try {\n    this.connection = (await mongoose.connect(urlToConnect, connectionOptions)).connection\n\n    // If we are running a replica set with MongoDB Memory Server,\n    // wait until the replica set elects a primary before proceeding\n    if (this.mongoMemoryServer) {\n      await new Promise((resolve) => setTimeout(resolve, 2000))\n    }\n\n    const client = this.connection.getClient()\n\n    if (!client.options.replicaSet) {\n      this.transactionOptions = false\n      this.beginTransaction = defaultBeginTransaction()\n    }\n\n    if (!this.mongoMemoryServer && !hotReload) {\n      if (process.env.PAYLOAD_DROP_DATABASE === 'true') {\n        this.payload.logger.info('---- DROPPING DATABASE ----')\n        await mongoose.connection.dropDatabase()\n        this.payload.logger.info('---- DROPPED DATABASE ----')\n      }\n    }\n\n    if (this.ensureIndexes) {\n      await Promise.all(\n        this.payload.config.collections.map(async (coll) => {\n          await this.collections[coll.slug]?.ensureIndexes()\n        }),\n      )\n    }\n\n    if (process.env.NODE_ENV === 'production' && this.prodMigrations) {\n      await this.migrate({ migrations: this.prodMigrations })\n    }\n  } catch (err) {\n    this.payload.logger.error({\n      err,\n      msg: `Error: cannot connect to MongoDB. Details: ${err.message}`,\n    })\n    process.exit(1)\n  }\n}\n"],"names":["mongoose","defaultBeginTransaction","connect","options","hotReload","url","Error","urlToConnect","connectionOptions","autoIndex","connectOptions","useFacet","undefined","connection","mongoMemoryServer","Promise","resolve","setTimeout","client","getClient","replicaSet","transactionOptions","beginTransaction","process","env","PAYLOAD_DROP_DATABASE","payload","logger","info","dropDatabase","ensureIndexes","all","config","collections","map","coll","slug","NODE_ENV","prodMigrations","migrate","migrations","err","error","msg","message","exit"],"mappings":";;;AAGA,OAAOA,cAAc,WAAU;AAC/B,SAASC,uBAAuB,QAAQ,UAAS;;;AAI1C,MAAMC,UAAmB,eAAeA,QAE7CC,UAAU;IACRC,WAAW;AACb,CAAC;IAED,MAAM,EAAEA,SAAS,EAAE,GAAGD;IAEtB,IAAI,IAAI,CAACE,GAAG,KAAK,OAAO;QACtB;IACF;IAEA,IAAI,OAAO,IAAI,CAACA,GAAG,KAAK,UAAU;QAChC,MAAM,IAAIC,MAAM;IAClB;IAEA,MAAMC,eAAe,IAAI,CAACF,GAAG;IAE7B,MAAMG,oBAA8D;QAClEC,WAAW;QACX,GAAG,IAAI,CAACC,cAAc;QACtBC,UAAUC;IACZ;IAEA,IAAIR,WAAW;QACbI,kBAAkBC,SAAS,GAAG;IAChC;IAEA,IAAI;QACF,IAAI,CAACI,UAAU,GAAI,CAAA,gHAAMb,UAAAA,CAASE,OAAO,CAACK,cAAcC,kBAAiB,EAAGK,UAAU;QAEtF,8DAA8D;QAC9D,gEAAgE;QAChE,IAAI,IAAI,CAACC,iBAAiB,EAAE;YAC1B,MAAM,IAAIC,QAAQ,CAACC,UAAYC,WAAWD,SAAS;QACrD;QAEA,MAAME,SAAS,IAAI,CAACL,UAAU,CAACM,SAAS;QAExC,IAAI,CAACD,OAAOf,OAAO,CAACiB,UAAU,EAAE;YAC9B,IAAI,CAACC,kBAAkB,GAAG;YAC1B,IAAI,CAACC,gBAAgB,gLAAGrB,0BAAAA;QAC1B;QAEA,IAAI,CAAC,IAAI,CAACa,iBAAiB,IAAI,CAACV,WAAW;YACzC,IAAImB,QAAQC,GAAG,CAACC,qBAAqB,KAAK,QAAQ;gBAChD,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC;gBACzB,gHAAM5B,UAAAA,CAASa,UAAU,CAACgB,YAAY;gBACtC,IAAI,CAACH,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC;YAC3B;QACF;QAEA,IAAI,IAAI,CAACE,aAAa,EAAE;YACtB,MAAMf,QAAQgB,GAAG,CACf,IAAI,CAACL,OAAO,CAACM,MAAM,CAACC,WAAW,CAACC,GAAG,CAAC,OAAOC;gBACzC,MAAM,IAAI,CAACF,WAAW,CAACE,KAAKC,IAAI,CAAC,EAAEN;YACrC;QAEJ;QAEA,IAAIP,QAAQC,GAAG,CAACa,QAAQ,gCAAK,gBAAgB,IAAI,CAACC,cAAc,EAAE;;QAElE;IACF,EAAE,OAAOG,KAAK;QACZ,IAAI,CAACf,OAAO,CAACC,MAAM,CAACe,KAAK,CAAC;YACxBD;YACAE,KAAK,CAAC,2CAA2C,EAAEF,IAAIG,OAAO,EAAE;QAClE;QACArB,QAAQsB,IAAI,CAAC;IACf;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/buildAndOrConditions.ts"],"sourcesContent":["import type { FlattenedField, Payload, Where } from 'payload'\n\nimport { parseParams } from './parseParams.js'\n\nexport async function buildAndOrConditions({\n  collectionSlug,\n  fields,\n  globalSlug,\n  locale,\n  parentIsLocalized,\n  payload,\n  where,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  locale?: string\n  parentIsLocalized: boolean\n  payload: Payload\n  where: Where[]\n}): Promise<Record<string, unknown>[]> {\n  const completedConditions = []\n  // Loop over all AND / OR operations and add them to the AND / OR query param\n  // Operations should come through as an array\n\n  for (const condition of where) {\n    // If the operation is properly formatted as an object\n    if (typeof condition === 'object') {\n      const result = await parseParams({\n        collectionSlug,\n        fields,\n        globalSlug,\n        locale,\n        parentIsLocalized,\n        payload,\n        where: condition,\n      })\n      if (Object.keys(result).length > 0) {\n        completedConditions.push(result)\n      }\n    }\n  }\n  return completedConditions\n}\n"],"names":["parseParams","buildAndOrConditions","collectionSlug","fields","globalSlug","locale","parentIsLocalized","payload","where","completedConditions","condition","result","Object","keys","length","push"],"mappings":";;;AAEA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,eAAeC,qBAAqB,EACzCC,cAAc,EACdC,MAAM,EACNC,UAAU,EACVC,MAAM,EACNC,iBAAiB,EACjBC,OAAO,EACPC,KAAK,EASN;IACC,MAAMC,sBAAsB,EAAE;IAC9B,6EAA6E;IAC7E,6CAA6C;IAE7C,KAAK,MAAMC,aAAaF,MAAO;QAC7B,sDAAsD;QACtD,IAAI,OAAOE,cAAc,UAAU;YACjC,MAAMC,SAAS,OAAMX,mMAAAA,EAAY;gBAC/BE;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC,OAAOE;YACT;YACA,IAAIE,OAAOC,IAAI,CAACF,QAAQG,MAAM,GAAG,GAAG;gBAClCL,oBAAoBM,IAAI,CAACJ;YAC3B;QACF;IACF;IACA,OAAOF;AACT","ignoreList":[0]}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/operatorMap.ts"],"sourcesContent":["export const operatorMap = {\n  all: '$all',\n  equals: '$eq',\n  exists: '$exists',\n  greater_than: '$gt',\n  greater_than_equal: '$gte',\n  in: '$in',\n  intersects: '$geoIntersects',\n  less_than: '$lt',\n  less_than_equal: '$lte',\n  near: '$near',\n  not_equals: '$ne',\n  not_in: '$nin',\n  within: '$geoWithin',\n}\n"],"names":["operatorMap","all","equals","exists","greater_than","greater_than_equal","in","intersects","less_than","less_than_equal","near","not_equals","not_in","within"],"mappings":";;;AAAO,MAAMA,cAAc;IACzBC,KAAK;IACLC,QAAQ;IACRC,QAAQ;IACRC,cAAc;IACdC,oBAAoB;IACpBC,IAAI;IACJC,YAAY;IACZC,WAAW;IACXC,iBAAiB;IACjBC,MAAM;IACNC,YAAY;IACZC,QAAQ;IACRC,QAAQ;AACV,EAAC","ignoreList":[0]}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/sanitizeQueryValue.ts"],"sourcesContent":["import type {\n  FlattenedBlock,\n  FlattenedBlocksField,\n  FlattenedField,\n  Payload,\n  RelationshipField,\n} from 'payload'\n\nimport { Types } from 'mongoose'\nimport { createArrayFromCommaDelineated } from 'payload'\nimport { fieldShouldBeLocalized } from 'payload/shared'\n\ntype SanitizeQueryValueArgs = {\n  field: FlattenedField\n  hasCustomID: boolean\n  locale?: string\n  operator: string\n  parentIsLocalized: boolean\n  path: string\n  payload: Payload\n  val: any\n}\n\nconst buildExistsQuery = (formattedValue, path, treatEmptyString = true) => {\n  if (formattedValue) {\n    return {\n      rawQuery: {\n        $and: [\n          { [path]: { $exists: true } },\n          { [path]: { $ne: null } },\n          ...(treatEmptyString ? [{ [path]: { $ne: '' } }] : []), // Treat empty string as null / undefined\n        ],\n      },\n    }\n  } else {\n    return {\n      rawQuery: {\n        $or: [\n          { [path]: { $exists: false } },\n          { [path]: { $eq: null } },\n          ...(treatEmptyString ? [{ [path]: { $eq: '' } }] : []), // Treat empty string as null / undefined\n        ],\n      },\n    }\n  }\n}\n\n// returns nestedField Field object from blocks.nestedField path because getLocalizedPaths splits them only for relationships\nconst getFieldFromSegments = ({\n  field,\n  payload,\n  segments,\n}: {\n  field: FlattenedBlock | FlattenedField\n  payload: Payload\n  segments: string[]\n}) => {\n  if ('blocks' in field || 'blockReferences' in field) {\n    const _field: FlattenedBlocksField = field as FlattenedBlocksField\n    for (const _block of _field.blockReferences ?? _field.blocks) {\n      const block: FlattenedBlock = typeof _block === 'string' ? payload.blocks[_block] : _block\n      const field = getFieldFromSegments({ field: block, payload, segments })\n      if (field) {\n        return field\n      }\n    }\n  }\n\n  if ('fields' in field) {\n    for (let i = 0; i < segments.length; i++) {\n      const foundField = field.flattenedFields.find((each) => each.name === segments[i])\n\n      if (!foundField) {\n        break\n      }\n\n      if (foundField && segments.length - 1 === i) {\n        return foundField\n      }\n\n      segments.shift()\n      return getFieldFromSegments({ field: foundField, payload, segments })\n    }\n  }\n}\n\nexport const sanitizeQueryValue = ({\n  field,\n  hasCustomID,\n  locale,\n  operator,\n  parentIsLocalized,\n  path,\n  payload,\n  val,\n}: SanitizeQueryValueArgs): {\n  operator?: string\n  rawQuery?: unknown\n  val?: unknown\n} => {\n  let formattedValue = val\n  let formattedOperator = operator\n  if (['array', 'blocks', 'group', 'tab'].includes(field.type) && path.includes('.')) {\n    const segments = path.split('.')\n    segments.shift()\n    const foundField = getFieldFromSegments({ field, payload, segments })\n\n    if (foundField) {\n      field = foundField\n    }\n  }\n\n  // Disregard invalid _ids\n  if (path === '_id') {\n    if (typeof val === 'string' && val.split(',').length === 1) {\n      if (!hasCustomID) {\n        const isValid = Types.ObjectId.isValid(val)\n\n        if (!isValid) {\n          return { operator: formattedOperator, val: undefined }\n        } else {\n          if (['in', 'not_in'].includes(operator)) {\n            formattedValue = createArrayFromCommaDelineated(formattedValue).map(\n              (id) => new Types.ObjectId(id),\n            )\n          } else {\n            formattedValue = new Types.ObjectId(val)\n          }\n        }\n      }\n\n      if (field.type === 'number') {\n        const parsedNumber = parseFloat(val)\n\n        if (Number.isNaN(parsedNumber)) {\n          return { operator: formattedOperator, val: undefined }\n        }\n      }\n    } else if (Array.isArray(val) || (typeof val === 'string' && val.split(',').length > 1)) {\n      if (typeof val === 'string') {\n        formattedValue = createArrayFromCommaDelineated(val)\n      }\n\n      formattedValue = formattedValue.reduce((formattedValues, inVal) => {\n        if (!hasCustomID) {\n          if (Types.ObjectId.isValid(inVal)) {\n            formattedValues.push(new Types.ObjectId(inVal))\n          }\n        }\n\n        if (field.type === 'number') {\n          const parsedNumber = parseFloat(inVal)\n          if (!Number.isNaN(parsedNumber)) {\n            formattedValues.push(parsedNumber)\n          }\n        } else {\n          formattedValues.push(inVal)\n        }\n\n        return formattedValues\n      }, [])\n    }\n  }\n\n  // Cast incoming values as proper searchable types\n  if (field.type === 'checkbox' && typeof val === 'string') {\n    if (val.toLowerCase() === 'true') {\n      formattedValue = true\n    }\n    if (val.toLowerCase() === 'false') {\n      formattedValue = false\n    }\n  }\n\n  if (['all', 'in', 'not_in'].includes(operator) && typeof formattedValue === 'string') {\n    formattedValue = createArrayFromCommaDelineated(formattedValue)\n\n    if (field.type === 'number') {\n      formattedValue = formattedValue.map((arrayVal) => parseFloat(arrayVal))\n    }\n  }\n\n  if (field.type === 'number') {\n    if (typeof formattedValue === 'string' && operator !== 'exists') {\n      formattedValue = Number(val)\n    }\n\n    if (operator === 'exists') {\n      formattedValue = val === 'true' ? true : val === 'false' ? false : Boolean(val)\n\n      return buildExistsQuery(formattedValue, path)\n    }\n  }\n\n  if (field.type === 'date' && typeof val === 'string' && operator !== 'exists') {\n    formattedValue = new Date(val)\n    if (Number.isNaN(Date.parse(formattedValue))) {\n      return undefined\n    }\n  }\n\n  if (['relationship', 'upload'].includes(field.type)) {\n    if (val === 'null') {\n      formattedValue = null\n    }\n\n    // Object equality requires the value to be the first key in the object that is being queried.\n    if (\n      operator === 'equals' &&\n      formattedValue &&\n      typeof formattedValue === 'object' &&\n      formattedValue.value &&\n      formattedValue.relationTo\n    ) {\n      const { value } = formattedValue\n      const isValid = Types.ObjectId.isValid(value)\n\n      if (isValid) {\n        formattedValue.value = new Types.ObjectId(value)\n      }\n\n      let localizedPath = path\n\n      if (\n        fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n        payload.config.localization &&\n        locale\n      ) {\n        localizedPath = `${path}.${locale}`\n      }\n\n      return {\n        rawQuery: {\n          $or: [\n            {\n              [localizedPath]: {\n                $eq: {\n                  // disable auto sort\n                  /* eslint-disable */\n                  value: formattedValue.value,\n                  relationTo: formattedValue.relationTo,\n                  /* eslint-enable */\n                },\n              },\n            },\n            {\n              [localizedPath]: {\n                $eq: {\n                  relationTo: formattedValue.relationTo,\n                  value: formattedValue.value,\n                },\n              },\n            },\n          ],\n        },\n      }\n    }\n\n    const relationTo = (field as RelationshipField).relationTo\n\n    if (['in', 'not_in'].includes(operator) && Array.isArray(formattedValue)) {\n      formattedValue = formattedValue.reduce((formattedValues, inVal) => {\n        if (!inVal) {\n          return formattedValues\n        }\n\n        if (typeof relationTo === 'string' && payload.collections[relationTo].customIDType) {\n          if (payload.collections[relationTo].customIDType === 'number') {\n            const parsedNumber = parseFloat(inVal)\n            if (!Number.isNaN(parsedNumber)) {\n              formattedValues.push(parsedNumber)\n              return formattedValues\n            }\n          }\n\n          formattedValues.push(inVal)\n          return formattedValues\n        }\n\n        if (\n          Array.isArray(relationTo) &&\n          relationTo.some((relationTo) => !!payload.collections[relationTo].customIDType)\n        ) {\n          if (Types.ObjectId.isValid(inVal.toString())) {\n            formattedValues.push(new Types.ObjectId(inVal))\n          } else {\n            formattedValues.push(inVal)\n          }\n          return formattedValues\n        }\n\n        if (Types.ObjectId.isValid(inVal.toString())) {\n          formattedValues.push(new Types.ObjectId(inVal))\n        }\n\n        return formattedValues\n      }, [])\n    }\n\n    if (\n      ['contains', 'equals', 'like', 'not_equals'].includes(operator) &&\n      (!Array.isArray(relationTo) || !path.endsWith('.relationTo'))\n    ) {\n      if (typeof relationTo === 'string') {\n        const customIDType = payload.collections[relationTo].customIDType\n\n        if (customIDType) {\n          if (customIDType === 'number') {\n            formattedValue = parseFloat(val)\n\n            if (Number.isNaN(formattedValue)) {\n              return { operator: formattedOperator, val: undefined }\n            }\n          }\n        } else {\n          if (!Types.ObjectId.isValid(formattedValue)) {\n            return { operator: formattedOperator, val: undefined }\n          }\n          formattedValue = new Types.ObjectId(formattedValue)\n        }\n      } else {\n        const hasCustomIDType = relationTo.some(\n          (relationTo) => !!payload.collections[relationTo].customIDType,\n        )\n\n        if (hasCustomIDType) {\n          if (typeof val === 'string') {\n            const formattedNumber = Number(val)\n            formattedValue = [Types.ObjectId.isValid(val) ? new Types.ObjectId(val) : val]\n            formattedOperator = operator === 'not_equals' ? 'not_in' : 'in'\n            if (!Number.isNaN(formattedNumber)) {\n              formattedValue.push(formattedNumber)\n            }\n          }\n        } else {\n          if (!Types.ObjectId.isValid(formattedValue)) {\n            return { operator: formattedOperator, val: undefined }\n          }\n          formattedValue = new Types.ObjectId(formattedValue)\n        }\n      }\n    }\n\n    if (\n      operator === 'all' &&\n      Array.isArray(relationTo) &&\n      path.endsWith('.value') &&\n      Array.isArray(formattedValue)\n    ) {\n      formattedValue.forEach((v, i) => {\n        if (Types.ObjectId.isValid(v)) {\n          formattedValue[i] = new Types.ObjectId(v)\n        }\n      })\n    }\n  }\n\n  // Set up specific formatting necessary by operators\n\n  if (operator === 'near') {\n    let lng\n    let lat\n    let maxDistance\n    let minDistance\n\n    if (Array.isArray(formattedValue)) {\n      ;[lng, lat, maxDistance, minDistance] = formattedValue\n    }\n\n    if (typeof formattedValue === 'string') {\n      ;[lng, lat, maxDistance, minDistance] = createArrayFromCommaDelineated(formattedValue)\n    }\n\n    if (lng == null || lat == null || (maxDistance == null && minDistance == null)) {\n      formattedValue = undefined\n    } else {\n      formattedValue = {\n        $geometry: { type: 'Point', coordinates: [parseFloat(lng), parseFloat(lat)] },\n      }\n\n      if (maxDistance && !Number.isNaN(Number(maxDistance))) {\n        formattedValue.$maxDistance = parseFloat(maxDistance)\n      }\n\n      if (minDistance && !Number.isNaN(Number(minDistance))) {\n        formattedValue.$minDistance = parseFloat(minDistance)\n      }\n    }\n  }\n\n  if (operator === 'within' || operator === 'intersects') {\n    formattedValue = {\n      $geometry: formattedValue,\n    }\n  }\n\n  if (path !== '_id' || (path === '_id' && hasCustomID && field.type === 'text')) {\n    if (operator === 'contains' && !Types.ObjectId.isValid(formattedValue)) {\n      formattedValue = {\n        $options: 'i',\n        $regex: formattedValue.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n      }\n    }\n\n    if (operator === 'exists') {\n      formattedValue = formattedValue === 'true' || formattedValue === true\n\n      // _id can't be empty string, will error Cast to ObjectId failed for value \"\"\n      return buildExistsQuery(\n        formattedValue,\n        path,\n        !['relationship', 'upload'].includes(field.type),\n      )\n    }\n  }\n\n  if (\n    (path === '_id' || path === 'parent') &&\n    operator === 'like' &&\n    formattedValue.length === 24 &&\n    !hasCustomID\n  ) {\n    formattedOperator = 'equals'\n  }\n\n  if (operator === 'exists') {\n    formattedValue = formattedValue === 'true' || formattedValue === true\n\n    // Clearable fields\n    if (['relationship', 'select', 'upload'].includes(field.type)) {\n      if (formattedValue) {\n        return {\n          rawQuery: {\n            $and: [{ [path]: { $exists: true } }, { [path]: { $ne: null } }],\n          },\n        }\n      } else {\n        return {\n          rawQuery: {\n            $or: [{ [path]: { $exists: false } }, { [path]: { $eq: null } }],\n          },\n        }\n      }\n    }\n  }\n\n  return { operator: formattedOperator, val: formattedValue }\n}\n"],"names":["Types","createArrayFromCommaDelineated","fieldShouldBeLocalized","buildExistsQuery","formattedValue","path","treatEmptyString","rawQuery","$and","$exists","$ne","$or","$eq","getFieldFromSegments","field","payload","segments","_field","_block","blockReferences","blocks","block","i","length","foundField","flattenedFields","find","each","name","shift","sanitizeQueryValue","hasCustomID","locale","operator","parentIsLocalized","val","formattedOperator","includes","type","split","isValid","ObjectId","undefined","map","id","parsedNumber","parseFloat","Number","isNaN","Array","isArray","reduce","formattedValues","inVal","push","toLowerCase","arrayVal","Boolean","Date","parse","value","relationTo","localizedPath","config","localization","collections","customIDType","some","toString","endsWith","hasCustomIDType","formattedNumber","forEach","v","lng","lat","maxDistance","minDistance","$geometry","coordinates","$maxDistance","$minDistance","$options","$regex","replace"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 584, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/buildSearchParams.ts"],"sourcesContent":["import type { FlattenedField, Operator, PathToQuery, Payload } from 'payload'\n\nimport { Types } from 'mongoose'\nimport { getLocalizedPaths } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { operatorMap } from './operatorMap.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\ntype SearchParam = {\n  path?: string\n  rawQuery?: unknown\n  value?: unknown\n}\n\nconst subQueryOptions = {\n  lean: true,\n  limit: 50,\n}\n\n/**\n * Convert the Payload key / value / operator into a MongoDB query\n */\nexport async function buildSearchParam({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  operator,\n  parentIsLocalized,\n  payload,\n  val,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  operator: string\n  parentIsLocalized: boolean\n  payload: Payload\n  val: unknown\n}): Promise<SearchParam> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath = incomingPath.replace(/__/g, '.')\n  if (sanitizedPath === 'id') {\n    sanitizedPath = '_id'\n  }\n\n  let paths: PathToQuery[] = []\n\n  let hasCustomID = false\n\n  if (sanitizedPath === '_id') {\n    const customIDFieldType = payload.collections[collectionSlug]?.customIDType\n\n    let idFieldType: 'number' | 'text' = 'text'\n\n    if (customIDFieldType) {\n      idFieldType = customIDFieldType\n      hasCustomID = true\n    }\n\n    paths.push({\n      collectionSlug,\n      complete: true,\n      field: {\n        name: 'id',\n        type: idFieldType,\n      } as FlattenedField,\n      parentIsLocalized,\n      path: '_id',\n    })\n  } else {\n    paths = getLocalizedPaths({\n      collectionSlug,\n      fields,\n      globalSlug,\n      incomingPath: sanitizedPath,\n      locale,\n      parentIsLocalized,\n      payload,\n    })\n  }\n\n  const [{ field, path }] = paths\n  if (path) {\n    const sanitizedQueryValue = sanitizeQueryValue({\n      field,\n      hasCustomID,\n      locale,\n      operator,\n      parentIsLocalized,\n      path,\n      payload,\n      val,\n    })\n\n    if (!sanitizedQueryValue) {\n      return undefined\n    }\n\n    const { operator: formattedOperator, rawQuery, val: formattedValue } = sanitizedQueryValue\n\n    if (rawQuery) {\n      return { value: rawQuery }\n    }\n\n    // If there are multiple collections to search through,\n    // Recursively build up a list of query constraints\n    if (paths.length > 1) {\n      // Remove top collection and reverse array\n      // to work backwards from top\n      const pathsToQuery = paths.slice(1).reverse()\n\n      const initialRelationshipQuery = {\n        value: {},\n      } as SearchParam\n\n      const relationshipQuery = await pathsToQuery.reduce(\n        async (priorQuery, { collectionSlug: slug, path: subPath }, i) => {\n          const priorQueryResult = await priorQuery\n\n          const SubModel = (payload.db as MongooseAdapter).collections[slug]\n\n          // On the \"deepest\" collection,\n          // Search on the value passed through the query\n          if (i === 0) {\n            const subQuery = await SubModel.buildQuery({\n              locale,\n              payload,\n              where: {\n                [subPath]: {\n                  [formattedOperator]: val,\n                },\n              },\n            })\n\n            const result = await SubModel.find(subQuery, subQueryOptions)\n\n            const $in: unknown[] = []\n\n            result.forEach((doc) => {\n              const stringID = doc._id.toString()\n              $in.push(stringID)\n\n              if (Types.ObjectId.isValid(stringID)) {\n                $in.push(doc._id)\n              }\n            })\n\n            if (pathsToQuery.length === 1) {\n              return {\n                path,\n                value: { $in },\n              }\n            }\n\n            const nextSubPath = pathsToQuery[i + 1].path\n\n            return {\n              value: { [nextSubPath]: { $in } },\n            }\n          }\n\n          const subQuery = priorQueryResult.value\n          const result = await SubModel.find(subQuery, subQueryOptions)\n\n          const $in = result.map((doc) => doc._id)\n\n          // If it is the last recursion\n          // then pass through the search param\n          if (i + 1 === pathsToQuery.length) {\n            return {\n              path,\n              value: { $in },\n            }\n          }\n\n          return {\n            value: {\n              _id: { $in },\n            },\n          }\n        },\n        Promise.resolve(initialRelationshipQuery),\n      )\n\n      return relationshipQuery\n    }\n\n    if (formattedOperator && validOperatorSet.has(formattedOperator as Operator)) {\n      const operatorKey = operatorMap[formattedOperator]\n\n      if (field.type === 'relationship' || field.type === 'upload') {\n        let hasNumberIDRelation\n        let multiIDCondition = '$or'\n        if (operatorKey === '$ne') {\n          multiIDCondition = '$and'\n        }\n\n        const result = {\n          value: {\n            [multiIDCondition]: [{ [path]: { [operatorKey]: formattedValue } }],\n          },\n        }\n\n        if (typeof formattedValue === 'string') {\n          if (Types.ObjectId.isValid(formattedValue)) {\n            result.value[multiIDCondition].push({\n              [path]: { [operatorKey]: new Types.ObjectId(formattedValue) },\n            })\n          } else {\n            ;(Array.isArray(field.relationTo) ? field.relationTo : [field.relationTo]).forEach(\n              (relationTo) => {\n                const isRelatedToCustomNumberID =\n                  payload.collections[relationTo]?.customIDType === 'number'\n\n                if (isRelatedToCustomNumberID) {\n                  hasNumberIDRelation = true\n                }\n              },\n            )\n\n            if (hasNumberIDRelation) {\n              result.value[multiIDCondition].push({\n                [path]: { [operatorKey]: parseFloat(formattedValue) },\n              })\n            }\n          }\n        }\n\n        if (result.value[multiIDCondition].length > 1) {\n          return result\n        }\n      }\n\n      if (formattedOperator === 'like' && typeof formattedValue === 'string') {\n        const words = formattedValue.split(' ')\n\n        const result = {\n          value: {\n            $and: words.map((word) => ({\n              [path]: {\n                $options: 'i',\n                $regex: word.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n              },\n            })),\n          },\n        }\n\n        return result\n      }\n\n      // Some operators like 'near' need to define a full query\n      // so if there is no operator key, just return the value\n      if (!operatorKey) {\n        return {\n          path,\n          value: formattedValue,\n        }\n      }\n\n      return {\n        path,\n        value: { [operatorKey]: formattedValue },\n      }\n    }\n  }\n  return undefined\n}\n"],"names":["Types","getLocalizedPaths","validOperatorSet","operatorMap","sanitizeQueryValue","subQueryOptions","lean","limit","buildSearchParam","collectionSlug","fields","globalSlug","incomingPath","locale","operator","parentIsLocalized","payload","val","sanitizedPath","replace","paths","hasCustomID","customIDFieldType","collections","customIDType","idFieldType","push","complete","field","name","type","path","sanitizedQueryValue","undefined","formattedOperator","rawQuery","formattedValue","value","length","pathsToQuery","slice","reverse","initialRelationshipQuery","relationshipQuery","reduce","priorQuery","slug","subPath","i","priorQueryResult","SubModel","db","subQuery","buildQuery","where","result","find","$in","forEach","doc","stringID","_id","toString","ObjectId","isValid","nextSubPath","map","Promise","resolve","has","operatorKey","hasNumberIDRelation","multiIDCondition","Array","isArray","relationTo","isRelatedToCustomNumberID","parseFloat","words","split","$and","word","$options","$regex"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 818, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/parseParams.ts"],"sourcesContent":["import type { FilterQuery } from 'mongoose'\nimport type { FlattenedField, Operator, Payload, Where } from 'payload'\n\nimport { deepMergeWithCombinedArrays } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { buildSearchParam } from './buildSearchParams.js'\n\nexport async function parseParams({\n  collectionSlug,\n  fields,\n  globalSlug,\n  locale,\n  parentIsLocalized,\n  payload,\n  where,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  locale: string\n  parentIsLocalized: boolean\n  payload: Payload\n  where: Where\n}): Promise<Record<string, unknown>> {\n  let result = {} as FilterQuery<any>\n\n  if (typeof where === 'object') {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      const condition = where[relationOrPath]\n      let conditionOperator: '$and' | '$or'\n      if (relationOrPath.toLowerCase() === 'and') {\n        conditionOperator = '$and'\n      } else if (relationOrPath.toLowerCase() === 'or') {\n        conditionOperator = '$or'\n      }\n      if (Array.isArray(condition)) {\n        const builtConditions = await buildAndOrConditions({\n          collectionSlug,\n          fields,\n          globalSlug,\n          locale,\n          parentIsLocalized,\n          payload,\n          where: condition,\n        })\n        if (builtConditions.length > 0) {\n          result[conditionOperator] = builtConditions\n        }\n      } else {\n        // It's a path - and there can be multiple comparisons on a single path.\n        // For example - title like 'test' and title not equal to 'tester'\n        // So we need to loop on keys again here to handle each operator independently\n        const pathOperators = where[relationOrPath]\n        if (typeof pathOperators === 'object') {\n          const validOperators = Object.keys(pathOperators).filter((operator) =>\n            validOperatorSet.has(operator as Operator),\n          )\n          for (const operator of validOperators) {\n            const searchParam = await buildSearchParam({\n              collectionSlug,\n              fields,\n              globalSlug,\n              incomingPath: relationOrPath,\n              locale,\n              operator,\n              parentIsLocalized,\n              payload,\n              val: pathOperators[operator],\n            })\n\n            if (searchParam?.value && searchParam?.path) {\n              if (validOperators.length > 1) {\n                if (!result.$and) {\n                  result.$and = []\n                }\n                result.$and.push({\n                  [searchParam.path]: searchParam.value,\n                })\n              } else {\n                result[searchParam.path] = searchParam.value\n              }\n            } else if (typeof searchParam?.value === 'object') {\n              result = deepMergeWithCombinedArrays(result, searchParam.value, {\n                // dont clone Types.ObjectIDs\n                clone: false,\n              })\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return result\n}\n"],"names":["deepMergeWithCombinedArrays","validOperatorSet","buildAndOrConditions","buildSearchParam","parseParams","collectionSlug","fields","globalSlug","locale","parentIsLocalized","payload","where","result","relationOrPath","Object","keys","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","length","pathOperators","validOperators","filter","operator","has","searchParam","incomingPath","val","value","path","$and","push","clone"],"mappings":";;;AAMA,SAASE,oBAAoB,QAAQ,4BAA2B;AAChE,SAASC,gBAAgB,QAAQ,yBAAwB;AAHzD,SAASF,gBAAgB,QAAQ,iBAAgB;AADjD,SAASD,2BAA2B,QAAQ,UAAS;;;;;AAM9C,eAAeI,YAAY,EAChCC,cAAc,EACdC,MAAM,EACNC,UAAU,EACVC,MAAM,EACNC,iBAAiB,EACjBC,OAAO,EACPC,KAAK,EASN;IACC,IAAIC,SAAS,CAAC;IAEd,IAAI,OAAOD,UAAU,UAAU;QAC7B,uEAAuE;QACvE,KAAK,MAAME,kBAAkBC,OAAOC,IAAI,CAACJ,OAAQ;YAC/C,MAAMK,YAAYL,KAAK,CAACE,eAAe;YACvC,IAAII;YACJ,IAAIJ,eAAeK,WAAW,OAAO,OAAO;gBAC1CD,oBAAoB;YACtB,OAAO,IAAIJ,eAAeK,WAAW,OAAO,MAAM;gBAChDD,oBAAoB;YACtB;YACA,IAAIE,MAAMC,OAAO,CAACJ,YAAY;gBAC5B,MAAMK,kBAAkB,qMAAMnB,uBAAAA,EAAqB;oBACjDG;oBACAC;oBACAC;oBACAC;oBACAC;oBACAC;oBACAC,OAAOK;gBACT;gBACA,IAAIK,gBAAgBC,MAAM,GAAG,GAAG;oBAC9BV,MAAM,CAACK,kBAAkB,GAAGI;gBAC9B;YACF,OAAO;gBACL,wEAAwE;gBACxE,kEAAkE;gBAClE,8EAA8E;gBAC9E,MAAME,gBAAgBZ,KAAK,CAACE,eAAe;gBAC3C,IAAI,OAAOU,kBAAkB,UAAU;oBACrC,MAAMC,iBAAiBV,OAAOC,IAAI,CAACQ,eAAeE,MAAM,CAAC,CAACC,mKACxDzB,mBAAAA,CAAiB0B,GAAG,CAACD;oBAEvB,KAAK,MAAMA,YAAYF,eAAgB;wBACrC,MAAMI,cAAc,kMAAMzB,mBAAAA,EAAiB;4BACzCE;4BACAC;4BACAC;4BACAsB,cAAchB;4BACdL;4BACAkB;4BACAjB;4BACAC;4BACAoB,KAAKP,aAAa,CAACG,SAAS;wBAC9B;wBAEA,IAAIE,aAAaG,SAASH,aAAaI,MAAM;4BAC3C,IAAIR,eAAeF,MAAM,GAAG,GAAG;gCAC7B,IAAI,CAACV,OAAOqB,IAAI,EAAE;oCAChBrB,OAAOqB,IAAI,GAAG,EAAE;gCAClB;gCACArB,OAAOqB,IAAI,CAACC,IAAI,CAAC;oCACf,CAACN,YAAYI,IAAI,CAAC,EAAEJ,YAAYG,KAAK;gCACvC;4BACF,OAAO;gCACLnB,MAAM,CAACgB,YAAYI,IAAI,CAAC,GAAGJ,YAAYG,KAAK;4BAC9C;wBACF,OAAO,IAAI,OAAOH,aAAaG,UAAU,UAAU;4BACjDnB,yLAASZ,8BAAAA,EAA4BY,QAAQgB,YAAYG,KAAK,EAAE;gCAC9D,6BAA6B;gCAC7BI,OAAO;4BACT;wBACF;oBACF;gBACF;YACF;QACF;IACF;IAEA,OAAOvB;AACT","ignoreList":[0]}},
    {"offset": {"line": 897, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 903, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/buildQuery.ts"],"sourcesContent":["import type { FlattenedField, Where } from 'payload'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { parseParams } from './parseParams.js'\n\nexport const buildQuery = async ({\n  adapter,\n  collectionSlug,\n  fields,\n  globalSlug,\n  locale,\n  where,\n}: {\n  adapter: MongooseAdapter\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  locale?: string\n  where: Where\n}) => {\n  const result = await parseParams({\n    collectionSlug,\n    fields,\n    globalSlug,\n    locale,\n    parentIsLocalized: false,\n    payload: adapter.payload,\n    where,\n  })\n\n  return result\n}\n"],"names":["parseParams","buildQuery","adapter","collectionSlug","fields","globalSlug","locale","where","result","parentIsLocalized","payload"],"mappings":";;;AAIA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,MAAMC,aAAa,OAAO,EAC/BC,OAAO,EACPC,cAAc,EACdC,MAAM,EACNC,UAAU,EACVC,MAAM,EACNC,KAAK,EAQN;IACC,MAAMC,SAAS,4LAAMR,cAAAA,EAAY;QAC/BG;QACAC;QACAC;QACAC;QACAG,mBAAmB;QACnBC,SAASR,QAAQQ,OAAO;QACxBH;IACF;IAEA,OAAOC;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 920, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 926, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/utilities/getSession.ts"],"sourcesContent":["import type { ClientSession } from 'mongoose'\nimport type { PayloadRequest } from 'payload'\n\nimport type { MongooseAdapter } from '../index.js'\n\n/**\n * returns the session belonging to the transaction of the req.session if exists\n * @returns ClientSession\n */\nexport async function getSession(\n  db: MongooseAdapter,\n  req?: Partial<PayloadRequest>,\n): Promise<ClientSession | undefined> {\n  if (!req) {\n    return\n  }\n\n  let transactionID = req.transactionID\n\n  if (transactionID instanceof Promise) {\n    transactionID = await req.transactionID\n  }\n\n  if (transactionID) {\n    return db.sessions[transactionID]\n  }\n}\n"],"names":["getSession","db","req","transactionID","Promise","sessions"],"mappings":"AAKA;;;CAGC,GACD;;;AAAO,eAAeA,WACpBC,EAAmB,EACnBC,GAA6B;IAE7B,IAAI,CAACA,KAAK;QACR;IACF;IAEA,IAAIC,gBAAgBD,IAAIC,aAAa;IAErC,IAAIA,yBAAyBC,SAAS;QACpCD,gBAAgB,MAAMD,IAAIC,aAAa;IACzC;IAEA,IAAIA,eAAe;QACjB,OAAOF,GAAGI,QAAQ,CAACF,cAAc;IACnC;AACF","ignoreList":[0]}},
    {"offset": {"line": 944, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/count.ts"],"sourcesContent":["import type { CountOptions } from 'mongodb'\nimport type { Count } from 'payload'\n\nimport { flattenWhereToOperators } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getSession } from './utilities/getSession.js'\n\nexport const count: Count = async function count(\n  this: MongooseAdapter,\n  { collection, locale, req, where },\n) {\n  const Model = this.collections[collection]\n  const options: CountOptions = {\n    session: await getSession(this, req),\n  }\n\n  let hasNearConstraint = false\n\n  if (where) {\n    const constraints = flattenWhereToOperators(where)\n    hasNearConstraint = constraints.some((prop) => Object.keys(prop).some((key) => key === 'near'))\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    collectionSlug: collection,\n    fields: this.payload.collections[collection].config.flattenedFields,\n    locale,\n    where,\n  })\n\n  // useEstimatedCount is faster, but not accurate, as it ignores any filters. It is thus set to true if there are no filters.\n  const useEstimatedCount = hasNearConstraint || !query || Object.keys(query).length === 0\n\n  if (!useEstimatedCount && Object.keys(query).length === 0 && this.disableIndexHints !== true) {\n    // Improve the performance of the countDocuments query which is used if useEstimatedCount is set to false by adding\n    // a hint. By default, if no hint is provided, MongoDB does not use an indexed field to count the returned documents,\n    // which makes queries very slow. This only happens when no query (filter) is provided. If one is provided, it uses\n    // the correct indexed field\n    options.hint = {\n      _id: 1,\n    }\n  }\n\n  let result: number\n  if (useEstimatedCount) {\n    result = await Model.estimatedDocumentCount({ session: options.session })\n  } else {\n    result = await Model.countDocuments(query, options)\n  }\n\n  return {\n    totalDocs: result,\n  }\n}\n"],"names":["flattenWhereToOperators","buildQuery","getSession","count","collection","locale","req","where","Model","collections","options","session","hasNearConstraint","constraints","some","prop","Object","keys","key","query","adapter","collectionSlug","fields","payload","config","flattenedFields","useEstimatedCount","length","disableIndexHints","hint","_id","result","estimatedDocumentCount","countDocuments","totalDocs"],"mappings":";;;AAOA,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,UAAU,QAAQ,4BAA2B;AALtD,SAASF,uBAAuB,QAAQ,UAAS;;;;AAO1C,MAAMG,QAAe,eAAeA,MAEzC,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAElC,MAAMC,QAAQ,IAAI,CAACC,WAAW,CAACL,WAAW;IAC1C,MAAMM,UAAwB;QAC5BC,SAAS,6LAAMT,aAAAA,EAAW,IAAI,EAAEI;IAClC;IAEA,IAAIM,oBAAoB;IAExB,IAAIL,OAAO;QACT,MAAMM,eAAcb,sMAAAA,EAAwBO;QAC5CK,oBAAoBC,YAAYC,IAAI,CAAC,CAACC,OAASC,OAAOC,IAAI,CAACF,MAAMD,IAAI,CAAC,CAACI,MAAQA,QAAQ;IACzF;IAEA,MAAMC,QAAQ,2LAAMlB,aAAAA,EAAW;QAC7BmB,SAAS,IAAI;QACbC,gBAAgBjB;QAChBkB,QAAQ,IAAI,CAACC,OAAO,CAACd,WAAW,CAACL,WAAW,CAACoB,MAAM,CAACC,eAAe;QACnEpB;QACAE;IACF;IAEA,4HAA4H;IAC5H,MAAMmB,oBAAoBd,qBAAqB,CAACO,SAASH,OAAOC,IAAI,CAACE,OAAOQ,MAAM,KAAK;IAEvF,IAAI,CAACD,qBAAqBV,OAAOC,IAAI,CAACE,OAAOQ,MAAM,KAAK,KAAK,IAAI,CAACC,iBAAiB,KAAK,MAAM;QAC5F,mHAAmH;QACnH,qHAAqH;QACrH,mHAAmH;QACnH,4BAA4B;QAC5BlB,QAAQmB,IAAI,GAAG;YACbC,KAAK;QACP;IACF;IAEA,IAAIC;IACJ,IAAIL,mBAAmB;QACrBK,SAAS,MAAMvB,MAAMwB,sBAAsB,CAAC;YAAErB,SAASD,QAAQC,OAAO;QAAC;IACzE,OAAO;QACLoB,SAAS,MAAMvB,MAAMyB,cAAc,CAACd,OAAOT;IAC7C;IAEA,OAAO;QACLwB,WAAWH;IACb;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 999, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1005, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/countGlobalVersions.ts"],"sourcesContent":["import type { CountOptions } from 'mongodb'\nimport type { CountGlobalVersions } from 'payload'\n\nimport { buildVersionGlobalFields, flattenWhereToOperators } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getSession } from './utilities/getSession.js'\n\nexport const countGlobalVersions: CountGlobalVersions = async function countGlobalVersions(\n  this: MongooseAdapter,\n  { global, locale, req, where },\n) {\n  const Model = this.versions[global]\n  const options: CountOptions = {\n    session: await getSession(this, req),\n  }\n\n  let hasNearConstraint = false\n\n  if (where) {\n    const constraints = flattenWhereToOperators(where)\n    hasNearConstraint = constraints.some((prop) => Object.keys(prop).some((key) => key === 'near'))\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    fields: buildVersionGlobalFields(\n      this.payload.config,\n      this.payload.globals.config.find((each) => each.slug === global),\n      true,\n    ),\n    locale,\n    where,\n  })\n\n  // useEstimatedCount is faster, but not accurate, as it ignores any filters. It is thus set to true if there are no filters.\n  const useEstimatedCount = hasNearConstraint || !query || Object.keys(query).length === 0\n\n  if (!useEstimatedCount && Object.keys(query).length === 0 && this.disableIndexHints !== true) {\n    // Improve the performance of the countDocuments query which is used if useEstimatedCount is set to false by adding\n    // a hint. By default, if no hint is provided, MongoDB does not use an indexed field to count the returned documents,\n    // which makes queries very slow. This only happens when no query (filter) is provided. If one is provided, it uses\n    // the correct indexed field\n    options.hint = {\n      _id: 1,\n    }\n  }\n\n  let result: number\n  if (useEstimatedCount) {\n    result = await Model.estimatedDocumentCount({ session: options.session })\n  } else {\n    result = await Model.countDocuments(query, options)\n  }\n\n  return {\n    totalDocs: result,\n  }\n}\n"],"names":["buildVersionGlobalFields","flattenWhereToOperators","buildQuery","getSession","countGlobalVersions","global","locale","req","where","Model","versions","options","session","hasNearConstraint","constraints","some","prop","Object","keys","key","query","adapter","fields","payload","config","globals","find","each","slug","useEstimatedCount","length","disableIndexHints","hint","_id","result","estimatedDocumentCount","countDocuments","totalDocs"],"mappings":";;;AAOA,SAASE,UAAU,QAAQ,0BAAyB;AACpD,SAASC,UAAU,QAAQ,4BAA2B;AALtD,SAASH,wBAAwB,EAAEC,uBAAuB,QAAQ,UAAS;;;;;AAOpE,MAAMG,sBAA2C,eAAeA,oBAErE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAE9B,MAAMC,QAAQ,IAAI,CAACC,QAAQ,CAACL,OAAO;IACnC,MAAMM,UAAwB;QAC5BC,SAAS,OAAMT,mMAAAA,EAAW,IAAI,EAAEI;IAClC;IAEA,IAAIM,oBAAoB;IAExB,IAAIL,OAAO;QACT,MAAMM,2LAAcb,0BAAAA,EAAwBO;QAC5CK,oBAAoBC,YAAYC,IAAI,CAAC,CAACC,OAASC,OAAOC,IAAI,CAACF,MAAMD,IAAI,CAAC,CAACI,MAAQA,QAAQ;IACzF;IAEA,MAAMC,QAAQ,2LAAMlB,aAAAA,EAAW;QAC7BmB,SAAS,IAAI;QACbC,+KAAQtB,2BAAAA,EACN,IAAI,CAACuB,OAAO,CAACC,MAAM,EACnB,IAAI,CAACD,OAAO,CAACE,OAAO,CAACD,MAAM,CAACE,IAAI,CAAC,CAACC,OAASA,KAAKC,IAAI,KAAKvB,SACzD;QAEFC;QACAE;IACF;IAEA,4HAA4H;IAC5H,MAAMqB,oBAAoBhB,qBAAqB,CAACO,SAASH,OAAOC,IAAI,CAACE,OAAOU,MAAM,KAAK;IAEvF,IAAI,CAACD,qBAAqBZ,OAAOC,IAAI,CAACE,OAAOU,MAAM,KAAK,KAAK,IAAI,CAACC,iBAAiB,KAAK,MAAM;QAC5F,mHAAmH;QACnH,qHAAqH;QACrH,mHAAmH;QACnH,4BAA4B;QAC5BpB,QAAQqB,IAAI,GAAG;YACbC,KAAK;QACP;IACF;IAEA,IAAIC;IACJ,IAAIL,mBAAmB;QACrBK,SAAS,MAAMzB,MAAM0B,sBAAsB,CAAC;YAAEvB,SAASD,QAAQC,OAAO;QAAC;IACzE,OAAO;QACLsB,SAAS,MAAMzB,MAAM2B,cAAc,CAAChB,OAAOT;IAC7C;IAEA,OAAO;QACL0B,WAAWH;IACb;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1054, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1060, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/countVersions.ts"],"sourcesContent":["import type { CountOptions } from 'mongodb'\nimport type { CountVersions } from 'payload'\n\nimport { buildVersionCollectionFields, flattenWhereToOperators } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getSession } from './utilities/getSession.js'\n\nexport const countVersions: CountVersions = async function countVersions(\n  this: MongooseAdapter,\n  { collection, locale, req, where },\n) {\n  const Model = this.versions[collection]\n  const options: CountOptions = {\n    session: await getSession(this, req),\n  }\n\n  let hasNearConstraint = false\n\n  if (where) {\n    const constraints = flattenWhereToOperators(where)\n    hasNearConstraint = constraints.some((prop) => Object.keys(prop).some((key) => key === 'near'))\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    fields: buildVersionCollectionFields(\n      this.payload.config,\n      this.payload.collections[collection].config,\n      true,\n    ),\n    locale,\n    where,\n  })\n\n  // useEstimatedCount is faster, but not accurate, as it ignores any filters. It is thus set to true if there are no filters.\n  const useEstimatedCount = hasNearConstraint || !query || Object.keys(query).length === 0\n\n  if (!useEstimatedCount && Object.keys(query).length === 0 && this.disableIndexHints !== true) {\n    // Improve the performance of the countDocuments query which is used if useEstimatedCount is set to false by adding\n    // a hint. By default, if no hint is provided, MongoDB does not use an indexed field to count the returned documents,\n    // which makes queries very slow. This only happens when no query (filter) is provided. If one is provided, it uses\n    // the correct indexed field\n    options.hint = {\n      _id: 1,\n    }\n  }\n\n  let result: number\n  if (useEstimatedCount) {\n    result = await Model.estimatedDocumentCount({ session: options.session })\n  } else {\n    result = await Model.countDocuments(query, options)\n  }\n\n  return {\n    totalDocs: result,\n  }\n}\n"],"names":["buildVersionCollectionFields","flattenWhereToOperators","buildQuery","getSession","countVersions","collection","locale","req","where","Model","versions","options","session","hasNearConstraint","constraints","some","prop","Object","keys","key","query","adapter","fields","payload","config","collections","useEstimatedCount","length","disableIndexHints","hint","_id","result","estimatedDocumentCount","countDocuments","totalDocs"],"mappings":";;;AAOA,SAASE,UAAU,QAAQ,0BAAyB;AACpD,SAASC,UAAU,QAAQ,4BAA2B;AALtD,SAASH,4BAA4B,EAAEC,uBAAuB,QAAQ,UAAS;;;;;AAOxE,MAAMG,gBAA+B,eAAeA,cAEzD,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAElC,MAAMC,QAAQ,IAAI,CAACC,QAAQ,CAACL,WAAW;IACvC,MAAMM,UAAwB;QAC5BC,SAAS,OAAMT,mMAAAA,EAAW,IAAI,EAAEI;IAClC;IAEA,IAAIM,oBAAoB;IAExB,IAAIL,OAAO;QACT,MAAMM,2LAAcb,0BAAAA,EAAwBO;QAC5CK,oBAAoBC,YAAYC,IAAI,CAAC,CAACC,OAASC,OAAOC,IAAI,CAACF,MAAMD,IAAI,CAAC,CAACI,MAAQA,QAAQ;IACzF;IAEA,MAAMC,QAAQ,2LAAMlB,aAAAA,EAAW;QAC7BmB,SAAS,IAAI;QACbC,mLAAQtB,+BAAAA,EACN,IAAI,CAACuB,OAAO,CAACC,MAAM,EACnB,IAAI,CAACD,OAAO,CAACE,WAAW,CAACpB,WAAW,CAACmB,MAAM,EAC3C;QAEFlB;QACAE;IACF;IAEA,4HAA4H;IAC5H,MAAMkB,oBAAoBb,qBAAqB,CAACO,SAASH,OAAOC,IAAI,CAACE,OAAOO,MAAM,KAAK;IAEvF,IAAI,CAACD,qBAAqBT,OAAOC,IAAI,CAACE,OAAOO,MAAM,KAAK,KAAK,IAAI,CAACC,iBAAiB,KAAK,MAAM;QAC5F,mHAAmH;QACnH,qHAAqH;QACrH,mHAAmH;QACnH,4BAA4B;QAC5BjB,QAAQkB,IAAI,GAAG;YACbC,KAAK;QACP;IACF;IAEA,IAAIC;IACJ,IAAIL,mBAAmB;QACrBK,SAAS,MAAMtB,MAAMuB,sBAAsB,CAAC;YAAEpB,SAASD,QAAQC,OAAO;QAAC;IACzE,OAAO;QACLmB,SAAS,MAAMtB,MAAMwB,cAAc,CAACb,OAAOT;IAC7C;IAEA,OAAO;QACLuB,WAAWH;IACb;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1115, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/utilities/handleError.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport { ValidationError } from 'payload'\n\nexport const handleError = ({\n  collection,\n  error,\n  global,\n  req,\n}: {\n  collection?: string\n  error: Error\n  global?: string\n  req?: Partial<PayloadRequest>\n}) => {\n  if (!error || typeof error !== 'object') {\n    throw error\n  }\n\n  // Handle uniqueness error from MongoDB\n  if ('code' in error && error.code === 11000 && 'keyValue' in error && error.keyValue) {\n    throw new ValidationError(\n      {\n        collection,\n        errors: [\n          {\n            message: req?.t ? req.t('error:valueMustBeUnique') : 'Value must be unique',\n            path: Object.keys(error.keyValue)[0],\n          },\n        ],\n        global,\n      },\n      req?.t,\n    )\n  }\n\n  throw error\n}\n"],"names":["ValidationError","handleError","collection","error","global","req","code","keyValue","errors","message","t","path","Object","keys"],"mappings":";;;AAEA,SAASA,eAAe,QAAQ,UAAS;;AAElC,MAAMC,cAAc,CAAC,EAC1BC,UAAU,EACVC,KAAK,EACLC,MAAM,EACNC,GAAG,EAMJ;IACC,IAAI,CAACF,SAAS,OAAOA,UAAU,UAAU;QACvC,MAAMA;IACR;IAEA,uCAAuC;IACvC,IAAI,UAAUA,SAASA,MAAMG,IAAI,KAAK,SAAS,cAAcH,SAASA,MAAMI,QAAQ,EAAE;QACpF,MAAM,mKAAIP,kBAAAA,CACR;YACEE;YACAM,QAAQ;gBACN;oBACEC,SAASJ,KAAKK,IAAIL,IAAIK,CAAC,CAAC,6BAA6B;oBACrDC,MAAMC,OAAOC,IAAI,CAACV,MAAMI,QAAQ,CAAC,CAAC,EAAE;gBACtC;aACD;YACDH;QACF,GACAC,KAAKK;IAET;IAEA,MAAMP;AACR,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1139, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1145, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/utilities/sanitizeRelationshipIDs.ts"],"sourcesContent":["import type { CollectionConfig, Field, SanitizedConfig, TraverseFieldsCallback } from 'payload'\n\nimport { Types } from 'mongoose'\nimport { traverseFields } from 'payload'\nimport { fieldAffectsData, fieldShouldBeLocalized } from 'payload/shared'\n\ntype Args = {\n  config: SanitizedConfig\n  data: Record<string, unknown>\n  fields: Field[]\n  parentIsLocalized?: boolean\n}\n\ninterface RelationObject {\n  relationTo: string\n  value: number | string\n}\n\nfunction isValidRelationObject(value: unknown): value is RelationObject {\n  return typeof value === 'object' && value !== null && 'relationTo' in value && 'value' in value\n}\n\nconst convertValue = ({\n  relatedCollection,\n  value,\n}: {\n  relatedCollection: CollectionConfig\n  value: number | string\n}): number | string | Types.ObjectId => {\n  const customIDField = relatedCollection.fields.find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  )\n\n  if (customIDField) {\n    return value\n  }\n\n  try {\n    return new Types.ObjectId(value)\n  } catch {\n    return value\n  }\n}\n\nconst sanitizeRelationship = ({ config, field, locale, ref, value }) => {\n  let relatedCollection: CollectionConfig | undefined\n  let result = value\n\n  const hasManyRelations = typeof field.relationTo !== 'string'\n\n  if (!hasManyRelations) {\n    relatedCollection = config.collections?.find(({ slug }) => slug === field.relationTo)\n  }\n\n  if (Array.isArray(value)) {\n    result = value.map((val) => {\n      // Handle has many\n      if (relatedCollection && val && (typeof val === 'string' || typeof val === 'number')) {\n        return convertValue({\n          relatedCollection,\n          value: val,\n        })\n      }\n\n      // Handle has many - polymorphic\n      if (isValidRelationObject(val)) {\n        const relatedCollectionForSingleValue = config.collections?.find(\n          ({ slug }) => slug === val.relationTo,\n        )\n\n        if (relatedCollectionForSingleValue) {\n          return {\n            relationTo: val.relationTo,\n            value: convertValue({\n              relatedCollection: relatedCollectionForSingleValue,\n              value: val.value,\n            }),\n          }\n        }\n      }\n\n      return val\n    })\n  }\n\n  // Handle has one - polymorphic\n  if (isValidRelationObject(value)) {\n    relatedCollection = config.collections?.find(({ slug }) => slug === value.relationTo)\n\n    if (relatedCollection) {\n      result = {\n        relationTo: value.relationTo,\n        value: convertValue({ relatedCollection, value: value.value }),\n      }\n    }\n  }\n\n  // Handle has one\n  if (relatedCollection && value && (typeof value === 'string' || typeof value === 'number')) {\n    result = convertValue({\n      relatedCollection,\n      value,\n    })\n  }\n  if (locale) {\n    ref[locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n\nexport const sanitizeRelationshipIDs = ({\n  config,\n  data,\n  fields,\n  parentIsLocalized,\n}: Args): Record<string, unknown> => {\n  const sanitize: TraverseFieldsCallback = ({ field, ref }) => {\n    if (!ref || typeof ref !== 'object') {\n      return\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (!ref[field.name]) {\n        return\n      }\n\n      // handle localized relationships\n      if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n        const locales = config.localization.locales\n        const fieldRef = ref[field.name]\n        if (typeof fieldRef !== 'object') {\n          return\n        }\n\n        for (const { code } of locales) {\n          const value = ref[field.name][code]\n          if (value) {\n            sanitizeRelationship({ config, field, locale: code, ref: fieldRef, value })\n          }\n        }\n      } else {\n        // handle non-localized relationships\n        sanitizeRelationship({\n          config,\n          field,\n          locale: undefined,\n          ref,\n          value: ref[field.name],\n        })\n      }\n    }\n  }\n\n  traverseFields({\n    callback: sanitize,\n    config,\n    fields,\n    fillEmpty: false,\n    parentIsLocalized,\n    ref: data,\n  })\n\n  return data\n}\n"],"names":["Types","traverseFields","fieldAffectsData","fieldShouldBeLocalized","isValidRelationObject","value","convertValue","relatedCollection","customIDField","fields","find","field","name","ObjectId","sanitizeRelationship","config","locale","ref","result","hasManyRelations","relationTo","collections","slug","Array","isArray","map","val","relatedCollectionForSingleValue","sanitizeRelationshipIDs","data","parentIsLocalized","sanitize","type","localization","locales","fieldRef","code","undefined","callback","fillEmpty"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1279, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1285, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/create.ts"],"sourcesContent":["import type { CreateOptions } from 'mongoose'\nimport type { Create, Document } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { getSession } from './utilities/getSession.js'\nimport { handleError } from './utilities/handleError.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport const create: Create = async function create(\n  this: MongooseAdapter,\n  { collection, data, req },\n) {\n  const Model = this.collections[collection]\n  const options: CreateOptions = {\n    session: await getSession(this, req),\n  }\n\n  let doc\n\n  const sanitizedData = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data,\n    fields: this.payload.collections[collection].config.fields,\n  })\n\n  if (this.payload.collections[collection].customIDType) {\n    sanitizedData._id = sanitizedData.id\n  }\n\n  try {\n    ;[doc] = await Model.create([sanitizedData], options)\n  } catch (error) {\n    handleError({ collection, error, req })\n  }\n\n  // doc.toJSON does not do stuff like converting ObjectIds to string, or date strings to date objects. That's why we use JSON.parse/stringify here\n  const result: Document = JSON.parse(JSON.stringify(doc))\n  const verificationToken = doc._verificationToken\n\n  // custom id type reset\n  result.id = result._id\n  if (verificationToken) {\n    result._verificationToken = verificationToken\n  }\n\n  return result\n}\n"],"names":["getSession","handleError","sanitizeRelationshipIDs","create","collection","data","req","Model","collections","options","session","doc","sanitizedData","config","payload","fields","customIDType","_id","id","error","result","JSON","parse","stringify","verificationToken","_verificationToken"],"mappings":";;;AAKA,SAASA,UAAU,QAAQ,4BAA2B;AACtD,SAASC,WAAW,QAAQ,6BAA4B;AACxD,SAASC,uBAAuB,QAAQ,yCAAwC;;;;AAEzE,MAAMC,SAAiB,eAAeA,OAE3C,EAAEC,UAAU,EAAEC,IAAI,EAAEC,GAAG,EAAE;IAEzB,MAAMC,QAAQ,IAAI,CAACC,WAAW,CAACJ,WAAW;IAC1C,MAAMK,UAAyB;QAC7BC,SAAS,6LAAMV,aAAAA,EAAW,IAAI,EAAEM;IAClC;IAEA,IAAIK;IAEJ,MAAMC,iBAAgBV,6NAAAA,EAAwB;QAC5CW,QAAQ,IAAI,CAACC,OAAO,CAACD,MAAM;QAC3BR;QACAU,QAAQ,IAAI,CAACD,OAAO,CAACN,WAAW,CAACJ,WAAW,CAACS,MAAM,CAACE,MAAM;IAC5D;IAEA,IAAI,IAAI,CAACD,OAAO,CAACN,WAAW,CAACJ,WAAW,CAACY,YAAY,EAAE;QACrDJ,cAAcK,GAAG,GAAGL,cAAcM,EAAE;IACtC;IAEA,IAAI;;QACD,CAACP,IAAI,GAAG,MAAMJ,MAAMJ,MAAM,CAAC;YAACS;SAAc,EAAEH;IAC/C,EAAE,OAAOU,OAAO;gMACdlB,cAAAA,EAAY;YAAEG;YAAYe;YAAOb;QAAI;IACvC;IAEA,iJAAiJ;IACjJ,MAAMc,SAAmBC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACZ;IACnD,MAAMa,oBAAoBb,IAAIc,kBAAkB;IAEhD,uBAAuB;IACvBL,OAAOF,EAAE,GAAGE,OAAOH,GAAG;IACtB,IAAIO,mBAAmB;QACrBJ,OAAOK,kBAAkB,GAAGD;IAC9B;IAEA,OAAOJ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1336, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/utilities/sanitizeInternalFields.ts"],"sourcesContent":["const internalFields = ['__v']\n\nexport const sanitizeInternalFields = <T extends Record<string, unknown>>(incomingDoc: T): T =>\n  Object.entries(incomingDoc).reduce((newDoc, [key, val]): T => {\n    if (key === '_id') {\n      return {\n        ...newDoc,\n        id: val,\n      }\n    }\n\n    if (internalFields.indexOf(key) > -1) {\n      return newDoc\n    }\n\n    return {\n      ...newDoc,\n      [key]: val,\n    }\n  }, {} as T)\n"],"names":["internalFields","sanitizeInternalFields","incomingDoc","Object","entries","reduce","newDoc","key","val","id","indexOf"],"mappings":";;;AAAA,MAAMA,iBAAiB;IAAC;CAAM;AAEvB,MAAMC,yBAAyB,CAAoCC,cACxEC,OAAOC,OAAO,CAACF,aAAaG,MAAM,CAAC,CAACC,QAAQ,CAACC,KAAKC,IAAI;QACpD,IAAID,QAAQ,OAAO;YACjB,OAAO;gBACL,GAAGD,MAAM;gBACTG,IAAID;YACN;QACF;QAEA,IAAIR,eAAeU,OAAO,CAACH,OAAO,CAAC,GAAG;YACpC,OAAOD;QACT;QAEA,OAAO;YACL,GAAGA,MAAM;YACT,CAACC,IAAI,EAAEC;QACT;IACF,GAAG,CAAC,GAAO","ignoreList":[0]}},
    {"offset": {"line": 1357, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1363, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/createGlobal.ts"],"sourcesContent":["import type { CreateOptions } from 'mongoose'\nimport type { CreateGlobal } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport const createGlobal: CreateGlobal = async function createGlobal(\n  this: MongooseAdapter,\n  { slug, data, req },\n) {\n  const Model = this.globals\n\n  const global = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data: {\n      globalType: slug,\n      ...data,\n    },\n    fields: this.payload.config.globals.find((globalConfig) => globalConfig.slug === slug).fields,\n  })\n\n  const options: CreateOptions = {\n    session: await getSession(this, req),\n  }\n\n  let [result] = (await Model.create([global], options)) as any\n\n  result = JSON.parse(JSON.stringify(result))\n\n  // custom id type reset\n  result.id = result._id\n  result = sanitizeInternalFields(result)\n\n  return result\n}\n"],"names":["getSession","sanitizeInternalFields","sanitizeRelationshipIDs","createGlobal","slug","data","req","Model","globals","global","config","payload","globalType","fields","find","globalConfig","options","session","result","create","JSON","parse","stringify","id","_id"],"mappings":";;;AAKA,SAASA,UAAU,QAAQ,4BAA2B;AACtD,SAASC,sBAAsB,QAAQ,wCAAuC;AAC9E,SAASC,uBAAuB,QAAQ,yCAAwC;;;;AAEzE,MAAMC,eAA6B,eAAeA,aAEvD,EAAEC,IAAI,EAAEC,IAAI,EAAEC,GAAG,EAAE;IAEnB,MAAMC,QAAQ,IAAI,CAACC,OAAO;IAE1B,MAAMC,6MAASP,0BAAAA,EAAwB;QACrCQ,QAAQ,IAAI,CAACC,OAAO,CAACD,MAAM;QAC3BL,MAAM;YACJO,YAAYR;YACZ,GAAGC,IAAI;QACT;QACAQ,QAAQ,IAAI,CAACF,OAAO,CAACD,MAAM,CAACF,OAAO,CAACM,IAAI,CAAC,CAACC,eAAiBA,aAAaX,IAAI,KAAKA,MAAMS,MAAM;IAC/F;IAEA,MAAMG,UAAyB;QAC7BC,SAAS,6LAAMjB,aAAAA,EAAW,IAAI,EAAEM;IAClC;IAEA,IAAI,CAACY,OAAO,GAAI,MAAMX,MAAMY,MAAM,CAAC;QAACV;KAAO,EAAEO;IAE7CE,SAASE,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACJ;IAEnC,uBAAuB;IACvBA,OAAOK,EAAE,GAAGL,OAAOM,GAAG;IACtBN,4MAASjB,yBAAAA,EAAuBiB;IAEhC,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1394, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1400, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/createGlobalVersion.ts"],"sourcesContent":["import type { CreateOptions } from 'mongoose'\n\nimport { buildVersionGlobalFields, type CreateGlobalVersion, type Document } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport const createGlobalVersion: CreateGlobalVersion = async function createGlobalVersion(\n  this: MongooseAdapter,\n  {\n    autosave,\n    createdAt,\n    globalSlug,\n    parent,\n    publishedLocale,\n    req,\n    snapshot,\n    updatedAt,\n    versionData,\n  },\n) {\n  const VersionModel = this.versions[globalSlug]\n  const options: CreateOptions = {\n    session: await getSession(this, req),\n  }\n\n  const data = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data: {\n      autosave,\n      createdAt,\n      latest: true,\n      parent,\n      publishedLocale,\n      snapshot,\n      updatedAt,\n      version: versionData,\n    },\n    fields: buildVersionGlobalFields(\n      this.payload.config,\n      this.payload.config.globals.find((global) => global.slug === globalSlug),\n    ),\n  })\n\n  const [doc] = await VersionModel.create([data], options, req)\n\n  await VersionModel.updateMany(\n    {\n      $and: [\n        {\n          _id: {\n            $ne: doc._id,\n          },\n        },\n        {\n          parent: {\n            $eq: parent,\n          },\n        },\n        {\n          latest: {\n            $eq: true,\n          },\n        },\n      ],\n    },\n    { $unset: { latest: 1 } },\n    options,\n  )\n\n  const result: Document = JSON.parse(JSON.stringify(doc))\n  const verificationToken = doc._verificationToken\n\n  // custom id type reset\n  result.id = result._id\n  if (verificationToken) {\n    result._verificationToken = verificationToken\n  }\n  return result\n}\n"],"names":["buildVersionGlobalFields","getSession","sanitizeRelationshipIDs","createGlobalVersion","autosave","createdAt","globalSlug","parent","publishedLocale","req","snapshot","updatedAt","versionData","VersionModel","versions","options","session","data","config","payload","latest","version","fields","globals","find","global","slug","doc","create","updateMany","$and","_id","$ne","$eq","$unset","result","JSON","parse","stringify","verificationToken","_verificationToken","id"],"mappings":";;;AAMA,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,uBAAuB,QAAQ,yCAAwC;AALhF,SAASF,wBAAwB,QAAiD,UAAS;;;;AAOpF,MAAMG,sBAA2C,eAAeA,oBAErE,EACEC,QAAQ,EACRC,SAAS,EACTC,UAAU,EACVC,MAAM,EACNC,eAAe,EACfC,GAAG,EACHC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACZ;IAED,MAAMC,eAAe,IAAI,CAACC,QAAQ,CAACR,WAAW;IAC9C,MAAMS,UAAyB;QAC7BC,SAAS,6LAAMf,aAAAA,EAAW,IAAI,EAAEQ;IAClC;IAEA,MAAMQ,2MAAOf,0BAAAA,EAAwB;QACnCgB,QAAQ,IAAI,CAACC,OAAO,CAACD,MAAM;QAC3BD,MAAM;YACJb;YACAC;YACAe,QAAQ;YACRb;YACAC;YACAE;YACAC;YACAU,SAAST;QACX;QACAU,+KAAQtB,2BAAAA,EACN,IAAI,CAACmB,OAAO,CAACD,MAAM,EACnB,IAAI,CAACC,OAAO,CAACD,MAAM,CAACK,OAAO,CAACC,IAAI,CAAC,CAACC,SAAWA,OAAOC,IAAI,KAAKpB;IAEjE;IAEA,MAAM,CAACqB,IAAI,GAAG,MAAMd,aAAae,MAAM,CAAC;QAACX;KAAK,EAAEF,SAASN;IAEzD,MAAMI,aAAagB,UAAU,CAC3B;QACEC,MAAM;YACJ;gBACEC,KAAK;oBACHC,KAAKL,IAAII,GAAG;gBACd;YACF;YACA;gBACExB,QAAQ;oBACN0B,KAAK1B;gBACP;YACF;YACA;gBACEa,QAAQ;oBACNa,KAAK;gBACP;YACF;SACD;IACH,GACA;QAAEC,QAAQ;YAAEd,QAAQ;QAAE;IAAE,GACxBL;IAGF,MAAMoB,SAAmBC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACX;IACnD,MAAMY,oBAAoBZ,IAAIa,kBAAkB;IAEhD,uBAAuB;IACvBL,OAAOM,EAAE,GAAGN,OAAOJ,GAAG;IACtB,IAAIQ,mBAAmB;QACrBJ,OAAOK,kBAAkB,GAAGD;IAC9B;IACA,OAAOJ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1463, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1469, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/createMigration.ts"],"sourcesContent":["import type { CreateMigration, MigrationTemplateArgs } from 'payload'\n\nimport fs from 'fs'\nimport path from 'path'\nimport { getPredefinedMigration, writeMigrationIndex } from 'payload'\nimport { fileURLToPath } from 'url'\n\nconst migrationTemplate = ({ downSQL, imports, upSQL }: MigrationTemplateArgs): string => `import {\n  MigrateDownArgs,\n  MigrateUpArgs,\n} from '@payloadcms/db-mongodb'\n${imports ?? ''}\nexport async function up({ payload, req, session }: MigrateUpArgs): Promise<void> {\n${upSQL ?? `  // Migration code`}\n}\n\nexport async function down({ payload, req, session }: MigrateDownArgs): Promise<void> {\n${downSQL ?? `  // Migration code`}\n}\n`\n\nexport const createMigration: CreateMigration = async function createMigration({\n  file,\n  migrationName,\n  payload,\n  skipEmpty,\n}) {\n  const filename = fileURLToPath(import.meta.url)\n  const dirname = path.dirname(filename)\n\n  const dir = payload.db.migrationDir\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir)\n  }\n  const predefinedMigration = await getPredefinedMigration({\n    dirname,\n    file,\n    migrationName,\n    payload,\n  })\n\n  const migrationFileContent = migrationTemplate(predefinedMigration)\n\n  const [yyymmdd, hhmmss] = new Date().toISOString().split('T')\n  const formattedDate = yyymmdd.replace(/\\D/g, '')\n  const formattedTime = hhmmss.split('.')[0].replace(/\\D/g, '')\n\n  const timestamp = `${formattedDate}_${formattedTime}`\n\n  const formattedName = migrationName?.replace(/\\W/g, '_')\n  const fileName = migrationName ? `${timestamp}_${formattedName}.ts` : `${timestamp}_migration.ts`\n  const filePath = `${dir}/${fileName}`\n\n  if (!skipEmpty) {\n    fs.writeFileSync(filePath, migrationFileContent)\n  }\n\n  writeMigrationIndex({ migrationsDir: payload.db.migrationDir })\n\n  payload.logger.info({ msg: `Migration created at ${filePath}` })\n}\n"],"names":["fs","path","getPredefinedMigration","writeMigrationIndex","fileURLToPath","migrationTemplate","downSQL","imports","upSQL","createMigration","file","migrationName","payload","skipEmpty","filename","url","dirname","dir","db","migrationDir","existsSync","mkdirSync","predefinedMigration","migrationFileContent","yyymmdd","hhmmss","Date","toISOString","split","formattedDate","replace","formattedTime","timestamp","formattedName","fileName","filePath","writeFileSync","migrationsDir","logger","info","msg"],"mappings":";;;AAEA,OAAOA,QAAQ,KAAI;AACnB,OAAOC,UAAU,OAAM;AAEvB,SAASG,aAAa,QAAQ,MAAK;AADnC,SAASF,sBAAsB,EAAEC,mBAAmB,QAAQ,UAAS;;;;;;;;;;;AAGrE,MAAME,oBAAoB,CAAC,EAAEC,OAAO,EAAEC,OAAO,EAAEC,KAAK,EAAyB,GAAa,CAAC;;;;AAI3F,EAAED,WAAW,GAAG;;AAEhB,EAAEC,SAAS,CAAC,mBAAmB,CAAC,CAAC;;;;AAIjC,EAAEF,WAAW,CAAC,mBAAmB,CAAC,CAAC;;AAEnC,CAAC;AAEM,MAAMG,kBAAmC,eAAeA,gBAAgB,EAC7EC,IAAI,EACJC,aAAa,EACbC,OAAO,EACPC,SAAS,EACV;IACC,MAAMC,+GAAWV,gBAAAA,EAAc,8BAAYW,GAAG;IAC9C,MAAMC,4GAAUf,UAAAA,CAAKe,OAAO,CAACF;IAE7B,MAAMG,MAAML,QAAQM,EAAE,CAACC,YAAY;IACnC,IAAI,+FAACnB,UAAAA,CAAGoB,UAAU,CAACH,MAAM;sGACvBjB,UAAAA,CAAGqB,SAAS,CAACJ;IACf;IACA,MAAMK,sBAAsB,gMAAMpB,yBAAAA,EAAuB;QACvDc;QACAN;QACAC;QACAC;IACF;IAEA,MAAMW,uBAAuBlB,kBAAkBiB;IAE/C,MAAM,CAACE,SAASC,OAAO,GAAG,IAAIC,OAAOC,WAAW,GAAGC,KAAK,CAAC;IACzD,MAAMC,gBAAgBL,QAAQM,OAAO,CAAC,OAAO;IAC7C,MAAMC,gBAAgBN,OAAOG,KAAK,CAAC,IAAI,CAAC,EAAE,CAACE,OAAO,CAAC,OAAO;IAE1D,MAAME,YAAY,GAAGH,cAAc,CAAC,EAAEE,eAAe;IAErD,MAAME,gBAAgBtB,eAAemB,QAAQ,OAAO;IACpD,MAAMI,WAAWvB,gBAAgB,GAAGqB,UAAU,CAAC,EAAEC,cAAc,GAAG,CAAC,GAAG,GAAGD,UAAU,aAAa,CAAC;IACjG,MAAMG,WAAW,GAAGlB,IAAI,CAAC,EAAEiB,UAAU;IAErC,IAAI,CAACrB,WAAW;sGACdb,UAAAA,CAAGoC,aAAa,CAACD,UAAUZ;IAC7B;2LAEApB,sBAAAA,EAAoB;QAAEkC,eAAezB,QAAQM,EAAE,CAACC,YAAY;IAAC;IAE7DP,QAAQ0B,MAAM,CAACC,IAAI,CAAC;QAAEC,KAAK,CAAC,qBAAqB,EAAEL,UAAU;IAAC;AAChE,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1530, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1536, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/createVersion.ts"],"sourcesContent":["import type { CreateOptions } from 'mongoose'\n\nimport { Types } from 'mongoose'\nimport { buildVersionCollectionFields, type CreateVersion, type Document } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport const createVersion: CreateVersion = async function createVersion(\n  this: MongooseAdapter,\n  {\n    autosave,\n    collectionSlug,\n    createdAt,\n    parent,\n    publishedLocale,\n    req,\n    snapshot,\n    updatedAt,\n    versionData,\n  },\n) {\n  const VersionModel = this.versions[collectionSlug]\n  const options: CreateOptions = {\n    session: await getSession(this, req),\n  }\n\n  const data = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data: {\n      autosave,\n      createdAt,\n      latest: true,\n      parent,\n      publishedLocale,\n      snapshot,\n      updatedAt,\n      version: versionData,\n    },\n    fields: buildVersionCollectionFields(\n      this.payload.config,\n      this.payload.collections[collectionSlug].config,\n    ),\n  })\n\n  const [doc] = await VersionModel.create([data], options, req)\n\n  const parentQuery = {\n    $or: [\n      {\n        parent: {\n          $eq: data.parent,\n        },\n      },\n    ],\n  }\n  if (data.parent instanceof Types.ObjectId) {\n    parentQuery.$or.push({\n      parent: {\n        $eq: data.parent.toString(),\n      },\n    })\n  }\n\n  await VersionModel.updateMany(\n    {\n      $and: [\n        {\n          _id: {\n            $ne: doc._id,\n          },\n        },\n        parentQuery,\n        {\n          latest: {\n            $eq: true,\n          },\n        },\n        {\n          updatedAt: {\n            $lt: new Date(doc.updatedAt),\n          },\n        },\n      ],\n    },\n    { $unset: { latest: 1 } },\n    options,\n  )\n\n  const result: Document = JSON.parse(JSON.stringify(doc))\n  const verificationToken = doc._verificationToken\n\n  // custom id type reset\n  result.id = result._id\n  if (verificationToken) {\n    result._verificationToken = verificationToken\n  }\n  return result\n}\n"],"names":["Types","buildVersionCollectionFields","getSession","sanitizeRelationshipIDs","createVersion","autosave","collectionSlug","createdAt","parent","publishedLocale","req","snapshot","updatedAt","versionData","VersionModel","versions","options","session","data","config","payload","latest","version","fields","collections","doc","create","parentQuery","$or","$eq","ObjectId","push","toString","updateMany","$and","_id","$ne","$lt","Date","$unset","result","JSON","parse","stringify","verificationToken","_verificationToken","id"],"mappings":";;;AAEA,SAASA,KAAK,QAAQ,WAAU;AAKhC,SAASE,UAAU,QAAQ,4BAA2B;AACtD,SAASC,uBAAuB,QAAQ,yCAAwC;AALhF,SAASF,4BAA4B,QAA2C,UAAS;;;;;AAOlF,MAAMG,gBAA+B,eAAeA,cAEzD,EACEC,QAAQ,EACRC,cAAc,EACdC,SAAS,EACTC,MAAM,EACNC,eAAe,EACfC,GAAG,EACHC,QAAQ,EACRC,SAAS,EACTC,WAAW,EACZ;IAED,MAAMC,eAAe,IAAI,CAACC,QAAQ,CAACT,eAAe;IAClD,MAAMU,UAAyB;QAC7BC,SAAS,UAAMf,gMAAAA,EAAW,IAAI,EAAEQ;IAClC;IAEA,MAAMQ,2MAAOf,0BAAAA,EAAwB;QACnCgB,QAAQ,IAAI,CAACC,OAAO,CAACD,MAAM;QAC3BD,MAAM;YACJb;YACAE;YACAc,QAAQ;YACRb;YACAC;YACAE;YACAC;YACAU,SAAST;QACX;QACAU,mLAAQtB,+BAAAA,EACN,IAAI,CAACmB,OAAO,CAACD,MAAM,EACnB,IAAI,CAACC,OAAO,CAACI,WAAW,CAAClB,eAAe,CAACa,MAAM;IAEnD;IAEA,MAAM,CAACM,IAAI,GAAG,MAAMX,aAAaY,MAAM,CAAC;QAACR;KAAK,EAAEF,SAASN;IAEzD,MAAMiB,cAAc;QAClBC,KAAK;YACH;gBACEpB,QAAQ;oBACNqB,KAAKX,KAAKV,MAAM;gBAClB;YACF;SACD;IACH;IACA,IAAIU,KAAKV,MAAM,sHAAYR,QAAAA,CAAM8B,QAAQ,EAAE;QACzCH,YAAYC,GAAG,CAACG,IAAI,CAAC;YACnBvB,QAAQ;gBACNqB,KAAKX,KAAKV,MAAM,CAACwB,QAAQ;YAC3B;QACF;IACF;IAEA,MAAMlB,aAAamB,UAAU,CAC3B;QACEC,MAAM;YACJ;gBACEC,KAAK;oBACHC,KAAKX,IAAIU,GAAG;gBACd;YACF;YACAR;YACA;gBACEN,QAAQ;oBACNQ,KAAK;gBACP;YACF;YACA;gBACEjB,WAAW;oBACTyB,KAAK,IAAIC,KAAKb,IAAIb,SAAS;gBAC7B;YACF;SACD;IACH,GACA;QAAE2B,QAAQ;YAAElB,QAAQ;QAAE;IAAE,GACxBL;IAGF,MAAMwB,SAAmBC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAAClB;IACnD,MAAMmB,oBAAoBnB,IAAIoB,kBAAkB;IAEhD,uBAAuB;IACvBL,OAAOM,EAAE,GAAGN,OAAOL,GAAG;IACtB,IAAIS,mBAAmB;QACrBJ,OAAOK,kBAAkB,GAAGD;IAC9B;IACA,OAAOJ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1618, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1624, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/deleteMany.ts"],"sourcesContent":["import type { DeleteOptions } from 'mongodb'\nimport type { DeleteMany } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getSession } from './utilities/getSession.js'\n\nexport const deleteMany: DeleteMany = async function deleteMany(\n  this: MongooseAdapter,\n  { collection, req, where },\n) {\n  const Model = this.collections[collection]\n  const options: DeleteOptions = {\n    session: await getSession(this, req),\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    collectionSlug: collection,\n    fields: this.payload.collections[collection].config.flattenedFields,\n    where,\n  })\n\n  await Model.deleteMany(query, options)\n}\n"],"names":["buildQuery","getSession","deleteMany","collection","req","where","Model","collections","options","session","query","adapter","collectionSlug","fields","payload","config","flattenedFields"],"mappings":";;;AAKA,SAASA,UAAU,QAAQ,0BAAyB;AACpD,SAASC,UAAU,QAAQ,4BAA2B;;;AAE/C,MAAMC,aAAyB,eAAeA,WAEnD,EAAEC,UAAU,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAE1B,MAAMC,QAAQ,IAAI,CAACC,WAAW,CAACJ,WAAW;IAC1C,MAAMK,UAAyB;QAC7BC,SAAS,6LAAMR,aAAAA,EAAW,IAAI,EAAEG;IAClC;IAEA,MAAMM,QAAQ,MAAMV,kMAAAA,EAAW;QAC7BW,SAAS,IAAI;QACbC,gBAAgBT;QAChBU,QAAQ,IAAI,CAACC,OAAO,CAACP,WAAW,CAACJ,WAAW,CAACY,MAAM,CAACC,eAAe;QACnEX;IACF;IAEA,MAAMC,MAAMJ,UAAU,CAACQ,OAAOF;AAChC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1644, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1650, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/utilities/buildProjectionFromSelect.ts"],"sourcesContent":["import type { FieldAffectingData, FlattenedField, SelectMode, SelectType } from 'payload'\n\nimport {\n  deepCopyObjectSimple,\n  fieldAffectsData,\n  fieldShouldBeLocalized,\n  getSelectMode,\n} from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\n\nconst addFieldToProjection = ({\n  adapter,\n  databaseSchemaPath,\n  field,\n  parentIsLocalized,\n  projection,\n}: {\n  adapter: MongooseAdapter\n  databaseSchemaPath: string\n  field: FieldAffectingData\n  parentIsLocalized: boolean\n  projection: Record<string, true>\n}) => {\n  const { config } = adapter.payload\n\n  if (parentIsLocalized && config.localization) {\n    for (const locale of config.localization.localeCodes) {\n      const localeDatabaseSchemaPath = databaseSchemaPath.replace('<locale>', locale)\n      projection[`${localeDatabaseSchemaPath}${field.name}`] = true\n    }\n  } else {\n    projection[`${databaseSchemaPath}${field.name}`] = true\n  }\n}\n\nconst traverseFields = ({\n  adapter,\n  databaseSchemaPath = '',\n  fields,\n  parentIsLocalized = false,\n  projection,\n  select,\n  selectAllOnCurrentLevel = false,\n  selectMode,\n}: {\n  adapter: MongooseAdapter\n  databaseSchemaPath?: string\n  fields: FlattenedField[]\n  parentIsLocalized?: boolean\n  projection: Record<string, true>\n  select: SelectType\n  selectAllOnCurrentLevel?: boolean\n  selectMode: SelectMode\n}) => {\n  for (const field of fields) {\n    if (fieldAffectsData(field)) {\n      if (selectMode === 'include') {\n        if (select[field.name] === true || selectAllOnCurrentLevel) {\n          addFieldToProjection({\n            adapter,\n            databaseSchemaPath,\n            field,\n            parentIsLocalized,\n            projection,\n          })\n          continue\n        }\n\n        if (!select[field.name]) {\n          continue\n        }\n      }\n\n      if (selectMode === 'exclude') {\n        if (typeof select[field.name] === 'undefined') {\n          addFieldToProjection({\n            adapter,\n            databaseSchemaPath,\n            field,\n            parentIsLocalized,\n            projection,\n          })\n          continue\n        }\n\n        if (select[field.name] === false) {\n          continue\n        }\n      }\n    }\n\n    let fieldDatabaseSchemaPath = databaseSchemaPath\n\n    if (fieldAffectsData(field)) {\n      fieldDatabaseSchemaPath = `${databaseSchemaPath}${field.name}.`\n\n      if (fieldShouldBeLocalized({ field, parentIsLocalized })) {\n        fieldDatabaseSchemaPath = `${fieldDatabaseSchemaPath}<locale>.`\n      }\n    }\n\n    switch (field.type) {\n      case 'array':\n      case 'group':\n      case 'tab': {\n        const fieldSelect = select[field.name] as SelectType\n\n        if (field.type === 'array' && selectMode === 'include') {\n          fieldSelect['id'] = true\n        }\n\n        traverseFields({\n          adapter,\n          databaseSchemaPath: fieldDatabaseSchemaPath,\n          fields: field.flattenedFields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          projection,\n          select: fieldSelect,\n          selectMode,\n        })\n\n        break\n      }\n\n      case 'blocks': {\n        const blocksSelect = select[field.name] as SelectType\n\n        for (const _block of field.blockReferences ?? field.blocks) {\n          const block = typeof _block === 'string' ? adapter.payload.blocks[_block] : _block\n          if (\n            (selectMode === 'include' && blocksSelect[block.slug] === true) ||\n            (selectMode === 'exclude' && typeof blocksSelect[block.slug] === 'undefined')\n          ) {\n            traverseFields({\n              adapter,\n              databaseSchemaPath: fieldDatabaseSchemaPath,\n              fields: block.flattenedFields,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              projection,\n              select: {},\n              selectAllOnCurrentLevel: true,\n              selectMode: 'include',\n            })\n            continue\n          }\n\n          let blockSelectMode = selectMode\n\n          if (selectMode === 'exclude' && blocksSelect[block.slug] === false) {\n            blockSelectMode = 'include'\n          }\n\n          if (typeof blocksSelect[block.slug] !== 'object') {\n            blocksSelect[block.slug] = {}\n          }\n\n          if (blockSelectMode === 'include') {\n            blocksSelect[block.slug]['id'] = true\n            blocksSelect[block.slug]['blockType'] = true\n          }\n\n          traverseFields({\n            adapter,\n            databaseSchemaPath: fieldDatabaseSchemaPath,\n            fields: block.flattenedFields,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            projection,\n            select: blocksSelect[block.slug] as SelectType,\n            selectMode: blockSelectMode,\n          })\n        }\n\n        break\n      }\n\n      default:\n        break\n    }\n  }\n}\n\nexport const buildProjectionFromSelect = ({\n  adapter,\n  fields,\n  select,\n}: {\n  adapter: MongooseAdapter\n  fields: FlattenedField[]\n  select?: SelectType\n}): Record<string, true> | undefined => {\n  if (!select) {\n    return\n  }\n\n  const projection: Record<string, true> = {\n    _id: true,\n  }\n\n  traverseFields({\n    adapter,\n    fields,\n    projection,\n    // Clone to safely mutate it later\n    select: deepCopyObjectSimple(select),\n    selectMode: getSelectMode(select),\n  })\n\n  return projection\n}\n"],"names":["deepCopyObjectSimple","fieldAffectsData","fieldShouldBeLocalized","getSelectMode","addFieldToProjection","adapter","databaseSchemaPath","field","parentIsLocalized","projection","config","payload","localization","locale","localeCodes","localeDatabaseSchemaPath","replace","name","traverseFields","fields","select","selectAllOnCurrentLevel","selectMode","fieldDatabaseSchemaPath","type","fieldSelect","flattenedFields","localized","blocksSelect","_block","blockReferences","blocks","block","slug","blockSelectMode","buildProjectionFromSelect","_id"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1795, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1801, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/deleteOne.ts"],"sourcesContent":["import type { QueryOptions } from 'mongoose'\nimport type { DeleteOne, Document } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\n\nexport const deleteOne: DeleteOne = async function deleteOne(\n  this: MongooseAdapter,\n  { collection, req, select, where },\n) {\n  const Model = this.collections[collection]\n  const options: QueryOptions = {\n    projection: buildProjectionFromSelect({\n      adapter: this,\n      fields: this.payload.collections[collection].config.flattenedFields,\n      select,\n    }),\n    session: await getSession(this, req),\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    collectionSlug: collection,\n    fields: this.payload.collections[collection].config.flattenedFields,\n    where,\n  })\n\n  const doc = await Model.findOneAndDelete(query, options)?.lean()\n\n  if (!doc) {\n    return null\n  }\n\n  let result: Document = JSON.parse(JSON.stringify(doc))\n\n  // custom id type reset\n  result.id = result._id\n  result = sanitizeInternalFields(result)\n\n  return result\n}\n"],"names":["buildQuery","buildProjectionFromSelect","getSession","sanitizeInternalFields","deleteOne","collection","req","select","where","Model","collections","options","projection","adapter","fields","payload","config","flattenedFields","session","query","collectionSlug","doc","findOneAndDelete","lean","result","JSON","parse","stringify","id","_id"],"mappings":";;;AAKA,SAASA,UAAU,QAAQ,0BAAyB;AACpD,SAASC,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,sBAAsB,QAAQ,wCAAuC;;;;;AAEvE,MAAMC,YAAuB,eAAeA,UAEjD,EAAEC,UAAU,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAElC,MAAMC,QAAQ,IAAI,CAACC,WAAW,CAACL,WAAW;IAC1C,MAAMM,UAAwB;QAC5BC,kNAAYX,4BAAAA,EAA0B;YACpCY,SAAS,IAAI;YACbC,QAAQ,IAAI,CAACC,OAAO,CAACL,WAAW,CAACL,WAAW,CAACW,MAAM,CAACC,eAAe;YACnEV;QACF;QACAW,SAAS,6LAAMhB,aAAAA,EAAW,IAAI,EAAEI;IAClC;IAEA,MAAMa,QAAQ,2LAAMnB,aAAAA,EAAW;QAC7Ba,SAAS,IAAI;QACbO,gBAAgBf;QAChBS,QAAQ,IAAI,CAACC,OAAO,CAACL,WAAW,CAACL,WAAW,CAACW,MAAM,CAACC,eAAe;QACnET;IACF;IAEA,MAAMa,MAAM,MAAMZ,MAAMa,gBAAgB,CAACH,OAAOR,UAAUY;IAE1D,IAAI,CAACF,KAAK;QACR,OAAO;IACT;IAEA,IAAIG,SAAmBC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACN;IAEjD,uBAAuB;IACvBG,OAAOI,EAAE,GAAGJ,OAAOK,GAAG;IACtBL,4MAASrB,yBAAAA,EAAuBqB;IAEhC,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1838, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1844, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/deleteVersions.ts"],"sourcesContent":["import { buildVersionCollectionFields, type DeleteVersions } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { getSession } from './utilities/getSession.js'\n\nexport const deleteVersions: DeleteVersions = async function deleteVersions(\n  this: MongooseAdapter,\n  { collection, locale, req, where },\n) {\n  const VersionsModel = this.versions[collection]\n\n  const session = await getSession(this, req)\n\n  const query = await buildQuery({\n    adapter: this,\n    fields: buildVersionCollectionFields(\n      this.payload.config,\n      this.payload.collections[collection].config,\n      true,\n    ),\n    locale,\n    where,\n  })\n\n  await VersionsModel.deleteMany(query, { session })\n}\n"],"names":["buildVersionCollectionFields","buildQuery","getSession","deleteVersions","collection","locale","req","where","VersionsModel","versions","session","query","adapter","fields","payload","config","collections","deleteMany"],"mappings":";;;AAIA,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,UAAU,QAAQ,4BAA2B;AALtD,SAASF,4BAA4B,QAA6B,UAAS;;;;AAOpE,MAAMG,iBAAiC,eAAeA,eAE3D,EAAEC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,KAAK,EAAE;IAElC,MAAMC,gBAAgB,IAAI,CAACC,QAAQ,CAACL,WAAW;IAE/C,MAAMM,UAAU,6LAAMR,aAAAA,EAAW,IAAI,EAAEI;IAEvC,MAAMK,QAAQ,2LAAMV,aAAAA,EAAW;QAC7BW,SAAS,IAAI;QACbC,mLAAQb,+BAAAA,EACN,IAAI,CAACc,OAAO,CAACC,MAAM,EACnB,IAAI,CAACD,OAAO,CAACE,WAAW,CAACZ,WAAW,CAACW,MAAM,EAC3C;QAEFV;QACAE;IACF;IAEA,MAAMC,cAAcS,UAAU,CAACN,OAAO;QAAED;IAAQ;AAClD,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1866, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/destroy.ts"],"sourcesContent":["import type { Destroy } from 'payload'\n\nimport mongoose from 'mongoose'\n\nimport type { MongooseAdapter } from './index.js'\n\nexport const destroy: Destroy = async function destroy(this: MongooseAdapter) {\n  if (this.mongoMemoryServer) {\n    await this.mongoMemoryServer.stop()\n  } else {\n    await mongoose.disconnect()\n  }\n\n  Object.keys(mongoose.models).map((model) => mongoose.deleteModel(model))\n}\n"],"names":["mongoose","destroy","mongoMemoryServer","stop","disconnect","Object","keys","models","map","model","deleteModel"],"mappings":";;;AAEA,OAAOA,cAAc,WAAU;;AAIxB,MAAMC,UAAmB,eAAeA;IAC7C,IAAI,IAAI,CAACC,iBAAiB,EAAE;QAC1B,MAAM,IAAI,CAACA,iBAAiB,CAACC,IAAI;IACnC,OAAO;QACL,gHAAMH,UAAAA,CAASI,UAAU;IAC3B;IAEAC,OAAOC,IAAI,2GAACN,UAAAA,CAASO,MAAM,EAAEC,GAAG,CAAC,CAACC,kHAAUT,UAAAA,CAASU,WAAW,CAACD;AACnE,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1885, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1891, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/getLocalizedSortProperty.ts"],"sourcesContent":["import type { FlattenedField, SanitizedConfig } from 'payload'\n\nimport { fieldAffectsData, fieldIsPresentationalOnly, fieldShouldBeLocalized } from 'payload/shared'\n\ntype Args = {\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  locale: string\n  parentIsLocalized: boolean\n  result?: string\n  segments: string[]\n}\n\nexport const getLocalizedSortProperty = ({\n  config,\n  fields,\n  locale,\n  parentIsLocalized,\n  result: incomingResult,\n  segments: incomingSegments,\n}: Args): string => {\n  // If localization is not enabled, accept exactly\n  // what is sent in\n  if (!config.localization) {\n    return incomingSegments.join('.')\n  }\n\n  const segments = [...incomingSegments]\n\n  // Retrieve first segment, and remove from segments\n  const firstSegment = segments.shift()\n\n  // Attempt to find a matched field\n  const matchedField = fields.find(\n    (field) => fieldAffectsData(field) && field.name === firstSegment,\n  )\n\n  if (matchedField && !fieldIsPresentationalOnly(matchedField)) {\n    let nextFields: FlattenedField[]\n    let nextParentIsLocalized = parentIsLocalized\n    const remainingSegments = [...segments]\n    let localizedSegment = matchedField.name\n\n    if (fieldShouldBeLocalized({ field: matchedField, parentIsLocalized })) {\n      // Check to see if next segment is a locale\n      if (segments.length > 0) {\n        const nextSegmentIsLocale = config.localization.localeCodes.includes(remainingSegments[0])\n\n        // If next segment is locale, remove it from remaining segments\n        // and use it to localize the current segment\n        if (nextSegmentIsLocale) {\n          const nextSegment = remainingSegments.shift()\n          localizedSegment = `${matchedField.name}.${nextSegment}`\n        }\n      } else {\n        // If no more segments, but field is localized, use default locale\n        localizedSegment = `${matchedField.name}.${locale}`\n      }\n    }\n\n    // If there are subfields, pass them through\n    if (\n      matchedField.type === 'tab' ||\n      matchedField.type === 'group' ||\n      matchedField.type === 'array'\n    ) {\n      nextFields = matchedField.flattenedFields\n      if (!nextParentIsLocalized) {\n        nextParentIsLocalized = matchedField.localized\n      }\n    }\n\n    if (matchedField.type === 'blocks') {\n      nextFields = (matchedField.blockReferences ?? matchedField.blocks).reduce(\n        (flattenedBlockFields, _block) => {\n          // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n          const block =\n            typeof _block === 'string' ? config.blocks.find((b) => b.slug === _block) : _block\n          return [\n            ...flattenedBlockFields,\n            ...block.flattenedFields.filter(\n              (blockField) =>\n                (fieldAffectsData(blockField) &&\n                  blockField.name !== 'blockType' &&\n                  blockField.name !== 'blockName') ||\n                !fieldAffectsData(blockField),\n            ),\n          ]\n        },\n        [],\n      )\n    }\n\n    const result = incomingResult ? `${incomingResult}.${localizedSegment}` : localizedSegment\n\n    if (nextFields) {\n      return getLocalizedSortProperty({\n        config,\n        fields: nextFields,\n        locale,\n        parentIsLocalized: nextParentIsLocalized,\n        result,\n        segments: remainingSegments,\n      })\n    }\n\n    return result\n  }\n\n  return incomingSegments.join('.')\n}\n"],"names":["fieldAffectsData","fieldIsPresentationalOnly","fieldShouldBeLocalized","getLocalizedSortProperty","config","fields","locale","parentIsLocalized","result","incomingResult","segments","incomingSegments","localization","join","firstSegment","shift","matchedField","find","field","name","nextFields","nextParentIsLocalized","remainingSegments","localizedSegment","length","nextSegmentIsLocale","localeCodes","includes","nextSegment","type","flattenedFields","localized","blockReferences","blocks","reduce","flattenedBlockFields","_block","block","b","slug","filter","blockField"],"mappings":";;;AAEA,SAASA,gBAAgB,EAAEC,yBAAyB,EAAEC,sBAAsB,QAAQ,iBAAgB;;AAW7F,MAAMC,2BAA2B,CAAC,EACvCC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,iBAAiB,EACjBC,QAAQC,cAAc,EACtBC,UAAUC,gBAAgB,EACrB;IACL,iDAAiD;IACjD,kBAAkB;IAClB,IAAI,CAACP,OAAOQ,YAAY,EAAE;QACxB,OAAOD,iBAAiBE,IAAI,CAAC;IAC/B;IAEA,MAAMH,WAAW;WAAIC;KAAiB;IAEtC,mDAAmD;IACnD,MAAMG,eAAeJ,SAASK,KAAK;IAEnC,kCAAkC;IAClC,MAAMC,eAAeX,OAAOY,IAAI,CAC9B,CAACC,2KAAUlB,mBAAAA,EAAiBkB,UAAUA,MAAMC,IAAI,KAAKL;IAGvD,IAAIE,gBAAgB,KAACf,2LAAAA,EAA0Be,eAAe;QAC5D,IAAII;QACJ,IAAIC,wBAAwBd;QAC5B,MAAMe,oBAAoB;eAAIZ;SAAS;QACvC,IAAIa,mBAAmBP,aAAaG,IAAI;QAExC,uKAAIjB,yBAAAA,EAAuB;YAAEgB,OAAOF;YAAcT;QAAkB,IAAI;YACtE,2CAA2C;YAC3C,IAAIG,SAASc,MAAM,GAAG,GAAG;gBACvB,MAAMC,sBAAsBrB,OAAOQ,YAAY,CAACc,WAAW,CAACC,QAAQ,CAACL,iBAAiB,CAAC,EAAE;gBAEzF,+DAA+D;gBAC/D,6CAA6C;gBAC7C,IAAIG,qBAAqB;oBACvB,MAAMG,cAAcN,kBAAkBP,KAAK;oBAC3CQ,mBAAmB,GAAGP,aAAaG,IAAI,CAAC,CAAC,EAAES,aAAa;gBAC1D;YACF,OAAO;gBACL,kEAAkE;gBAClEL,mBAAmB,GAAGP,aAAaG,IAAI,CAAC,CAAC,EAAEb,QAAQ;YACrD;QACF;QAEA,4CAA4C;QAC5C,IACEU,aAAaa,IAAI,KAAK,SACtBb,aAAaa,IAAI,KAAK,WACtBb,aAAaa,IAAI,KAAK,SACtB;YACAT,aAAaJ,aAAac,eAAe;YACzC,IAAI,CAACT,uBAAuB;gBAC1BA,wBAAwBL,aAAae,SAAS;YAChD;QACF;QAEA,IAAIf,aAAaa,IAAI,KAAK,UAAU;YAClCT,aAAcJ,CAAAA,aAAagB,eAAe,IAAIhB,aAAaiB,MAAK,EAAGC,MAAM,CACvE,CAACC,sBAAsBC;gBACrB,uFAAuF;gBACvF,MAAMC,QACJ,OAAOD,WAAW,WAAWhC,OAAO6B,MAAM,CAAChB,IAAI,CAAC,CAACqB,IAAMA,EAAEC,IAAI,KAAKH,UAAUA;gBAC9E,OAAO;uBACFD;uBACAE,MAAMP,eAAe,CAACU,MAAM,CAC7B,CAACC,cACEzC,qLAAAA,EAAiByC,eAChBA,WAAWtB,IAAI,KAAK,eACpBsB,WAAWtB,IAAI,KAAK,eACtB,CAACnB,sLAAAA,EAAiByC;iBAEvB;YACH,GACA,EAAE;QAEN;QAEA,MAAMjC,SAASC,iBAAiB,GAAGA,eAAe,CAAC,EAAEc,kBAAkB,GAAGA;QAE1E,IAAIH,YAAY;YACd,OAAOjB,yBAAyB;gBAC9BC;gBACAC,QAAQe;gBACRd;gBACAC,mBAAmBc;gBACnBb;gBACAE,UAAUY;YACZ;QACF;QAEA,OAAOd;IACT;IAEA,OAAOG,iBAAiBE,IAAI,CAAC;AAC/B,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1966, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1972, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/buildSortParam.ts"],"sourcesContent":["import type { PaginateOptions } from 'mongoose'\nimport type { FlattenedField, SanitizedConfig, Sort } from 'payload'\n\nimport { getLocalizedSortProperty } from './getLocalizedSortProperty.js'\n\ntype Args = {\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  locale: string\n  parentIsLocalized?: boolean\n  sort: Sort\n  timestamps: boolean\n}\n\nexport type SortArgs = {\n  direction: SortDirection\n  property: string\n}[]\n\nexport type SortDirection = 'asc' | 'desc'\n\nexport const buildSortParam = ({\n  config,\n  fields,\n  locale,\n  parentIsLocalized,\n  sort,\n  timestamps,\n}: Args): PaginateOptions['sort'] => {\n  if (!sort) {\n    if (timestamps) {\n      sort = '-createdAt'\n    } else {\n      sort = '-id'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  const sorting = sort.reduce<PaginateOptions['sort']>((acc, item) => {\n    let sortProperty: string\n    let sortDirection: SortDirection\n    if (item.indexOf('-') === 0) {\n      sortProperty = item.substring(1)\n      sortDirection = 'desc'\n    } else {\n      sortProperty = item\n      sortDirection = 'asc'\n    }\n    if (sortProperty === 'id') {\n      acc['_id'] = sortDirection\n      return acc\n    }\n    const localizedProperty = getLocalizedSortProperty({\n      config,\n      fields,\n      locale,\n      parentIsLocalized,\n      segments: sortProperty.split('.'),\n    })\n    acc[localizedProperty] = sortDirection\n    return acc\n  }, {})\n\n  return sorting\n}\n"],"names":["getLocalizedSortProperty","buildSortParam","config","fields","locale","parentIsLocalized","sort","timestamps","sorting","reduce","acc","item","sortProperty","sortDirection","indexOf","substring","localizedProperty","segments","split"],"mappings":";;;AAGA,SAASA,wBAAwB,QAAQ,gCAA+B;;AAkBjE,MAAMC,iBAAiB,CAAC,EAC7BC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,iBAAiB,EACjBC,IAAI,EACJC,UAAU,EACL;IACL,IAAI,CAACD,MAAM;QACT,IAAIC,YAAY;YACdD,OAAO;QACT,OAAO;YACLA,OAAO;QACT;IACF;IAEA,IAAI,OAAOA,SAAS,UAAU;QAC5BA,OAAO;YAACA;SAAK;IACf;IAEA,MAAME,UAAUF,KAAKG,MAAM,CAA0B,CAACC,KAAKC;QACzD,IAAIC;QACJ,IAAIC;QACJ,IAAIF,KAAKG,OAAO,CAAC,SAAS,GAAG;YAC3BF,eAAeD,KAAKI,SAAS,CAAC;YAC9BF,gBAAgB;QAClB,OAAO;YACLD,eAAeD;YACfE,gBAAgB;QAClB;QACA,IAAID,iBAAiB,MAAM;YACzBF,GAAG,CAAC,MAAM,GAAGG;YACb,OAAOH;QACT;QACA,MAAMM,uNAAoBhB,2BAAAA,EAAyB;YACjDE;YACAC;YACAC;YACAC;YACAY,UAAUL,aAAaM,KAAK,CAAC;QAC/B;QACAR,GAAG,CAACM,kBAAkB,GAAGH;QACzB,OAAOH;IACT,GAAG,CAAC;IAEJ,OAAOF;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2016, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2022, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/utilities/buildJoinAggregation.ts"],"sourcesContent":["import type { PipelineStage } from 'mongoose'\nimport type {\n  CollectionSlug,\n  FlattenedField,\n  JoinQuery,\n  SanitizedCollectionConfig,\n  Where,\n} from 'payload'\n\nimport { fieldShouldBeLocalized } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { buildQuery } from '../queries/buildQuery.js'\nimport { buildSortParam } from '../queries/buildSortParam.js'\n\ntype BuildJoinAggregationArgs = {\n  adapter: MongooseAdapter\n  collection: CollectionSlug\n  collectionConfig: SanitizedCollectionConfig\n  joins: JoinQuery\n  // the number of docs to get at the top collection level\n  limit?: number\n  locale: string\n  projection?: Record<string, true>\n  // the where clause for the top collection\n  query?: Where\n  /** whether the query is from drafts */\n  versions?: boolean\n}\n\nexport const buildJoinAggregation = async ({\n  adapter,\n  collection,\n  collectionConfig,\n  joins,\n  limit,\n  locale,\n  projection,\n  query,\n  versions,\n}: BuildJoinAggregationArgs): Promise<PipelineStage[] | undefined> => {\n  if (\n    (Object.keys(collectionConfig.joins).length === 0 &&\n      collectionConfig.polymorphicJoins.length == 0) ||\n    joins === false\n  ) {\n    return\n  }\n\n  const joinConfig = adapter.payload.collections[collection].config.joins\n  const polymorphicJoinsConfig = adapter.payload.collections[collection].config.polymorphicJoins\n  const aggregate: PipelineStage[] = [\n    {\n      $sort: { createdAt: -1 },\n    },\n  ]\n\n  if (query) {\n    aggregate.push({\n      $match: query,\n    })\n  }\n\n  if (limit) {\n    aggregate.push({\n      $limit: limit,\n    })\n  }\n\n  for (const join of polymorphicJoinsConfig) {\n    if (projection && !projection[join.joinPath]) {\n      continue\n    }\n\n    if (joins?.[join.joinPath] === false) {\n      continue\n    }\n\n    const {\n      limit: limitJoin = join.field.defaultLimit ?? 10,\n      page,\n      sort: sortJoin = join.field.defaultSort || collectionConfig.defaultSort,\n      where: whereJoin,\n    } = joins?.[join.joinPath] || {}\n\n    const aggregatedFields: FlattenedField[] = []\n    for (const collectionSlug of join.field.collection) {\n      for (const field of adapter.payload.collections[collectionSlug].config.flattenedFields) {\n        if (!aggregatedFields.some((eachField) => eachField.name === field.name)) {\n          aggregatedFields.push(field)\n        }\n      }\n    }\n\n    const sort = buildSortParam({\n      config: adapter.payload.config,\n      fields: aggregatedFields,\n      locale,\n      sort: sortJoin,\n      timestamps: true,\n    })\n\n    const $match = await buildQuery({\n      adapter,\n      fields: aggregatedFields,\n      locale,\n      where: whereJoin,\n    })\n\n    const sortProperty = Object.keys(sort)[0]\n    const sortDirection = sort[sortProperty] === 'asc' ? 1 : -1\n\n    const projectSort = sortProperty !== '_id' && sortProperty !== 'relationTo'\n\n    const aliases: string[] = []\n\n    const as = join.joinPath\n\n    for (const collectionSlug of join.field.collection) {\n      const alias = `${as}.docs.${collectionSlug}`\n      aliases.push(alias)\n\n      aggregate.push({\n        $lookup: {\n          as: alias,\n          from: adapter.collections[collectionSlug].collection.name,\n          let: {\n            root_id_: '$_id',\n          },\n          pipeline: [\n            {\n              $addFields: {\n                relationTo: {\n                  $literal: collectionSlug,\n                },\n              },\n            },\n            {\n              $match: {\n                $and: [\n                  {\n                    $expr: {\n                      $eq: [`$${join.field.on}`, '$$root_id_'],\n                    },\n                  },\n                  $match,\n                ],\n              },\n            },\n            {\n              $sort: {\n                [sortProperty]: sortDirection,\n              },\n            },\n            {\n              // Unfortunately, we can't use $skip here because we can lose data, instead we do $slice then\n              $limit: page ? page * limitJoin : limitJoin,\n            },\n            {\n              $project: {\n                value: '$_id',\n                ...(projectSort && {\n                  [sortProperty]: 1,\n                }),\n                relationTo: 1,\n              },\n            },\n          ],\n        },\n      })\n    }\n\n    aggregate.push({\n      $addFields: {\n        [`${as}.docs`]: {\n          $concatArrays: aliases.map((alias) => `$${alias}`),\n        },\n      },\n    })\n\n    aggregate.push({\n      $set: {\n        [`${as}.docs`]: {\n          $sortArray: {\n            input: `$${as}.docs`,\n            sortBy: {\n              [sortProperty]: sortDirection,\n            },\n          },\n        },\n      },\n    })\n\n    const sliceValue = page ? [(page - 1) * limitJoin, limitJoin] : [limitJoin]\n\n    aggregate.push({\n      $set: {\n        [`${as}.docs`]: {\n          $slice: [`$${as}.docs`, ...sliceValue],\n        },\n      },\n    })\n\n    aggregate.push({\n      $addFields: {\n        [`${as}.hasNextPage`]: {\n          $gt: [{ $size: `$${as}.docs` }, limitJoin || Number.MAX_VALUE],\n        },\n      },\n    })\n  }\n\n  for (const slug of Object.keys(joinConfig)) {\n    for (const join of joinConfig[slug]) {\n      if (projection && !projection[join.joinPath]) {\n        continue\n      }\n\n      if (joins?.[join.joinPath] === false) {\n        continue\n      }\n\n      const {\n        limit: limitJoin = join.field.defaultLimit ?? 10,\n        page,\n        sort: sortJoin = join.field.defaultSort || collectionConfig.defaultSort,\n        where: whereJoin,\n      } = joins?.[join.joinPath] || {}\n\n      if (Array.isArray(join.field.collection)) {\n        throw new Error('Unreachable')\n      }\n\n      const joinModel = adapter.collections[join.field.collection]\n\n      const sort = buildSortParam({\n        config: adapter.payload.config,\n        fields: adapter.payload.collections[slug].config.flattenedFields,\n        locale,\n        sort: sortJoin,\n        timestamps: true,\n      })\n      const sortProperty = Object.keys(sort)[0]\n      const sortDirection = sort[sortProperty] === 'asc' ? 1 : -1\n\n      const $match = await joinModel.buildQuery({\n        locale,\n        payload: adapter.payload,\n        where: whereJoin,\n      })\n\n      const pipeline: Exclude<PipelineStage, PipelineStage.Merge | PipelineStage.Out>[] = [\n        { $match },\n        {\n          $sort: { [sortProperty]: sortDirection },\n        },\n      ]\n\n      if (page) {\n        pipeline.push({\n          $skip: (page - 1) * limitJoin,\n        })\n      }\n\n      if (limitJoin > 0) {\n        pipeline.push({\n          $limit: limitJoin + 1,\n        })\n      }\n\n      let polymorphicSuffix = ''\n      if (Array.isArray(join.targetField.relationTo)) {\n        polymorphicSuffix = '.value'\n      }\n\n      if (adapter.payload.config.localization && locale === 'all') {\n        adapter.payload.config.localization.localeCodes.forEach((code) => {\n          const as = `${versions ? `version.${join.joinPath}` : join.joinPath}${code}`\n\n          aggregate.push(\n            {\n              $lookup: {\n                as: `${as}.docs`,\n                foreignField: `${join.field.on}${code}${polymorphicSuffix}`,\n                from: adapter.collections[slug].collection.name,\n                localField: versions ? 'parent' : '_id',\n                pipeline,\n              },\n            },\n            {\n              $addFields: {\n                [`${as}.docs`]: {\n                  $map: {\n                    as: 'doc',\n                    in: '$$doc._id',\n                    input: `$${as}.docs`,\n                  },\n                }, // Slicing the docs to match the limit\n                [`${as}.hasNextPage`]: limitJoin\n                  ? { $gt: [{ $size: `$${as}.docs` }, limitJoin] }\n                  : false,\n                // Boolean indicating if more docs than limit\n              },\n            },\n          )\n          if (limitJoin > 0) {\n            aggregate.push({\n              $addFields: {\n                [`${as}.docs`]: {\n                  $slice: [`$${as}.docs`, limitJoin],\n                },\n              },\n            })\n          }\n        })\n      } else {\n        const localeSuffix =\n          fieldShouldBeLocalized({\n            field: join.field,\n            parentIsLocalized: join.parentIsLocalized,\n          }) &&\n          adapter.payload.config.localization &&\n          locale\n            ? `.${locale}`\n            : ''\n        const as = `${versions ? `version.${join.joinPath}` : join.joinPath}${localeSuffix}`\n\n        let foreignField: string\n\n        if (join.getForeignPath) {\n          foreignField = `${join.getForeignPath({ locale })}${polymorphicSuffix}`\n        } else {\n          foreignField = `${join.field.on}${polymorphicSuffix}`\n        }\n\n        aggregate.push(\n          {\n            $lookup: {\n              as: `${as}.docs`,\n              foreignField,\n              from: adapter.collections[slug].collection.name,\n              localField: versions ? 'parent' : '_id',\n              pipeline,\n            },\n          },\n          {\n            $addFields: {\n              [`${as}.docs`]: {\n                $map: {\n                  as: 'doc',\n                  in: '$$doc._id',\n                  input: `$${as}.docs`,\n                },\n              }, // Slicing the docs to match the limit\n              [`${as}.hasNextPage`]: {\n                $gt: [{ $size: `$${as}.docs` }, limitJoin || Number.MAX_VALUE],\n              }, // Boolean indicating if more docs than limit\n            },\n          },\n        )\n        if (limitJoin > 0) {\n          aggregate.push({\n            $addFields: {\n              [`${as}.docs`]: {\n                $slice: [`$${as}.docs`, limitJoin],\n              },\n            },\n          })\n        }\n      }\n    }\n  }\n\n  if (projection) {\n    aggregate.push({ $project: projection })\n  }\n\n  return aggregate\n}\n"],"names":["fieldShouldBeLocalized","buildQuery","buildSortParam","buildJoinAggregation","adapter","collection","collectionConfig","joins","limit","locale","projection","query","versions","Object","keys","length","polymorphicJoins","joinConfig","payload","collections","config","polymorphicJoinsConfig","aggregate","$sort","createdAt","push","$match","$limit","join","joinPath","limitJoin","field","defaultLimit","page","sort","sortJoin","defaultSort","where","whereJoin","aggregatedFields","collectionSlug","flattenedFields","some","eachField","name","fields","timestamps","sortProperty","sortDirection","projectSort","aliases","as","alias","$lookup","from","let","root_id_","pipeline","$addFields","relationTo","$literal","$and","$expr","$eq","on","$project","value","$concatArrays","map","$set","$sortArray","input","sortBy","sliceValue","$slice","$gt","$size","Number","MAX_VALUE","slug","Array","isArray","Error","joinModel","$skip","polymorphicSuffix","targetField","localization","localeCodes","forEach","code","foreignField","localField","$map","in","localeSuffix","parentIsLocalized","getForeignPath"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2348, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2354, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/find.ts"],"sourcesContent":["import type { PaginateOptions } from 'mongoose'\nimport type { Find } from 'payload'\n\nimport { flattenWhereToOperators } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildSortParam } from './queries/buildSortParam.js'\nimport { buildJoinAggregation } from './utilities/buildJoinAggregation.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\n\nexport const find: Find = async function find(\n  this: MongooseAdapter,\n  {\n    collection,\n    joins = {},\n    limit = 0,\n    locale,\n    page,\n    pagination,\n    projection,\n    req,\n    select,\n    sort: sortArg,\n    where,\n  },\n) {\n  const Model = this.collections[collection]\n  const collectionConfig = this.payload.collections[collection].config\n\n  const session = await getSession(this, req)\n\n  let hasNearConstraint = false\n\n  if (where) {\n    const constraints = flattenWhereToOperators(where)\n    hasNearConstraint = constraints.some((prop) => Object.keys(prop).some((key) => key === 'near'))\n  }\n\n  let sort\n  if (!hasNearConstraint) {\n    sort = buildSortParam({\n      config: this.payload.config,\n      fields: collectionConfig.flattenedFields,\n      locale,\n      sort: sortArg || collectionConfig.defaultSort,\n      timestamps: true,\n    })\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    collectionSlug: collection,\n    fields: this.payload.collections[collection].config.flattenedFields,\n    locale,\n    where,\n  })\n\n  // useEstimatedCount is faster, but not accurate, as it ignores any filters. It is thus set to true if there are no filters.\n  const useEstimatedCount = hasNearConstraint || !query || Object.keys(query).length === 0\n  const paginationOptions: PaginateOptions = {\n    lean: true,\n    leanWithId: true,\n    options: {\n      session,\n    },\n    page,\n    pagination,\n    projection,\n    sort,\n    useEstimatedCount,\n  }\n\n  if (select) {\n    paginationOptions.projection = buildProjectionFromSelect({\n      adapter: this,\n      fields: collectionConfig.flattenedFields,\n      select,\n    })\n  }\n\n  if (this.collation) {\n    const defaultLocale = 'en'\n    paginationOptions.collation = {\n      locale: locale && locale !== 'all' && locale !== '*' ? locale : defaultLocale,\n      ...this.collation,\n    }\n  }\n\n  if (!useEstimatedCount && Object.keys(query).length === 0 && this.disableIndexHints !== true) {\n    // Improve the performance of the countDocuments query which is used if useEstimatedCount is set to false by adding\n    // a hint. By default, if no hint is provided, MongoDB does not use an indexed field to count the returned documents,\n    // which makes queries very slow. This only happens when no query (filter) is provided. If one is provided, it uses\n    // the correct indexed field\n    paginationOptions.useCustomCountFn = () => {\n      return Promise.resolve(\n        Model.countDocuments(query, {\n          hint: { _id: 1 },\n          session,\n        }),\n      )\n    }\n  }\n\n  if (limit >= 0) {\n    paginationOptions.limit = limit\n    // limit must also be set here, it's ignored when pagination is false\n    paginationOptions.options.limit = limit\n\n    // Disable pagination if limit is 0\n    if (limit === 0) {\n      paginationOptions.pagination = false\n    }\n  }\n\n  let result\n\n  const aggregate = await buildJoinAggregation({\n    adapter: this,\n    collection,\n    collectionConfig,\n    joins,\n    locale,\n    query,\n  })\n  // build join aggregation\n  if (aggregate) {\n    result = await Model.aggregatePaginate(Model.aggregate(aggregate), paginationOptions)\n  } else {\n    result = await Model.paginate(query, paginationOptions)\n  }\n\n  const docs = JSON.parse(JSON.stringify(result.docs))\n\n  return {\n    ...result,\n    docs: docs.map((doc) => {\n      doc.id = doc._id\n      return sanitizeInternalFields(doc)\n    }),\n  }\n}\n"],"names":["flattenWhereToOperators","buildQuery","buildSortParam","buildJoinAggregation","buildProjectionFromSelect","getSession","sanitizeInternalFields","find","collection","joins","limit","locale","page","pagination","projection","req","select","sort","sortArg","where","Model","collections","collectionConfig","payload","config","session","hasNearConstraint","constraints","some","prop","Object","keys","key","fields","flattenedFields","defaultSort","timestamps","query","adapter","collectionSlug","useEstimatedCount","length","paginationOptions","lean","leanWithId","options","collation","defaultLocale","disableIndexHints","useCustomCountFn","Promise","resolve","countDocuments","hint","_id","result","aggregate","aggregatePaginate","paginate","docs","JSON","parse","stringify","map","doc","id"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2472, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2478, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/findGlobal.ts"],"sourcesContent":["import type { QueryOptions } from 'mongoose'\nimport type { FindGlobal } from 'payload'\n\nimport { combineQueries } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\n\nexport const findGlobal: FindGlobal = async function findGlobal(\n  this: MongooseAdapter,\n  { slug, locale, req, select, where },\n) {\n  const Model = this.globals\n  const fields = this.payload.globals.config.find((each) => each.slug === slug).flattenedFields\n  const options: QueryOptions = {\n    lean: true,\n    select: buildProjectionFromSelect({\n      adapter: this,\n      fields,\n      select,\n    }),\n    session: await getSession(this, req),\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    fields,\n    globalSlug: slug,\n    locale,\n    where: combineQueries({ globalType: { equals: slug } }, where),\n  })\n\n  let doc = (await Model.findOne(query, {}, options)) as any\n\n  if (!doc) {\n    return null\n  }\n  if (doc._id) {\n    doc.id = doc._id\n    delete doc._id\n  }\n\n  doc = JSON.parse(JSON.stringify(doc))\n  doc = sanitizeInternalFields(doc)\n\n  return doc\n}\n"],"names":["combineQueries","buildQuery","buildProjectionFromSelect","getSession","sanitizeInternalFields","findGlobal","slug","locale","req","select","where","Model","globals","fields","payload","config","find","each","flattenedFields","options","lean","adapter","session","query","globalSlug","globalType","equals","doc","findOne","_id","id","JSON","parse","stringify"],"mappings":";;;AAOA,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,sBAAsB,QAAQ,wCAAuC;AAP9E,SAASJ,cAAc,QAAQ,UAAS;;;;;;AASjC,MAAMK,aAAyB,eAAeA,WAEnD,EAAEC,IAAI,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAEpC,MAAMC,QAAQ,IAAI,CAACC,OAAO;IAC1B,MAAMC,SAAS,IAAI,CAACC,OAAO,CAACF,OAAO,CAACG,MAAM,CAACC,IAAI,CAAC,CAACC,OAASA,KAAKX,IAAI,KAAKA,MAAMY,eAAe;IAC7F,MAAMC,UAAwB;QAC5BC,MAAM;QACNX,8MAAQP,4BAAAA,EAA0B;YAChCmB,SAAS,IAAI;YACbR;YACAJ;QACF;QACAa,SAAS,OAAMnB,mMAAAA,EAAW,IAAI,EAAEK;IAClC;IAEA,MAAMe,QAAQ,2LAAMtB,aAAAA,EAAW;QAC7BoB,SAAS,IAAI;QACbR;QACAW,YAAYlB;QACZC;QACAG,2KAAOV,iBAAAA,EAAe;YAAEyB,YAAY;gBAAEC,QAAQpB;YAAK;QAAE,GAAGI;IAC1D;IAEA,IAAIiB,MAAO,MAAMhB,MAAMiB,OAAO,CAACL,OAAO,CAAC,GAAGJ;IAE1C,IAAI,CAACQ,KAAK;QACR,OAAO;IACT;IACA,IAAIA,IAAIE,GAAG,EAAE;QACXF,IAAIG,EAAE,GAAGH,IAAIE,GAAG;QAChB,OAAOF,IAAIE,GAAG;IAChB;IAEAF,MAAMI,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACN;IAChCA,yMAAMvB,yBAAAA,EAAuBuB;IAE7B,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2526, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2532, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/findGlobalVersions.ts"],"sourcesContent":["import type { PaginateOptions, QueryOptions } from 'mongoose'\nimport type { FindGlobalVersions } from 'payload'\n\nimport { buildVersionGlobalFields, flattenWhereToOperators } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildSortParam } from './queries/buildSortParam.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\n\nexport const findGlobalVersions: FindGlobalVersions = async function findGlobalVersions(\n  this: MongooseAdapter,\n  { global, limit, locale, page, pagination, req, select, skip, sort: sortArg, where },\n) {\n  const Model = this.versions[global]\n  const versionFields = buildVersionGlobalFields(\n    this.payload.config,\n    this.payload.globals.config.find(({ slug }) => slug === global),\n    true,\n  )\n\n  const session = await getSession(this, req)\n  const options: QueryOptions = {\n    limit,\n    session,\n    skip,\n  }\n\n  let hasNearConstraint = false\n\n  if (where) {\n    const constraints = flattenWhereToOperators(where)\n    hasNearConstraint = constraints.some((prop) => Object.keys(prop).some((key) => key === 'near'))\n  }\n\n  let sort\n  if (!hasNearConstraint) {\n    sort = buildSortParam({\n      config: this.payload.config,\n      fields: versionFields,\n      locale,\n      sort: sortArg || '-updatedAt',\n      timestamps: true,\n    })\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    fields: versionFields,\n    locale,\n    where,\n  })\n\n  // useEstimatedCount is faster, but not accurate, as it ignores any filters. It is thus set to true if there are no filters.\n  const useEstimatedCount = hasNearConstraint || !query || Object.keys(query).length === 0\n  const paginationOptions: PaginateOptions = {\n    lean: true,\n    leanWithId: true,\n    limit,\n    options,\n    page,\n    pagination,\n    projection: buildProjectionFromSelect({ adapter: this, fields: versionFields, select }),\n    sort,\n    useEstimatedCount,\n  }\n\n  if (this.collation) {\n    const defaultLocale = 'en'\n    paginationOptions.collation = {\n      locale: locale && locale !== 'all' && locale !== '*' ? locale : defaultLocale,\n      ...this.collation,\n    }\n  }\n\n  if (!useEstimatedCount && Object.keys(query).length === 0 && this.disableIndexHints !== true) {\n    // Improve the performance of the countDocuments query which is used if useEstimatedCount is set to false by adding\n    // a hint. By default, if no hint is provided, MongoDB does not use an indexed field to count the returned documents,\n    // which makes queries very slow. This only happens when no query (filter) is provided. If one is provided, it uses\n    // the correct indexed field\n    paginationOptions.useCustomCountFn = () => {\n      return Promise.resolve(\n        Model.countDocuments(query, {\n          hint: { _id: 1 },\n          session,\n        }),\n      )\n    }\n  }\n\n  if (limit >= 0) {\n    paginationOptions.limit = limit\n    // limit must also be set here, it's ignored when pagination is false\n    paginationOptions.options.limit = limit\n\n    // Disable pagination if limit is 0\n    if (limit === 0) {\n      paginationOptions.pagination = false\n    }\n  }\n\n  const result = await Model.paginate(query, paginationOptions)\n  const docs = JSON.parse(JSON.stringify(result.docs))\n\n  return {\n    ...result,\n    docs: docs.map((doc) => {\n      doc.id = doc._id\n      return sanitizeInternalFields(doc)\n    }),\n  }\n}\n"],"names":["buildVersionGlobalFields","flattenWhereToOperators","buildQuery","buildSortParam","buildProjectionFromSelect","getSession","sanitizeInternalFields","findGlobalVersions","global","limit","locale","page","pagination","req","select","skip","sort","sortArg","where","Model","versions","versionFields","payload","config","globals","find","slug","session","options","hasNearConstraint","constraints","some","prop","Object","keys","key","fields","timestamps","query","adapter","useEstimatedCount","length","paginationOptions","lean","leanWithId","projection","collation","defaultLocale","disableIndexHints","useCustomCountFn","Promise","resolve","countDocuments","hint","_id","result","paginate","docs","JSON","parse","stringify","map","doc","id"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2635, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2641, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/findOne.ts"],"sourcesContent":["import type { AggregateOptions, QueryOptions } from 'mongoose'\nimport type { Document, FindOne } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildJoinAggregation } from './utilities/buildJoinAggregation.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\n\nexport const findOne: FindOne = async function findOne(\n  this: MongooseAdapter,\n  { collection, joins, locale, req, select, where },\n) {\n  const Model = this.collections[collection]\n  const collectionConfig = this.payload.collections[collection].config\n  const session = await getSession(this, req)\n  const options: AggregateOptions & QueryOptions = {\n    lean: true,\n    session,\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    collectionSlug: collection,\n    fields: collectionConfig.flattenedFields,\n    locale,\n    where,\n  })\n\n  const projection = buildProjectionFromSelect({\n    adapter: this,\n    fields: collectionConfig.flattenedFields,\n    select,\n  })\n\n  const aggregate = await buildJoinAggregation({\n    adapter: this,\n    collection,\n    collectionConfig,\n    joins,\n    limit: 1,\n    locale,\n    projection,\n    query,\n  })\n\n  let doc\n  if (aggregate) {\n    ;[doc] = await Model.aggregate(aggregate, { session })\n  } else {\n    ;(options as Record<string, unknown>).projection = projection\n    doc = await Model.findOne(query, {}, options)\n  }\n\n  if (!doc) {\n    return null\n  }\n\n  let result: Document = JSON.parse(JSON.stringify(doc))\n\n  // custom id type reset\n  result.id = result._id\n  result = sanitizeInternalFields(result)\n\n  return result\n}\n"],"names":["buildQuery","buildJoinAggregation","buildProjectionFromSelect","getSession","sanitizeInternalFields","findOne","collection","joins","locale","req","select","where","Model","collections","collectionConfig","payload","config","session","options","lean","query","adapter","collectionSlug","fields","flattenedFields","projection","aggregate","limit","doc","result","JSON","parse","stringify","id","_id"],"mappings":";;;AAKA,SAASA,UAAU,QAAQ,0BAAyB;AACpD,SAASC,oBAAoB,QAAQ,sCAAqC;AAC1E,SAASC,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,sBAAsB,QAAQ,wCAAuC;;;;;;AAEvE,MAAMC,UAAmB,eAAeA,QAE7C,EAAEC,UAAU,EAAEC,KAAK,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAEjD,MAAMC,QAAQ,IAAI,CAACC,WAAW,CAACP,WAAW;IAC1C,MAAMQ,mBAAmB,IAAI,CAACC,OAAO,CAACF,WAAW,CAACP,WAAW,CAACU,MAAM;IACpE,MAAMC,UAAU,6LAAMd,aAAAA,EAAW,IAAI,EAAEM;IACvC,MAAMS,UAA2C;QAC/CC,MAAM;QACNF;IACF;IAEA,MAAMG,QAAQ,2LAAMpB,aAAAA,EAAW;QAC7BqB,SAAS,IAAI;QACbC,gBAAgBhB;QAChBiB,QAAQT,iBAAiBU,eAAe;QACxChB;QACAG;IACF;IAEA,MAAMc,mNAAavB,4BAAAA,EAA0B;QAC3CmB,SAAS,IAAI;QACbE,QAAQT,iBAAiBU,eAAe;QACxCd;IACF;IAEA,MAAMgB,YAAY,OAAMzB,uNAAAA,EAAqB;QAC3CoB,SAAS,IAAI;QACbf;QACAQ;QACAP;QACAoB,OAAO;QACPnB;QACAiB;QACAL;IACF;IAEA,IAAIQ;IACJ,IAAIF,WAAW;;QACZ,CAACE,IAAI,GAAG,MAAMhB,MAAMc,SAAS,CAACA,WAAW;YAAET;QAAQ;IACtD,OAAO;;QACHC,QAAoCO,UAAU,GAAGA;QACnDG,MAAM,MAAMhB,MAAMP,OAAO,CAACe,OAAO,CAAC,GAAGF;IACvC;IAEA,IAAI,CAACU,KAAK;QACR,OAAO;IACT;IAEA,IAAIC,SAAmBC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACJ;IAEjD,uBAAuB;IACvBC,OAAOI,EAAE,GAAGJ,OAAOK,GAAG;IACtBL,4MAASzB,yBAAAA,EAAuByB;IAEhC,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2704, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2710, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/findVersions.ts"],"sourcesContent":["import type { PaginateOptions, QueryOptions } from 'mongoose'\nimport type { FindVersions } from 'payload'\n\nimport { buildVersionCollectionFields, flattenWhereToOperators } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildSortParam } from './queries/buildSortParam.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\n\nexport const findVersions: FindVersions = async function findVersions(\n  this: MongooseAdapter,\n  { collection, limit, locale, page, pagination, req = {}, select, skip, sort: sortArg, where },\n) {\n  const Model = this.versions[collection]\n  const collectionConfig = this.payload.collections[collection].config\n  const session = await getSession(this, req)\n  const options: QueryOptions = {\n    limit,\n    session,\n    skip,\n  }\n\n  let hasNearConstraint = false\n\n  if (where) {\n    const constraints = flattenWhereToOperators(where)\n    hasNearConstraint = constraints.some((prop) => Object.keys(prop).some((key) => key === 'near'))\n  }\n\n  let sort\n  if (!hasNearConstraint) {\n    sort = buildSortParam({\n      config: this.payload.config,\n      fields: collectionConfig.flattenedFields,\n      locale,\n      sort: sortArg || '-updatedAt',\n      timestamps: true,\n    })\n  }\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n\n  const query = await buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    where,\n  })\n\n  // useEstimatedCount is faster, but not accurate, as it ignores any filters. It is thus set to true if there are no filters.\n  const useEstimatedCount = hasNearConstraint || !query || Object.keys(query).length === 0\n  const paginationOptions: PaginateOptions = {\n    lean: true,\n    leanWithId: true,\n    limit,\n    options,\n    page,\n    pagination,\n    projection: buildProjectionFromSelect({\n      adapter: this,\n      fields,\n      select,\n    }),\n    sort,\n    useEstimatedCount,\n  }\n\n  if (this.collation) {\n    const defaultLocale = 'en'\n    paginationOptions.collation = {\n      locale: locale && locale !== 'all' && locale !== '*' ? locale : defaultLocale,\n      ...this.collation,\n    }\n  }\n\n  if (!useEstimatedCount && Object.keys(query).length === 0 && this.disableIndexHints !== true) {\n    // Improve the performance of the countDocuments query which is used if useEstimatedCount is set to false by adding\n    // a hint. By default, if no hint is provided, MongoDB does not use an indexed field to count the returned documents,\n    // which makes queries very slow. This only happens when no query (filter) is provided. If one is provided, it uses\n    // the correct indexed field\n    paginationOptions.useCustomCountFn = () => {\n      return Promise.resolve(\n        Model.countDocuments(query, {\n          hint: { _id: 1 },\n          session,\n        }),\n      )\n    }\n  }\n\n  if (limit >= 0) {\n    paginationOptions.limit = limit\n    // limit must also be set here, it's ignored when pagination is false\n    paginationOptions.options.limit = limit\n\n    // Disable pagination if limit is 0\n    if (limit === 0) {\n      paginationOptions.pagination = false\n    }\n  }\n\n  const result = await Model.paginate(query, paginationOptions)\n  const docs = JSON.parse(JSON.stringify(result.docs))\n\n  return {\n    ...result,\n    docs: docs.map((doc) => {\n      doc.id = doc._id\n      return sanitizeInternalFields(doc)\n    }),\n  }\n}\n"],"names":["buildVersionCollectionFields","flattenWhereToOperators","buildQuery","buildSortParam","buildProjectionFromSelect","getSession","sanitizeInternalFields","findVersions","collection","limit","locale","page","pagination","req","select","skip","sort","sortArg","where","Model","versions","collectionConfig","payload","collections","config","session","options","hasNearConstraint","constraints","some","prop","Object","keys","key","fields","flattenedFields","timestamps","query","adapter","useEstimatedCount","length","paginationOptions","lean","leanWithId","projection","collation","defaultLocale","disableIndexHints","useCustomCountFn","Promise","resolve","countDocuments","hint","_id","result","paginate","docs","JSON","parse","stringify","map","doc","id"],"mappings":";;;AAOA,SAASE,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,8BAA6B;AAC5D,SAASC,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,sBAAsB,QAAQ,wCAAuC;;AAR9E,SAASN,4BAA4B,EAAEC,uBAAuB,QAAQ,UAAS;;;;;;;AAUxE,MAAMM,eAA6B,eAAeA,aAEvD,EAAEC,UAAU,EAAEC,KAAK,EAAEC,MAAM,EAAEC,IAAI,EAAEC,UAAU,EAAEC,MAAM,CAAC,CAAC,EAAEC,MAAM,EAAEC,IAAI,EAAEC,MAAMC,OAAO,EAAEC,KAAK,EAAE;IAE7F,MAAMC,QAAQ,IAAI,CAACC,QAAQ,CAACZ,WAAW;IACvC,MAAMa,mBAAmB,IAAI,CAACC,OAAO,CAACC,WAAW,CAACf,WAAW,CAACgB,MAAM;IACpE,MAAMC,UAAU,UAAMpB,gMAAAA,EAAW,IAAI,EAAEQ;IACvC,MAAMa,UAAwB;QAC5BjB;QACAgB;QACAV;IACF;IAEA,IAAIY,oBAAoB;IAExB,IAAIT,OAAO;QACT,MAAMU,cAAc3B,uMAAAA,EAAwBiB;QAC5CS,oBAAoBC,YAAYC,IAAI,CAAC,CAACC,OAASC,OAAOC,IAAI,CAACF,MAAMD,IAAI,CAAC,CAACI,MAAQA,QAAQ;IACzF;IAEA,IAAIjB;IACJ,IAAI,CAACW,mBAAmB;QACtBX,OAAOb,0MAAAA,EAAe;YACpBqB,QAAQ,IAAI,CAACF,OAAO,CAACE,MAAM;YAC3BU,QAAQb,iBAAiBc,eAAe;YACxCzB;YACAM,MAAMC,WAAW;YACjBmB,YAAY;QACd;IACF;IAEA,MAAMF,oLAASlC,+BAAAA,EAA6B,IAAI,CAACsB,OAAO,CAACE,MAAM,EAAEH,kBAAkB;IAEnF,MAAMgB,QAAQ,OAAMnC,iMAAAA,EAAW;QAC7BoC,SAAS,IAAI;QACbJ;QACAxB;QACAQ;IACF;IAEA,4HAA4H;IAC5H,MAAMqB,oBAAoBZ,qBAAqB,CAACU,SAASN,OAAOC,IAAI,CAACK,OAAOG,MAAM,KAAK;IACvF,MAAMC,oBAAqC;QACzCC,MAAM;QACNC,YAAY;QACZlC;QACAiB;QACAf;QACAC;QACAgC,aAAYxC,iOAAAA,EAA0B;YACpCkC,SAAS,IAAI;YACbJ;YACApB;QACF;QACAE;QACAuB;IACF;IAEA,IAAI,IAAI,CAACM,SAAS,EAAE;QAClB,MAAMC,gBAAgB;QACtBL,kBAAkBI,SAAS,GAAG;YAC5BnC,QAAQA,UAAUA,WAAW,SAASA,WAAW,MAAMA,SAASoC;YAChE,GAAG,IAAI,CAACD,SAAS;QACnB;IACF;IAEA,IAAI,CAACN,qBAAqBR,OAAOC,IAAI,CAACK,OAAOG,MAAM,KAAK,KAAK,IAAI,CAACO,iBAAiB,KAAK,MAAM;QAC5F,mHAAmH;QACnH,qHAAqH;QACrH,mHAAmH;QACnH,4BAA4B;QAC5BN,kBAAkBO,gBAAgB,GAAG;YACnC,OAAOC,QAAQC,OAAO,CACpB/B,MAAMgC,cAAc,CAACd,OAAO;gBAC1Be,MAAM;oBAAEC,KAAK;gBAAE;gBACf5B;YACF;QAEJ;IACF;IAEA,IAAIhB,SAAS,GAAG;QACdgC,kBAAkBhC,KAAK,GAAGA;QAC1B,qEAAqE;QACrEgC,kBAAkBf,OAAO,CAACjB,KAAK,GAAGA;QAElC,mCAAmC;QACnC,IAAIA,UAAU,GAAG;YACfgC,kBAAkB7B,UAAU,GAAG;QACjC;IACF;IAEA,MAAM0C,SAAS,MAAMnC,MAAMoC,QAAQ,CAAClB,OAAOI;IAC3C,MAAMe,OAAOC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACL,OAAOE,IAAI;IAElD,OAAO;QACL,GAAGF,MAAM;QACTE,MAAMA,KAAKI,GAAG,CAAC,CAACC;YACdA,IAAIC,EAAE,GAAGD,IAAIR,GAAG;YAChB,0MAAO/C,yBAAAA,EAAuBuD;QAChC;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2814, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2820, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queries/getBuildQueryPlugin.ts"],"sourcesContent":["import type { FlattenedField, Payload, Where } from 'payload'\n\nimport { QueryError } from 'payload'\n\nimport { parseParams } from './parseParams.js'\n\ntype GetBuildQueryPluginArgs = {\n  collectionSlug?: string\n  versionsFields?: FlattenedField[]\n}\n\nexport type BuildQueryArgs = {\n  globalSlug?: string\n  locale?: string\n  payload: Payload\n  where: Where\n}\n\n// This plugin asynchronously builds a list of Mongoose query constraints\n// which can then be used in subsequent Mongoose queries.\n// Deprecated in favor of using simpler buildQuery directly\nexport const getBuildQueryPlugin = ({\n  collectionSlug,\n  versionsFields,\n}: GetBuildQueryPluginArgs = {}) => {\n  return function buildQueryPlugin(schema) {\n    const modifiedSchema = schema\n    async function schemaBuildQuery({\n      globalSlug,\n      locale,\n      payload,\n      where,\n    }: BuildQueryArgs): Promise<Record<string, unknown>> {\n      let fields = versionsFields\n      if (!fields) {\n        if (globalSlug) {\n          const globalConfig = payload.globals.config.find(({ slug }) => slug === globalSlug)\n          fields = globalConfig.flattenedFields\n        }\n        if (collectionSlug) {\n          const collectionConfig = payload.collections[collectionSlug].config\n          fields = collectionConfig.flattenedFields\n        }\n      }\n\n      const errors = []\n      const result = await parseParams({\n        collectionSlug,\n        fields,\n        globalSlug,\n        locale,\n        parentIsLocalized: false,\n        payload,\n        where,\n      })\n\n      if (errors.length > 0) {\n        throw new QueryError(errors)\n      }\n\n      return result\n    }\n    modifiedSchema.statics.buildQuery = schemaBuildQuery\n  }\n}\n"],"names":["QueryError","parseParams","getBuildQueryPlugin","collectionSlug","versionsFields","buildQueryPlugin","schema","modifiedSchema","schemaBuildQuery","globalSlug","locale","payload","where","fields","globalConfig","globals","config","find","slug","flattenedFields","collectionConfig","collections","errors","result","parentIsLocalized","length","statics","buildQuery"],"mappings":";;;AAIA,SAASC,WAAW,QAAQ,mBAAkB;AAF9C,SAASD,UAAU,QAAQ,UAAS;;;AAmB7B,MAAME,sBAAsB,CAAC,EAClCC,cAAc,EACdC,cAAc,EACU,GAAG,CAAC,CAAC;IAC7B,OAAO,SAASC,iBAAiBC,MAAM;QACrC,MAAMC,iBAAiBD;QACvB,eAAeE,iBAAiB,EAC9BC,UAAU,EACVC,MAAM,EACNC,OAAO,EACPC,KAAK,EACU;YACf,IAAIC,SAAST;YACb,IAAI,CAACS,QAAQ;gBACX,IAAIJ,YAAY;oBACd,MAAMK,eAAeH,QAAQI,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAKA,SAAST;oBACxEI,SAASC,aAAaK,eAAe;gBACvC;gBACA,IAAIhB,gBAAgB;oBAClB,MAAMiB,mBAAmBT,QAAQU,WAAW,CAAClB,eAAe,CAACa,MAAM;oBACnEH,SAASO,iBAAiBD,eAAe;gBAC3C;YACF;YAEA,MAAMG,SAAS,EAAE;YACjB,MAAMC,SAAS,4LAAMtB,cAAAA,EAAY;gBAC/BE;gBACAU;gBACAJ;gBACAC;gBACAc,mBAAmB;gBACnBb;gBACAC;YACF;YAEA,IAAIU,OAAOG,MAAM,GAAG,GAAG;gBACrB,MAAM,8JAAIzB,aAAAA,CAAWsB;YACvB;YAEA,OAAOC;QACT;QACAhB,eAAemB,OAAO,CAACC,UAAU,GAAGnB;IACtC;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2860, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2866, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/models/buildSchema.ts"],"sourcesContent":["import type { IndexOptions, Schema, SchemaOptions, SchemaTypeOptions } from 'mongoose'\n\nimport mongoose from 'mongoose'\nimport {\n  type ArrayField,\n  type BlocksField,\n  type CheckboxField,\n  type CodeField,\n  type CollapsibleField,\n  type DateField,\n  type EmailField,\n  type Field,\n  type FieldAffectingData,\n  type GroupField,\n  type JSONField,\n  type NonPresentationalField,\n  type NumberField,\n  type Payload,\n  type PointField,\n  type RadioField,\n  type RelationshipField,\n  type RichTextField,\n  type RowField,\n  type SanitizedLocalizationConfig,\n  type SelectField,\n  type Tab,\n  type TabsField,\n  type TextareaField,\n  type TextField,\n  type UploadField,\n} from 'payload'\nimport {\n  fieldAffectsData,\n  fieldIsPresentationalOnly,\n  fieldIsVirtual,\n  fieldShouldBeLocalized,\n  tabHasName,\n} from 'payload/shared'\n\nexport type BuildSchemaOptions = {\n  allowIDField?: boolean\n  disableUnique?: boolean\n  draftsEnabled?: boolean\n  indexSortableFields?: boolean\n  options?: SchemaOptions\n}\n\ntype FieldSchemaGenerator = (\n  field: Field,\n  schema: Schema,\n  config: Payload,\n  buildSchemaOptions: BuildSchemaOptions,\n  parentIsLocalized: boolean,\n) => void\n\n/**\n * get a field's defaultValue only if defined and not dynamic so that it can be set on the field schema\n * @param field\n */\nconst formatDefaultValue = (field: FieldAffectingData) =>\n  typeof field.defaultValue !== 'undefined' && typeof field.defaultValue !== 'function'\n    ? field.defaultValue\n    : undefined\n\nconst formatBaseSchema = ({\n  buildSchemaOptions,\n  field,\n  parentIsLocalized,\n}: {\n  buildSchemaOptions: BuildSchemaOptions\n  field: FieldAffectingData\n  parentIsLocalized: boolean\n}) => {\n  const { disableUnique, draftsEnabled, indexSortableFields } = buildSchemaOptions\n  const schema: SchemaTypeOptions<unknown> = {\n    default: formatDefaultValue(field),\n    index: field.index || (!disableUnique && field.unique) || indexSortableFields || false,\n    required: false,\n    unique: (!disableUnique && field.unique) || false,\n  }\n\n  if (\n    schema.unique &&\n    (fieldShouldBeLocalized({ field, parentIsLocalized }) ||\n      draftsEnabled ||\n      (fieldAffectsData(field) &&\n        field.type !== 'group' &&\n        field.type !== 'tab' &&\n        field.required !== true))\n  ) {\n    schema.sparse = true\n  }\n\n  if (field.hidden) {\n    schema.hidden = true\n  }\n\n  return schema\n}\n\nconst localizeSchema = (\n  entity: NonPresentationalField | Tab,\n  schema,\n  localization: false | SanitizedLocalizationConfig,\n  parentIsLocalized: boolean,\n) => {\n  if (\n    fieldShouldBeLocalized({ field: entity, parentIsLocalized }) &&\n    localization &&\n    Array.isArray(localization.locales)\n  ) {\n    return {\n      type: localization.localeCodes.reduce(\n        (localeSchema, locale) => ({\n          ...localeSchema,\n          [locale]: schema,\n        }),\n        {\n          _id: false,\n        },\n      ),\n      localized: true,\n    }\n  }\n  return schema\n}\n\nexport const buildSchema = (args: {\n  buildSchemaOptions: BuildSchemaOptions\n  configFields: Field[]\n  parentIsLocalized?: boolean\n  payload: Payload\n}): Schema => {\n  const { buildSchemaOptions = {}, configFields, parentIsLocalized, payload } = args\n  const { allowIDField, options } = buildSchemaOptions\n  let fields = {}\n\n  let schemaFields = configFields\n\n  if (!allowIDField) {\n    const idField = schemaFields.find((field) => fieldAffectsData(field) && field.name === 'id')\n    if (idField) {\n      fields = {\n        _id: idField.type === 'number' ? Number : String,\n      }\n      schemaFields = schemaFields.filter(\n        (field) => !(fieldAffectsData(field) && field.name === 'id'),\n      )\n    }\n  }\n\n  const schema = new mongoose.Schema(fields, options)\n\n  schemaFields.forEach((field) => {\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    if (!fieldIsPresentationalOnly(field)) {\n      const addFieldSchema: FieldSchemaGenerator = fieldToSchemaMap[field.type]\n\n      if (addFieldSchema) {\n        addFieldSchema(field, schema, payload, buildSchemaOptions, parentIsLocalized)\n      }\n    }\n  })\n\n  return schema\n}\n\nconst fieldToSchemaMap: Record<string, FieldSchemaGenerator> = {\n  array: (field: ArrayField, schema, payload, buildSchemaOptions, parentIsLocalized) => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: [\n        buildSchema({\n          buildSchemaOptions: {\n            allowIDField: true,\n            disableUnique: buildSchemaOptions.disableUnique,\n            draftsEnabled: buildSchemaOptions.draftsEnabled,\n            options: {\n              _id: false,\n              id: false,\n              minimize: false,\n            },\n          },\n          configFields: field.fields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          payload,\n        }),\n      ],\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  blocks: (field: BlocksField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const fieldSchema = {\n      type: [new mongoose.Schema({}, { _id: false, discriminatorKey: 'blockType' })],\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        fieldSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n    ;(field.blockReferences ?? field.blocks).forEach((blockItem) => {\n      const blockSchema = new mongoose.Schema({}, { _id: false, id: false })\n\n      const block = typeof blockItem === 'string' ? payload.blocks[blockItem] : blockItem\n\n      block.fields.forEach((blockField) => {\n        const addFieldSchema: FieldSchemaGenerator = fieldToSchemaMap[blockField.type]\n        if (addFieldSchema) {\n          addFieldSchema(\n            blockField,\n            blockSchema,\n            payload,\n            buildSchemaOptions,\n            parentIsLocalized || field.localized,\n          )\n        }\n      })\n\n      if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n        payload.config.localization.localeCodes.forEach((localeCode) => {\n          // @ts-expect-error Possible incorrect typing in mongoose types, this works\n          schema.path(`${field.name}.${localeCode}`).discriminator(block.slug, blockSchema)\n        })\n      } else {\n        // @ts-expect-error Possible incorrect typing in mongoose types, this works\n        schema.path(field.name).discriminator(block.slug, blockSchema)\n      }\n    })\n  },\n  checkbox: (\n    field: CheckboxField,\n    schema,\n    payload,\n    buildSchemaOptions,\n    parentIsLocalized,\n  ): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: Boolean,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  code: (field: CodeField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: String,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  collapsible: (\n    field: CollapsibleField,\n    schema,\n    payload,\n    buildSchemaOptions,\n    parentIsLocalized,\n  ): void => {\n    field.fields.forEach((subField: Field) => {\n      if (fieldIsVirtual(subField)) {\n        return\n      }\n\n      const addFieldSchema: FieldSchemaGenerator = fieldToSchemaMap[subField.type]\n\n      if (addFieldSchema) {\n        addFieldSchema(subField, schema, payload, buildSchemaOptions, parentIsLocalized)\n      }\n    })\n  },\n  date: (field: DateField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: Date,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  email: (field: EmailField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: String,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  group: (field: GroupField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const formattedBaseSchema = formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized })\n\n    // carry indexSortableFields through to versions if drafts enabled\n    const indexSortableFields =\n      buildSchemaOptions.indexSortableFields &&\n      field.name === 'version' &&\n      buildSchemaOptions.draftsEnabled\n\n    const baseSchema = {\n      ...formattedBaseSchema,\n      type: buildSchema({\n        buildSchemaOptions: {\n          disableUnique: buildSchemaOptions.disableUnique,\n          draftsEnabled: buildSchemaOptions.draftsEnabled,\n          indexSortableFields,\n          options: {\n            _id: false,\n            id: false,\n            minimize: false,\n          },\n        },\n        configFields: field.fields,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        payload,\n      }),\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  json: (field: JSONField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: mongoose.Schema.Types.Mixed,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  number: (field: NumberField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: field.hasMany ? [Number] : Number,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  point: (field: PointField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema: SchemaTypeOptions<unknown> = {\n      type: {\n        type: String,\n        enum: ['Point'],\n        ...(typeof field.defaultValue !== 'undefined' && {\n          default: 'Point',\n        }),\n      },\n      coordinates: {\n        type: [Number],\n        default: formatDefaultValue(field),\n        required: false,\n      },\n    }\n    if (\n      buildSchemaOptions.disableUnique &&\n      field.unique &&\n      fieldShouldBeLocalized({ field, parentIsLocalized })\n    ) {\n      baseSchema.coordinates.sparse = true\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n\n    if (field.index === true || field.index === undefined) {\n      const indexOptions: IndexOptions = {}\n      if (!buildSchemaOptions.disableUnique && field.unique) {\n        indexOptions.sparse = true\n        indexOptions.unique = true\n      }\n      if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n        payload.config.localization.locales.forEach((locale) => {\n          schema.index({ [`${field.name}.${locale.code}`]: '2dsphere' }, indexOptions)\n        })\n      } else {\n        schema.index({ [field.name]: '2dsphere' }, indexOptions)\n      }\n    }\n  },\n  radio: (field: RadioField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: String,\n      enum: field.options.map((option) => {\n        if (typeof option === 'object') {\n          return option.value\n        }\n        return option\n      }),\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  relationship: (\n    field: RelationshipField,\n    schema,\n    payload,\n    buildSchemaOptions,\n    parentIsLocalized,\n  ) => {\n    const hasManyRelations = Array.isArray(field.relationTo)\n    let schemaToReturn: { [key: string]: any } = {}\n\n    const valueType = getRelationshipValueType(field, payload)\n\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n      schemaToReturn = {\n        type: payload.config.localization.localeCodes.reduce((locales, locale) => {\n          let localeSchema: { [key: string]: any } = {}\n\n          if (hasManyRelations) {\n            localeSchema = {\n              ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n              _id: false,\n              type: mongoose.Schema.Types.Mixed,\n              relationTo: { type: String, enum: field.relationTo },\n              value: {\n                type: valueType,\n                refPath: `${field.name}.${locale}.relationTo`,\n              },\n            }\n          } else {\n            localeSchema = {\n              ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n              type: valueType,\n              ref: field.relationTo,\n            }\n          }\n\n          return {\n            ...locales,\n            [locale]: field.hasMany\n              ? { type: [localeSchema], default: formatDefaultValue(field) }\n              : localeSchema,\n          }\n        }, {}),\n        localized: true,\n      }\n    } else if (hasManyRelations) {\n      schemaToReturn = {\n        ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n        _id: false,\n        type: mongoose.Schema.Types.Mixed,\n        relationTo: { type: String, enum: field.relationTo },\n        value: {\n          type: valueType,\n          refPath: `${field.name}.relationTo`,\n        },\n      }\n\n      if (field.hasMany) {\n        schemaToReturn = {\n          type: [schemaToReturn],\n          default: formatDefaultValue(field),\n        }\n      }\n    } else {\n      schemaToReturn = {\n        ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n        type: valueType,\n        ref: field.relationTo,\n      }\n\n      if (field.hasMany) {\n        schemaToReturn = {\n          type: [schemaToReturn],\n          default: formatDefaultValue(field),\n        }\n      }\n    }\n\n    schema.add({\n      [field.name]: schemaToReturn,\n    })\n  },\n  richText: (\n    field: RichTextField,\n    schema,\n    payload,\n    buildSchemaOptions,\n    parentIsLocalized,\n  ): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: mongoose.Schema.Types.Mixed,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  row: (field: RowField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    field.fields.forEach((subField: Field) => {\n      if (fieldIsVirtual(subField)) {\n        return\n      }\n\n      const addFieldSchema: FieldSchemaGenerator = fieldToSchemaMap[subField.type]\n\n      if (addFieldSchema) {\n        addFieldSchema(subField, schema, payload, buildSchemaOptions, parentIsLocalized)\n      }\n    })\n  },\n  select: (field: SelectField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: String,\n      enum: field.options.map((option) => {\n        if (typeof option === 'object') {\n          return option.value\n        }\n        return option\n      }),\n    }\n\n    if (buildSchemaOptions.draftsEnabled || !field.required) {\n      baseSchema.enum.push(null)\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        field.hasMany ? [baseSchema] : baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  tabs: (field: TabsField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    field.tabs.forEach((tab) => {\n      if (tabHasName(tab)) {\n        if (fieldIsVirtual(tab)) {\n          return\n        }\n        const baseSchema = {\n          type: buildSchema({\n            buildSchemaOptions: {\n              disableUnique: buildSchemaOptions.disableUnique,\n              draftsEnabled: buildSchemaOptions.draftsEnabled,\n              options: {\n                _id: false,\n                id: false,\n                minimize: false,\n              },\n            },\n            configFields: tab.fields,\n            parentIsLocalized: parentIsLocalized || tab.localized,\n            payload,\n          }),\n        }\n\n        schema.add({\n          [tab.name]: localizeSchema(\n            tab,\n            baseSchema,\n            payload.config.localization,\n            parentIsLocalized,\n          ),\n        })\n      } else {\n        tab.fields.forEach((subField: Field) => {\n          if (fieldIsVirtual(subField)) {\n            return\n          }\n          const addFieldSchema: FieldSchemaGenerator = fieldToSchemaMap[subField.type]\n\n          if (addFieldSchema) {\n            addFieldSchema(\n              subField,\n              schema,\n              payload,\n              buildSchemaOptions,\n              parentIsLocalized || tab.localized,\n            )\n          }\n        })\n      }\n    })\n  },\n  text: (field: TextField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: field.hasMany ? [String] : String,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  textarea: (\n    field: TextareaField,\n    schema,\n    payload,\n    buildSchemaOptions,\n    parentIsLocalized,\n  ): void => {\n    const baseSchema = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: String,\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  },\n  upload: (field: UploadField, schema, payload, buildSchemaOptions, parentIsLocalized): void => {\n    const hasManyRelations = Array.isArray(field.relationTo)\n    let schemaToReturn: { [key: string]: any } = {}\n\n    const valueType = getRelationshipValueType(field, payload)\n\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n      schemaToReturn = {\n        type: payload.config.localization.localeCodes.reduce((locales, locale) => {\n          let localeSchema: { [key: string]: any } = {}\n\n          if (hasManyRelations) {\n            localeSchema = {\n              ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n              _id: false,\n              type: mongoose.Schema.Types.Mixed,\n              relationTo: { type: String, enum: field.relationTo },\n              value: {\n                type: valueType,\n                refPath: `${field.name}.${locale}.relationTo`,\n              },\n            }\n          } else {\n            localeSchema = {\n              ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n              type: valueType,\n              ref: field.relationTo,\n            }\n          }\n\n          return {\n            ...locales,\n            [locale]: field.hasMany\n              ? { type: [localeSchema], default: formatDefaultValue(field) }\n              : localeSchema,\n          }\n        }, {}),\n        localized: true,\n      }\n    } else if (hasManyRelations) {\n      schemaToReturn = {\n        ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n        _id: false,\n        type: mongoose.Schema.Types.Mixed,\n        relationTo: { type: String, enum: field.relationTo },\n        value: {\n          type: valueType,\n          refPath: `${field.name}.relationTo`,\n        },\n      }\n\n      if (field.hasMany) {\n        schemaToReturn = {\n          type: [schemaToReturn],\n          default: formatDefaultValue(field),\n        }\n      }\n    } else {\n      schemaToReturn = {\n        ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n        type: valueType,\n        ref: field.relationTo,\n      }\n\n      if (field.hasMany) {\n        schemaToReturn = {\n          type: [schemaToReturn],\n          default: formatDefaultValue(field),\n        }\n      }\n    }\n\n    schema.add({\n      [field.name]: schemaToReturn,\n    })\n  },\n}\n\nconst getRelationshipValueType = (field: RelationshipField | UploadField, payload: Payload) => {\n  if (typeof field.relationTo === 'string') {\n    const { customIDType } = payload.collections[field.relationTo]\n\n    if (!customIDType) {\n      return mongoose.Schema.Types.ObjectId\n    }\n\n    if (customIDType === 'number') {\n      return mongoose.Schema.Types.Number\n    }\n\n    return mongoose.Schema.Types.String\n  }\n\n  // has custom id relationTo\n  if (\n    field.relationTo.some((relationTo) => {\n      return !!payload.collections[relationTo].customIDType\n    })\n  ) {\n    return mongoose.Schema.Types.Mixed\n  }\n\n  return mongoose.Schema.Types.ObjectId\n}\n"],"names":["mongoose","fieldAffectsData","fieldIsPresentationalOnly","fieldIsVirtual","fieldShouldBeLocalized","tabHasName","formatDefaultValue","field","defaultValue","undefined","formatBaseSchema","buildSchemaOptions","parentIsLocalized","disableUnique","draftsEnabled","indexSortableFields","schema","default","index","unique","required","type","sparse","hidden","localizeSchema","entity","localization","Array","isArray","locales","localeCodes","reduce","localeSchema","locale","_id","localized","buildSchema","args","configFields","payload","allowIDField","options","fields","schemaFields","idField","find","name","Number","String","filter","Schema","forEach","addFieldSchema","fieldToSchemaMap","array","baseSchema","id","minimize","add","config","blocks","fieldSchema","discriminatorKey","blockReferences","blockItem","blockSchema","block","blockField","localeCode","path","discriminator","slug","checkbox","Boolean","code","collapsible","subField","date","Date","email","group","formattedBaseSchema","json","Types","Mixed","number","hasMany","point","enum","coordinates","indexOptions","radio","map","option","value","relationship","hasManyRelations","relationTo","schemaToReturn","valueType","getRelationshipValueType","refPath","ref","richText","row","select","push","tabs","tab","text","textarea","upload","customIDType","collections","ObjectId","some"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3535, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3541, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/models/buildCollectionSchema.ts"],"sourcesContent":["import type { PaginateOptions, Schema } from 'mongoose'\nimport type { Payload, SanitizedCollectionConfig } from 'payload'\n\nimport mongooseAggregatePaginate from 'mongoose-aggregate-paginate-v2'\nimport paginate from 'mongoose-paginate-v2'\n\nimport { getBuildQueryPlugin } from '../queries/getBuildQueryPlugin.js'\nimport { buildSchema } from './buildSchema.js'\n\nexport const buildCollectionSchema = (\n  collection: SanitizedCollectionConfig,\n  payload: Payload,\n  schemaOptions = {},\n): Schema => {\n  const schema = buildSchema({\n    buildSchemaOptions: {\n      draftsEnabled: Boolean(\n        typeof collection?.versions === 'object' && collection.versions.drafts,\n      ),\n      indexSortableFields: payload.config.indexSortableFields,\n      options: {\n        minimize: false,\n        timestamps: collection.timestamps !== false,\n        ...schemaOptions,\n      },\n    },\n    configFields: collection.fields,\n    payload,\n  })\n\n  if (Array.isArray(collection.upload.filenameCompoundIndex)) {\n    const indexDefinition: Record<string, 1> = collection.upload.filenameCompoundIndex.reduce(\n      (acc, index) => {\n        acc[index] = 1\n        return acc\n      },\n      {},\n    )\n\n    schema.index(indexDefinition, { unique: true })\n  }\n\n  schema\n    .plugin<any, PaginateOptions>(paginate, { useEstimatedCount: true })\n    .plugin(getBuildQueryPlugin({ collectionSlug: collection.slug }))\n\n  if (\n    Object.keys(collection.joins).length > 0 ||\n    Object.keys(collection.polymorphicJoins).length > 0\n  ) {\n    schema.plugin(mongooseAggregatePaginate)\n  }\n\n  return schema\n}\n"],"names":["mongooseAggregatePaginate","paginate","getBuildQueryPlugin","buildSchema","buildCollectionSchema","collection","payload","schemaOptions","schema","buildSchemaOptions","draftsEnabled","Boolean","versions","drafts","indexSortableFields","config","options","minimize","timestamps","configFields","fields","Array","isArray","upload","filenameCompoundIndex","indexDefinition","reduce","acc","index","unique","plugin","useEstimatedCount","collectionSlug","slug","Object","keys","joins","length","polymorphicJoins"],"mappings":";;;AAGA,OAAOA,+BAA+B,iCAAgC;AACtE,OAAOC,cAAc,uBAAsB;AAE3C,SAASC,mBAAmB,QAAQ,oCAAmC;AACvE,SAASC,WAAW,QAAQ,mBAAkB;;;;;AAEvC,MAAMC,wBAAwB,CACnCC,YACAC,SACAC,gBAAgB,CAAC,CAAC;IAElB,MAAMC,8LAASL,cAAAA,EAAY;QACzBM,oBAAoB;YAClBC,eAAeC,QACb,OAAON,YAAYO,aAAa,YAAYP,WAAWO,QAAQ,CAACC,MAAM;YAExEC,qBAAqBR,QAAQS,MAAM,CAACD,mBAAmB;YACvDE,SAAS;gBACPC,UAAU;gBACVC,YAAYb,WAAWa,UAAU,KAAK;gBACtC,GAAGX,aAAa;YAClB;QACF;QACAY,cAAcd,WAAWe,MAAM;QAC/Bd;IACF;IAEA,IAAIe,MAAMC,OAAO,CAACjB,WAAWkB,MAAM,CAACC,qBAAqB,GAAG;QAC1D,MAAMC,kBAAqCpB,WAAWkB,MAAM,CAACC,qBAAqB,CAACE,MAAM,CACvF,CAACC,KAAKC;YACJD,GAAG,CAACC,MAAM,GAAG;YACb,OAAOD;QACT,GACA,CAAC;QAGHnB,OAAOoB,KAAK,CAACH,iBAAiB;YAAEI,QAAQ;QAAK;IAC/C;IAEArB,OACGsB,MAAM,+JAAuB7B,UAAAA,EAAU;QAAE8B,mBAAmB;IAAK,GACjED,MAAM,+LAAC5B,sBAAAA,EAAoB;QAAE8B,gBAAgB3B,WAAW4B,IAAI;IAAC;IAEhE,IACEC,OAAOC,IAAI,CAAC9B,WAAW+B,KAAK,EAAEC,MAAM,GAAG,KACvCH,OAAOC,IAAI,CAAC9B,WAAWiC,gBAAgB,EAAED,MAAM,GAAG,GAClD;QACA7B,OAAOsB,MAAM,oKAAC9B,UAAAA;IAChB;IAEA,OAAOQ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3585, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3591, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/models/buildGlobalModel.ts"],"sourcesContent":["import type { Payload } from 'payload'\n\nimport mongoose from 'mongoose'\n\nimport type { GlobalModel } from '../types.js'\n\nimport { getBuildQueryPlugin } from '../queries/getBuildQueryPlugin.js'\nimport { buildSchema } from './buildSchema.js'\n\nexport const buildGlobalModel = (payload: Payload): GlobalModel | null => {\n  if (payload.config.globals && payload.config.globals.length > 0) {\n    const globalsSchema = new mongoose.Schema(\n      {},\n      { discriminatorKey: 'globalType', minimize: false, timestamps: true },\n    )\n\n    globalsSchema.plugin(getBuildQueryPlugin())\n\n    const Globals = mongoose.model('globals', globalsSchema, 'globals') as unknown as GlobalModel\n\n    Object.values(payload.config.globals).forEach((globalConfig) => {\n      const globalSchema = buildSchema({\n        buildSchemaOptions: {\n          options: {\n            minimize: false,\n          },\n        },\n        configFields: globalConfig.fields,\n        payload,\n      })\n      Globals.discriminator(globalConfig.slug, globalSchema)\n    })\n\n    return Globals\n  }\n\n  return null\n}\n"],"names":["mongoose","getBuildQueryPlugin","buildSchema","buildGlobalModel","payload","config","globals","length","globalsSchema","Schema","discriminatorKey","minimize","timestamps","plugin","Globals","model","Object","values","forEach","globalConfig","globalSchema","buildSchemaOptions","options","configFields","fields","discriminator","slug"],"mappings":";;;AAEA,OAAOA,cAAc,WAAU;AAI/B,SAASC,mBAAmB,QAAQ,oCAAmC;AACvE,SAASC,WAAW,QAAQ,mBAAkB;;;;AAEvC,MAAMC,mBAAmB,CAACC;IAC/B,IAAIA,QAAQC,MAAM,CAACC,OAAO,IAAIF,QAAQC,MAAM,CAACC,OAAO,CAACC,MAAM,GAAG,GAAG;QAC/D,MAAMC,gBAAgB,8GAAIR,UAAAA,CAASS,MAAM,CACvC,CAAC,GACD;YAAEC,kBAAkB;YAAcC,UAAU;YAAOC,YAAY;QAAK;QAGtEJ,cAAcK,MAAM,+LAACZ,sBAAAA;QAErB,MAAMa,oHAAUd,UAAAA,CAASe,KAAK,CAAC,WAAWP,eAAe;QAEzDQ,OAAOC,MAAM,CAACb,QAAQC,MAAM,CAACC,OAAO,EAAEY,OAAO,CAAC,CAACC;YAC7C,MAAMC,oMAAelB,cAAAA,EAAY;gBAC/BmB,oBAAoB;oBAClBC,SAAS;wBACPX,UAAU;oBACZ;gBACF;gBACAY,cAAcJ,aAAaK,MAAM;gBACjCpB;YACF;YACAU,QAAQW,aAAa,CAACN,aAAaO,IAAI,EAAEN;QAC3C;QAEA,OAAON;IACT;IAEA,OAAO;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3625, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3631, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/utilities/getDBName.ts"],"sourcesContent":["import type { DBIdentifierName } from 'payload'\n\ntype Args = {\n  config: {\n    dbName?: DBIdentifierName\n    enumName?: DBIdentifierName\n    name?: string\n    slug?: string\n  }\n  locales?: boolean\n  target?: 'dbName' | 'enumName'\n  versions?: boolean\n}\n\n/**\n * Used to name database enums and collections\n * Returns the collection or enum name for a given entity\n */\nexport const getDBName = ({\n  config: { name, slug },\n  config,\n  target = 'dbName',\n  versions = false,\n}: Args): string => {\n  let result: string\n  let custom = config[target]\n\n  if (!custom && target === 'enumName') {\n    custom = config['dbName']\n  }\n\n  if (custom) {\n    result = typeof custom === 'function' ? custom({}) : custom\n  } else {\n    result = name ?? slug\n  }\n\n  if (versions) {\n    result = `_${result}_versions`\n  }\n\n  return result\n}\n"],"names":["getDBName","config","name","slug","target","versions","result","custom"],"mappings":"AAcA;;;CAGC,GACD;;;AAAO,MAAMA,YAAY,CAAC,EACxBC,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAE,EACtBF,MAAM,EACNG,SAAS,QAAQ,EACjBC,WAAW,KAAK,EACX;IACL,IAAIC;IACJ,IAAIC,SAASN,MAAM,CAACG,OAAO;IAE3B,IAAI,CAACG,UAAUH,WAAW,YAAY;QACpCG,SAASN,MAAM,CAAC,SAAS;IAC3B;IAEA,IAAIM,QAAQ;QACVD,SAAS,OAAOC,WAAW,aAAaA,OAAO,CAAC,KAAKA;IACvD,OAAO;QACLD,SAASJ,QAAQC;IACnB;IAEA,IAAIE,UAAU;QACZC,SAAS,CAAC,CAAC,EAAEA,OAAO,SAAS,CAAC;IAChC;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3653, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3659, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/init.ts"],"sourcesContent":["import type { PaginateOptions } from 'mongoose'\nimport type { Init, SanitizedCollectionConfig } from 'payload'\n\nimport mongoose from 'mongoose'\nimport mongooseAggregatePaginate from 'mongoose-aggregate-paginate-v2'\nimport paginate from 'mongoose-paginate-v2'\nimport { buildVersionCollectionFields, buildVersionGlobalFields } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\nimport type { CollectionModel } from './types.js'\n\nimport { buildCollectionSchema } from './models/buildCollectionSchema.js'\nimport { buildGlobalModel } from './models/buildGlobalModel.js'\nimport { buildSchema } from './models/buildSchema.js'\nimport { getBuildQueryPlugin } from './queries/getBuildQueryPlugin.js'\nimport { getDBName } from './utilities/getDBName.js'\n\nexport const init: Init = function init(this: MongooseAdapter) {\n  this.payload.config.collections.forEach((collection: SanitizedCollectionConfig) => {\n    const schemaOptions = this.collectionsSchemaOptions[collection.slug]\n\n    const schema = buildCollectionSchema(collection, this.payload, schemaOptions)\n\n    if (collection.versions) {\n      const versionModelName = getDBName({ config: collection, versions: true })\n\n      const versionCollectionFields = buildVersionCollectionFields(this.payload.config, collection)\n\n      const versionSchema = buildSchema({\n        buildSchemaOptions: {\n          disableUnique: true,\n          draftsEnabled: true,\n          indexSortableFields: this.payload.config.indexSortableFields,\n          options: {\n            minimize: false,\n            timestamps: false,\n          },\n          ...schemaOptions,\n        },\n        configFields: versionCollectionFields,\n        payload: this.payload,\n      })\n\n      versionSchema.plugin<any, PaginateOptions>(paginate, { useEstimatedCount: true }).plugin(\n        getBuildQueryPlugin({\n          collectionSlug: collection.slug,\n          versionsFields: buildVersionCollectionFields(this.payload.config, collection, true),\n        }),\n      )\n\n      if (Object.keys(collection.joins).length > 0) {\n        versionSchema.plugin(mongooseAggregatePaginate)\n      }\n\n      const versionCollectionName =\n        this.autoPluralization === true && !collection.dbName ? undefined : versionModelName\n\n      this.versions[collection.slug] = mongoose.model(\n        versionModelName,\n        versionSchema,\n        versionCollectionName,\n      ) as CollectionModel\n    }\n\n    const modelName = getDBName({ config: collection })\n    const collectionName =\n      this.autoPluralization === true && !collection.dbName ? undefined : modelName\n\n    this.collections[collection.slug] = mongoose.model(\n      modelName,\n      schema,\n      collectionName,\n    ) as CollectionModel\n  })\n\n  this.globals = buildGlobalModel(this.payload)\n\n  this.payload.config.globals.forEach((global) => {\n    if (global.versions) {\n      const versionModelName = getDBName({ config: global, versions: true })\n\n      const versionGlobalFields = buildVersionGlobalFields(this.payload.config, global)\n\n      const versionSchema = buildSchema({\n        buildSchemaOptions: {\n          disableUnique: true,\n          draftsEnabled: true,\n          indexSortableFields: this.payload.config.indexSortableFields,\n          options: {\n            minimize: false,\n            timestamps: false,\n          },\n        },\n        configFields: versionGlobalFields,\n        payload: this.payload,\n      })\n\n      versionSchema.plugin<any, PaginateOptions>(paginate, { useEstimatedCount: true }).plugin(\n        getBuildQueryPlugin({\n          versionsFields: buildVersionGlobalFields(this.payload.config, global, true),\n        }),\n      )\n\n      this.versions[global.slug] = mongoose.model(\n        versionModelName,\n        versionSchema,\n        versionModelName,\n      ) as CollectionModel\n    }\n  })\n}\n"],"names":["mongoose","mongooseAggregatePaginate","paginate","buildVersionCollectionFields","buildVersionGlobalFields","buildCollectionSchema","buildGlobalModel","buildSchema","getBuildQueryPlugin","getDBName","init","payload","config","collections","forEach","collection","schemaOptions","collectionsSchemaOptions","slug","schema","versions","versionModelName","versionCollectionFields","versionSchema","buildSchemaOptions","disableUnique","draftsEnabled","indexSortableFields","options","minimize","timestamps","configFields","plugin","useEstimatedCount","collectionSlug","versionsFields","Object","keys","joins","length","versionCollectionName","autoPluralization","dbName","undefined","model","modelName","collectionName","globals","global","versionGlobalFields"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3753, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3759, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/migrateFresh.ts"],"sourcesContent":["import type { PayloadRequest } from 'payload'\n\nimport { commitTransaction, initTransaction, killTransaction, readMigrationFiles } from 'payload'\nimport prompts from 'prompts'\n\nimport type { MongooseAdapter } from './index.js'\n\n/**\n * Drop the current database and run all migrate up functions\n */\nexport async function migrateFresh(\n  this: MongooseAdapter,\n  { forceAcceptWarning = false }: { forceAcceptWarning?: boolean },\n): Promise<void> {\n  const { payload } = this\n\n  if (!forceAcceptWarning) {\n    const { confirm: acceptWarning } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message: `WARNING: This will drop your database and run all migrations. Are you sure you want to proceed?`,\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    if (!acceptWarning) {\n      process.exit(0)\n    }\n  }\n\n  payload.logger.info({\n    msg: `Dropping database.`,\n  })\n\n  await this.connection.dropDatabase()\n\n  const migrationFiles = await readMigrationFiles({ payload })\n  payload.logger.debug({\n    msg: `Found ${migrationFiles.length} migration files.`,\n  })\n\n  const req = { payload }\n\n  // Run all migrate up\n  for (const migration of migrationFiles) {\n    payload.logger.info({ msg: `Migrating: ${migration.name}` })\n    try {\n      const start = Date.now()\n      await initTransaction(req)\n      await migration.up({ payload, req })\n      await payload.create({\n        collection: 'payload-migrations',\n        data: {\n          name: migration.name,\n          batch: 1,\n        },\n        req,\n      })\n\n      await commitTransaction(req)\n\n      payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    } catch (err: unknown) {\n      await killTransaction(req)\n      payload.logger.error({\n        err,\n        msg: `Error running migration ${migration.name}. Rolling back.`,\n      })\n      throw err\n    }\n  }\n}\n"],"names":["commitTransaction","initTransaction","killTransaction","readMigrationFiles","prompts","migrateFresh","forceAcceptWarning","payload","confirm","acceptWarning","name","type","initial","message","onCancel","process","exit","logger","info","msg","connection","dropDatabase","migrationFiles","debug","length","req","migration","start","Date","now","up","create","collection","data","batch","err","error"],"mappings":";;;AAGA,OAAOI,aAAa,UAAS;AAD7B,SAASJ,iBAAiB,EAAEC,eAAe,EAAEC,eAAe,EAAEC,kBAAkB,QAAQ,UAAS;;;;;;AAQ1F,eAAeE,aAEpB,EAAEC,qBAAqB,KAAK,EAAoC;IAEhE,MAAM,EAAEC,OAAO,EAAE,GAAG,IAAI;IAExB,IAAI,CAACD,oBAAoB;QACvB,MAAM,EAAEE,SAASC,aAAa,EAAE,GAAG,6IAAML,UAAAA,EACvC;YACEM,MAAM;YACNC,MAAM;YACNC,SAAS;YACTC,SAAS,CAAC,+FAA+F,CAAC;QAC5G,GACA;YACEC,UAAU;gBACRC,QAAQC,IAAI,CAAC;YACf;QACF;QAGF,IAAI,CAACP,eAAe;YAClBM,QAAQC,IAAI,CAAC;QACf;IACF;IAEAT,QAAQU,MAAM,CAACC,IAAI,CAAC;QAClBC,KAAK,CAAC,kBAAkB,CAAC;IAC3B;IAEA,MAAM,IAAI,CAACC,UAAU,CAACC,YAAY;IAElC,MAAMC,iBAAiB,4LAAMnB,qBAAAA,EAAmB;QAAEI;IAAQ;IAC1DA,QAAQU,MAAM,CAACM,KAAK,CAAC;QACnBJ,KAAK,CAAC,MAAM,EAAEG,eAAeE,MAAM,CAAC,iBAAiB,CAAC;IACxD;IAEA,MAAMC,MAAM;QAAElB;IAAQ;IAEtB,qBAAqB;IACrB,KAAK,MAAMmB,aAAaJ,eAAgB;QACtCf,QAAQU,MAAM,CAACC,IAAI,CAAC;YAAEC,KAAK,CAAC,WAAW,EAAEO,UAAUhB,IAAI,EAAE;QAAC;QAC1D,IAAI;YACF,MAAMiB,QAAQC,KAAKC,GAAG;YACtB,4KAAM5B,kBAAAA,EAAgBwB;YACtB,MAAMC,UAAUI,EAAE,CAAC;gBAAEvB;gBAASkB;YAAI;YAClC,MAAMlB,QAAQwB,MAAM,CAAC;gBACnBC,YAAY;gBACZC,MAAM;oBACJvB,MAAMgB,UAAUhB,IAAI;oBACpBwB,OAAO;gBACT;gBACAT;YACF;YAEA,8KAAMzB,oBAAAA,EAAkByB;YAExBlB,QAAQU,MAAM,CAACC,IAAI,CAAC;gBAAEC,KAAK,CAAC,WAAW,EAAEO,UAAUhB,IAAI,CAAC,EAAE,EAAEkB,KAAKC,GAAG,KAAKF,MAAM,GAAG,CAAC;YAAC;QACtF,EAAE,OAAOQ,KAAc;YACrB,4KAAMjC,kBAAAA,EAAgBuB;YACtBlB,QAAQU,MAAM,CAACmB,KAAK,CAAC;gBACnBD;gBACAhB,KAAK,CAAC,wBAAwB,EAAEO,UAAUhB,IAAI,CAAC,eAAe,CAAC;YACjE;YACA,MAAMyB;QACR;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3833, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3839, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/queryDrafts.ts"],"sourcesContent":["import type { PaginateOptions, QueryOptions } from 'mongoose'\nimport type { QueryDrafts } from 'payload'\n\nimport { buildVersionCollectionFields, combineQueries, flattenWhereToOperators } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildSortParam } from './queries/buildSortParam.js'\nimport { buildJoinAggregation } from './utilities/buildJoinAggregation.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\n\nexport const queryDrafts: QueryDrafts = async function queryDrafts(\n  this: MongooseAdapter,\n  { collection, joins, limit, locale, page, pagination, req, select, sort: sortArg, where },\n) {\n  const VersionModel = this.versions[collection]\n  const collectionConfig = this.payload.collections[collection].config\n  const options: QueryOptions = {\n    session: await getSession(this, req),\n  }\n\n  let hasNearConstraint\n  let sort\n\n  if (where) {\n    const constraints = flattenWhereToOperators(where)\n    hasNearConstraint = constraints.some((prop) => Object.keys(prop).some((key) => key === 'near'))\n  }\n\n  if (!hasNearConstraint) {\n    sort = buildSortParam({\n      config: this.payload.config,\n      fields: collectionConfig.flattenedFields,\n      locale,\n      sort: sortArg || collectionConfig.defaultSort,\n      timestamps: true,\n    })\n  }\n\n  const combinedWhere = combineQueries({ latest: { equals: true } }, where)\n\n  const fields = buildVersionCollectionFields(this.payload.config, collectionConfig, true)\n  const versionQuery = await buildQuery({\n    adapter: this,\n    fields,\n    locale,\n    where: combinedWhere,\n  })\n\n  const projection = buildProjectionFromSelect({\n    adapter: this,\n    fields,\n    select,\n  })\n  // useEstimatedCount is faster, but not accurate, as it ignores any filters. It is thus set to true if there are no filters.\n  const useEstimatedCount =\n    hasNearConstraint || !versionQuery || Object.keys(versionQuery).length === 0\n  const paginationOptions: PaginateOptions = {\n    lean: true,\n    leanWithId: true,\n    options,\n    page,\n    pagination,\n    projection,\n    sort,\n    useEstimatedCount,\n  }\n\n  if (this.collation) {\n    const defaultLocale = 'en'\n    paginationOptions.collation = {\n      locale: locale && locale !== 'all' && locale !== '*' ? locale : defaultLocale,\n      ...this.collation,\n    }\n  }\n\n  if (\n    !useEstimatedCount &&\n    Object.keys(versionQuery).length === 0 &&\n    this.disableIndexHints !== true\n  ) {\n    // Improve the performance of the countDocuments query which is used if useEstimatedCount is set to false by adding\n    // a hint. By default, if no hint is provided, MongoDB does not use an indexed field to count the returned documents,\n    // which makes queries very slow. This only happens when no query (filter) is provided. If one is provided, it uses\n    // the correct indexed field\n    paginationOptions.useCustomCountFn = () => {\n      return Promise.resolve(\n        VersionModel.countDocuments(versionQuery, {\n          hint: { _id: 1 },\n        }),\n      )\n    }\n  }\n\n  if (limit > 0) {\n    paginationOptions.limit = limit\n    // limit must also be set here, it's ignored when pagination is false\n    paginationOptions.options.limit = limit\n  }\n\n  let result\n\n  const aggregate = await buildJoinAggregation({\n    adapter: this,\n    collection,\n    collectionConfig,\n    joins,\n    locale,\n    projection,\n    query: versionQuery,\n    versions: true,\n  })\n\n  // build join aggregation\n  if (aggregate) {\n    result = await VersionModel.aggregatePaginate(\n      VersionModel.aggregate(aggregate),\n      paginationOptions,\n    )\n  } else {\n    result = await VersionModel.paginate(versionQuery, paginationOptions)\n  }\n\n  const docs = JSON.parse(JSON.stringify(result.docs))\n\n  return {\n    ...result,\n    docs: docs.map((doc) => {\n      doc = {\n        _id: doc.parent,\n        id: doc.parent,\n        ...doc.version,\n      }\n\n      return sanitizeInternalFields(doc)\n    }),\n  }\n}\n"],"names":["buildVersionCollectionFields","combineQueries","flattenWhereToOperators","buildQuery","buildSortParam","buildJoinAggregation","buildProjectionFromSelect","getSession","sanitizeInternalFields","queryDrafts","collection","joins","limit","locale","page","pagination","req","select","sort","sortArg","where","VersionModel","versions","collectionConfig","payload","collections","config","options","session","hasNearConstraint","constraints","some","prop","Object","keys","key","fields","flattenedFields","defaultSort","timestamps","combinedWhere","latest","equals","versionQuery","adapter","projection","useEstimatedCount","length","paginationOptions","lean","leanWithId","collation","defaultLocale","disableIndexHints","useCustomCountFn","Promise","resolve","countDocuments","hint","_id","result","aggregate","query","aggregatePaginate","paginate","docs","JSON","parse","stringify","map","doc","parent","id","version"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3963, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3969, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/transactions/beginTransaction.ts"],"sourcesContent":["import type { TransactionOptions } from 'mongodb'\nimport type { BeginTransaction } from 'payload'\n\nimport { APIError } from 'payload'\nimport { v4 as uuid } from 'uuid'\n\nimport type { MongooseAdapter } from '../index.js'\n\n// Needs await to fulfill the interface\n// eslint-disable-next-line @typescript-eslint/require-await\nexport const beginTransaction: BeginTransaction = async function beginTransaction(\n  this: MongooseAdapter,\n  options: TransactionOptions,\n) {\n  if (!this.connection) {\n    throw new APIError('beginTransaction called while no connection to the database exists')\n  }\n\n  const client = this.connection.getClient()\n  const id = uuid()\n\n  if (!this.sessions[id]) {\n    this.sessions[id] = client.startSession()\n  }\n  if (this.sessions[id].inTransaction()) {\n    this.payload.logger.warn('beginTransaction called while transaction already exists')\n  } else {\n    this.sessions[id].startTransaction(options || (this.transactionOptions as TransactionOptions))\n  }\n\n  return id\n}\n"],"names":["APIError","v4","uuid","beginTransaction","options","connection","client","getClient","id","sessions","startSession","inTransaction","payload","logger","warn","startTransaction","transactionOptions"],"mappings":";;;AAGA,SAASA,QAAQ,QAAQ,UAAS;AAClC,SAASC,MAAMC,IAAI,QAAQ,OAAM;;;AAM1B,MAAMC,mBAAqC,eAAeA,iBAE/DC,OAA2B;IAE3B,IAAI,CAAC,IAAI,CAACC,UAAU,EAAE;QACpB,MAAM,4JAAIL,WAAAA,CAAS;IACrB;IAEA,MAAMM,SAAS,IAAI,CAACD,UAAU,CAACE,SAAS;IACxC,MAAMC,8LAAKN,KAAAA;IAEX,IAAI,CAAC,IAAI,CAACO,QAAQ,CAACD,GAAG,EAAE;QACtB,IAAI,CAACC,QAAQ,CAACD,GAAG,GAAGF,OAAOI,YAAY;IACzC;IACA,IAAI,IAAI,CAACD,QAAQ,CAACD,GAAG,CAACG,aAAa,IAAI;QACrC,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC;IAC3B,OAAO;QACL,IAAI,CAACL,QAAQ,CAACD,GAAG,CAACO,gBAAgB,CAACX,WAAY,IAAI,CAACY,kBAAkB;IACxE;IAEA,OAAOR;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3992, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3998, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/transactions/commitTransaction.ts"],"sourcesContent":["import type { CommitTransaction } from 'payload'\n\nexport const commitTransaction: CommitTransaction = async function commitTransaction(id) {\n  if (id instanceof Promise) {\n    return\n  }\n\n  if (!this.sessions[id]?.inTransaction()) {\n    return\n  }\n\n  await this.sessions[id].commitTransaction()\n  try {\n    await this.sessions[id].endSession()\n  } catch (error) {\n    // ending sessions is only best effort and won't impact anything if it fails since the transaction was committed\n  }\n  delete this.sessions[id]\n}\n"],"names":["commitTransaction","id","Promise","sessions","inTransaction","endSession","error"],"mappings":";;;AAEO,MAAMA,oBAAuC,eAAeA,kBAAkBC,EAAE;IACrF,IAAIA,cAAcC,SAAS;QACzB;IACF;IAEA,IAAI,CAAC,IAAI,CAACC,QAAQ,CAACF,GAAG,EAAEG,iBAAiB;QACvC;IACF;IAEA,MAAM,IAAI,CAACD,QAAQ,CAACF,GAAG,CAACD,iBAAiB;IACzC,IAAI;QACF,MAAM,IAAI,CAACG,QAAQ,CAACF,GAAG,CAACI,UAAU;IACpC,EAAE,OAAOC,OAAO;IACd,gHAAgH;IAClH;IACA,OAAO,IAAI,CAACH,QAAQ,CAACF,GAAG;AAC1B,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4016, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4022, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/transactions/rollbackTransaction.ts"],"sourcesContent":["import type { RollbackTransaction } from 'payload'\n\nexport const rollbackTransaction: RollbackTransaction = async function rollbackTransaction(\n  incomingID = '',\n) {\n  let transactionID: number | string\n\n  if (incomingID instanceof Promise) {\n    transactionID = await incomingID\n  } else {\n    transactionID = incomingID\n  }\n\n  // if multiple operations are using the same transaction, the first will flow through and delete the session.\n  // subsequent calls should be ignored.\n  if (!this.sessions[transactionID]) {\n    return\n  }\n\n  // when session exists but is not inTransaction something unexpected is happening to the session\n  if (!this.sessions[transactionID].inTransaction()) {\n    this.payload.logger.warn('rollbackTransaction called when no transaction exists')\n    delete this.sessions[transactionID]\n    return\n  }\n\n  // the first call for rollback should be aborted and deleted causing any other operations with the same transaction to fail\n  try {\n    await this.sessions[transactionID].abortTransaction()\n    await this.sessions[transactionID].endSession()\n  } catch (error) {\n    // ignore the error as it is likely a race condition from multiple errors\n  }\n  delete this.sessions[transactionID]\n}\n"],"names":["rollbackTransaction","incomingID","transactionID","Promise","sessions","inTransaction","payload","logger","warn","abortTransaction","endSession","error"],"mappings":";;;AAEO,MAAMA,sBAA2C,eAAeA,oBACrEC,aAAa,EAAE;IAEf,IAAIC;IAEJ,IAAID,sBAAsBE,SAAS;QACjCD,gBAAgB,MAAMD;IACxB,OAAO;QACLC,gBAAgBD;IAClB;IAEA,6GAA6G;IAC7G,sCAAsC;IACtC,IAAI,CAAC,IAAI,CAACG,QAAQ,CAACF,cAAc,EAAE;QACjC;IACF;IAEA,gGAAgG;IAChG,IAAI,CAAC,IAAI,CAACE,QAAQ,CAACF,cAAc,CAACG,aAAa,IAAI;QACjD,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC;QACzB,OAAO,IAAI,CAACJ,QAAQ,CAACF,cAAc;QACnC;IACF;IAEA,2HAA2H;IAC3H,IAAI;QACF,MAAM,IAAI,CAACE,QAAQ,CAACF,cAAc,CAACO,gBAAgB;QACnD,MAAM,IAAI,CAACL,QAAQ,CAACF,cAAc,CAACQ,UAAU;IAC/C,EAAE,OAAOC,OAAO;IACd,yEAAyE;IAC3E;IACA,OAAO,IAAI,CAACP,QAAQ,CAACF,cAAc;AACrC,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4052, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4058, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/updateGlobal.ts"],"sourcesContent":["import type { QueryOptions } from 'mongoose'\nimport type { UpdateGlobal } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport const updateGlobal: UpdateGlobal = async function updateGlobal(\n  this: MongooseAdapter,\n  { slug, data, options: optionsArgs = {}, req, select },\n) {\n  const Model = this.globals\n  const fields = this.payload.config.globals.find((global) => global.slug === slug).fields\n\n  const options: QueryOptions = {\n    ...optionsArgs,\n    lean: true,\n    new: true,\n    projection: buildProjectionFromSelect({\n      adapter: this,\n      fields: this.payload.config.globals.find((global) => global.slug === slug).flattenedFields,\n      select,\n    }),\n    session: await getSession(this, req),\n  }\n\n  let result\n\n  const sanitizedData = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data,\n    fields,\n  })\n\n  result = await Model.findOneAndUpdate({ globalType: slug }, sanitizedData, options)\n\n  if (!result) {\n    return null\n  }\n\n  result = JSON.parse(JSON.stringify(result))\n\n  // custom id type reset\n  result.id = result._id\n  result = sanitizeInternalFields(result)\n\n  return result\n}\n"],"names":["buildProjectionFromSelect","getSession","sanitizeInternalFields","sanitizeRelationshipIDs","updateGlobal","slug","data","options","optionsArgs","req","select","Model","globals","fields","payload","config","find","global","lean","new","projection","adapter","flattenedFields","session","result","sanitizedData","findOneAndUpdate","globalType","JSON","parse","stringify","id","_id"],"mappings":";;;AAKA,SAASA,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,sBAAsB,QAAQ,wCAAuC;AAC9E,SAASC,uBAAuB,QAAQ,yCAAwC;;;;;AAEzE,MAAMC,eAA6B,eAAeA,aAEvD,EAAEC,IAAI,EAAEC,IAAI,EAAEC,SAASC,cAAc,CAAC,CAAC,EAAEC,GAAG,EAAEC,MAAM,EAAE;IAEtD,MAAMC,QAAQ,IAAI,CAACC,OAAO;IAC1B,MAAMC,SAAS,IAAI,CAACC,OAAO,CAACC,MAAM,CAACH,OAAO,CAACI,IAAI,CAAC,CAACC,SAAWA,OAAOZ,IAAI,KAAKA,MAAMQ,MAAM;IAExF,MAAMN,UAAwB;QAC5B,GAAGC,WAAW;QACdU,MAAM;QACNC,KAAK;QACLC,kNAAYpB,4BAAAA,EAA0B;YACpCqB,SAAS,IAAI;YACbR,QAAQ,IAAI,CAACC,OAAO,CAACC,MAAM,CAACH,OAAO,CAACI,IAAI,CAAC,CAACC,SAAWA,OAAOZ,IAAI,KAAKA,MAAMiB,eAAe;YAC1FZ;QACF;QACAa,SAAS,MAAMtB,oMAAAA,EAAW,IAAI,EAAEQ;IAClC;IAEA,IAAIe;IAEJ,MAAMC,oNAAgBtB,0BAAAA,EAAwB;QAC5CY,QAAQ,IAAI,CAACD,OAAO,CAACC,MAAM;QAC3BT;QACAO;IACF;IAEAW,SAAS,MAAMb,MAAMe,gBAAgB,CAAC;QAAEC,YAAYtB;IAAK,GAAGoB,eAAelB;IAE3E,IAAI,CAACiB,QAAQ;QACX,OAAO;IACT;IAEAA,SAASI,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACN;IAEnC,uBAAuB;IACvBA,OAAOO,EAAE,GAAGP,OAAOQ,GAAG;IACtBR,4MAAStB,yBAAAA,EAAuBsB;IAEhC,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4101, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4107, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/updateGlobalVersion.ts"],"sourcesContent":["import type { QueryOptions } from 'mongoose'\n\nimport { buildVersionGlobalFields, type TypeWithID, type UpdateGlobalVersionArgs } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport async function updateGlobalVersion<T extends TypeWithID>(\n  this: MongooseAdapter,\n  {\n    id,\n    global: globalSlug,\n    locale,\n    options: optionsArgs = {},\n    req,\n    select,\n    versionData,\n    where,\n  }: UpdateGlobalVersionArgs<T>,\n) {\n  const VersionModel = this.versions[globalSlug]\n  const whereToUse = where || { id: { equals: id } }\n\n  const currentGlobal = this.payload.config.globals.find((global) => global.slug === globalSlug)\n  const fields = buildVersionGlobalFields(this.payload.config, currentGlobal)\n  const flattenedFields = buildVersionGlobalFields(this.payload.config, currentGlobal, true)\n  const options: QueryOptions = {\n    ...optionsArgs,\n    lean: true,\n    new: true,\n    projection: buildProjectionFromSelect({\n      adapter: this,\n      fields: flattenedFields,\n      select,\n    }),\n    session: await getSession(this, req),\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    fields: flattenedFields,\n    locale,\n    where: whereToUse,\n  })\n\n  const sanitizedData = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data: versionData,\n    fields,\n  })\n\n  const doc = await VersionModel.findOneAndUpdate(query, sanitizedData, options)\n\n  if (!doc) {\n    return null\n  }\n\n  const result = JSON.parse(JSON.stringify(doc))\n\n  const verificationToken = doc._verificationToken\n\n  // custom id type reset\n  result.id = result._id\n  if (verificationToken) {\n    result._verificationToken = verificationToken\n  }\n  return result\n}\n"],"names":["buildVersionGlobalFields","buildQuery","buildProjectionFromSelect","getSession","sanitizeRelationshipIDs","updateGlobalVersion","id","global","globalSlug","locale","options","optionsArgs","req","select","versionData","where","VersionModel","versions","whereToUse","equals","currentGlobal","payload","config","globals","find","slug","fields","flattenedFields","lean","new","projection","adapter","session","query","sanitizedData","data","doc","findOneAndUpdate","result","JSON","parse","stringify","verificationToken","_verificationToken","_id"],"mappings":";;;AAMA,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,uBAAuB,QAAQ,yCAAwC;AAPhF,SAASJ,wBAAwB,QAAuD,UAAS;;;;;;AAS1F,eAAeK,oBAEpB,EACEC,EAAE,EACFC,QAAQC,UAAU,EAClBC,MAAM,EACNC,SAASC,cAAc,CAAC,CAAC,EACzBC,GAAG,EACHC,MAAM,EACNC,WAAW,EACXC,KAAK,EACsB;IAE7B,MAAMC,eAAe,IAAI,CAACC,QAAQ,CAACT,WAAW;IAC9C,MAAMU,aAAaH,SAAS;QAAET,IAAI;YAAEa,QAAQb;QAAG;IAAE;IAEjD,MAAMc,gBAAgB,IAAI,CAACC,OAAO,CAACC,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,CAACjB,SAAWA,OAAOkB,IAAI,KAAKjB;IACnF,MAAMkB,SAAS1B,kMAAAA,EAAyB,IAAI,CAACqB,OAAO,CAACC,MAAM,EAAEF;IAC7D,MAAMO,yLAAkB3B,2BAAAA,EAAyB,IAAI,CAACqB,OAAO,CAACC,MAAM,EAAEF,eAAe;IACrF,MAAMV,UAAwB;QAC5B,GAAGC,WAAW;QACdiB,MAAM;QACNC,KAAK;QACLC,kNAAY5B,4BAAAA,EAA0B;YACpC6B,SAAS,IAAI;YACbL,QAAQC;YACRd;QACF;QACAmB,SAAS,MAAM7B,oMAAAA,EAAW,IAAI,EAAES;IAClC;IAEA,MAAMqB,QAAQ,2LAAMhC,aAAAA,EAAW;QAC7B8B,SAAS,IAAI;QACbL,QAAQC;QACRlB;QACAM,OAAOG;IACT;IAEA,MAAMgB,oNAAgB9B,0BAAAA,EAAwB;QAC5CkB,QAAQ,IAAI,CAACD,OAAO,CAACC,MAAM;QAC3Ba,MAAMrB;QACNY;IACF;IAEA,MAAMU,MAAM,MAAMpB,aAAaqB,gBAAgB,CAACJ,OAAOC,eAAexB;IAEtE,IAAI,CAAC0B,KAAK;QACR,OAAO;IACT;IAEA,MAAME,SAASC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACL;IAEzC,MAAMM,oBAAoBN,IAAIO,kBAAkB;IAEhD,uBAAuB;IACvBL,OAAOhC,EAAE,GAAGgC,OAAOM,GAAG;IACtB,IAAIF,mBAAmB;QACrBJ,OAAOK,kBAAkB,GAAGD;IAC9B;IACA,OAAOJ;AACT","ignoreList":[0]}},
    {"offset": {"line": 4165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4171, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/updateOne.ts"],"sourcesContent":["import type { QueryOptions } from 'mongoose'\nimport type { UpdateOne } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { handleError } from './utilities/handleError.js'\nimport { sanitizeInternalFields } from './utilities/sanitizeInternalFields.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport const updateOne: UpdateOne = async function updateOne(\n  this: MongooseAdapter,\n  { id, collection, data, locale, options: optionsArgs = {}, req, select, where: whereArg },\n) {\n  const where = id ? { id: { equals: id } } : whereArg\n  const Model = this.collections[collection]\n  const fields = this.payload.collections[collection].config.fields\n  const options: QueryOptions = {\n    ...optionsArgs,\n    lean: true,\n    new: true,\n    projection: buildProjectionFromSelect({\n      adapter: this,\n      fields: this.payload.collections[collection].config.flattenedFields,\n      select,\n    }),\n    session: await getSession(this, req),\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    collectionSlug: collection,\n    fields: this.payload.collections[collection].config.flattenedFields,\n    locale,\n    where,\n  })\n\n  let result\n\n  const sanitizedData = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data,\n    fields,\n  })\n\n  try {\n    result = await Model.findOneAndUpdate(query, sanitizedData, options)\n  } catch (error) {\n    handleError({ collection, error, req })\n  }\n\n  if (!result) {\n    return null\n  }\n\n  result = JSON.parse(JSON.stringify(result))\n  result.id = result._id\n  result = sanitizeInternalFields(result)\n\n  return result\n}\n"],"names":["buildQuery","buildProjectionFromSelect","getSession","handleError","sanitizeInternalFields","sanitizeRelationshipIDs","updateOne","id","collection","data","locale","options","optionsArgs","req","select","where","whereArg","equals","Model","collections","fields","payload","config","lean","new","projection","adapter","flattenedFields","session","query","collectionSlug","result","sanitizedData","findOneAndUpdate","error","JSON","parse","stringify","_id"],"mappings":";;;AAKA,SAASA,UAAU,QAAQ,0BAAyB;AACpD,SAASC,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,WAAW,QAAQ,6BAA4B;AACxD,SAASC,sBAAsB,QAAQ,wCAAuC;AAC9E,SAASC,uBAAuB,QAAQ,yCAAwC;;;;;;;AAEzE,MAAMC,YAAuB,eAAeA,UAEjD,EAAEC,EAAE,EAAEC,UAAU,EAAEC,IAAI,EAAEC,MAAM,EAAEC,SAASC,cAAc,CAAC,CAAC,EAAEC,GAAG,EAAEC,MAAM,EAAEC,OAAOC,QAAQ,EAAE;IAEzF,MAAMD,QAAQR,KAAK;QAAEA,IAAI;YAAEU,QAAQV;QAAG;IAAE,IAAIS;IAC5C,MAAME,QAAQ,IAAI,CAACC,WAAW,CAACX,WAAW;IAC1C,MAAMY,SAAS,IAAI,CAACC,OAAO,CAACF,WAAW,CAACX,WAAW,CAACc,MAAM,CAACF,MAAM;IACjE,MAAMT,UAAwB;QAC5B,GAAGC,WAAW;QACdW,MAAM;QACNC,KAAK;QACLC,kNAAYxB,4BAAAA,EAA0B;YACpCyB,SAAS,IAAI;YACbN,QAAQ,IAAI,CAACC,OAAO,CAACF,WAAW,CAACX,WAAW,CAACc,MAAM,CAACK,eAAe;YACnEb;QACF;QACAc,SAAS,6LAAM1B,aAAAA,EAAW,IAAI,EAAEW;IAClC;IAEA,MAAMgB,QAAQ,2LAAM7B,aAAAA,EAAW;QAC7B0B,SAAS,IAAI;QACbI,gBAAgBtB;QAChBY,QAAQ,IAAI,CAACC,OAAO,CAACF,WAAW,CAACX,WAAW,CAACc,MAAM,CAACK,eAAe;QACnEjB;QACAK;IACF;IAEA,IAAIgB;IAEJ,MAAMC,iBAAgB3B,6NAAAA,EAAwB;QAC5CiB,QAAQ,IAAI,CAACD,OAAO,CAACC,MAAM;QAC3Bb;QACAW;IACF;IAEA,IAAI;QACFW,SAAS,MAAMb,MAAMe,gBAAgB,CAACJ,OAAOG,eAAerB;IAC9D,EAAE,OAAOuB,OAAO;gMACd/B,cAAAA,EAAY;YAAEK;YAAY0B;YAAOrB;QAAI;IACvC;IAEA,IAAI,CAACkB,QAAQ;QACX,OAAO;IACT;IAEAA,SAASI,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACN;IACnCA,OAAOxB,EAAE,GAAGwB,OAAOO,GAAG;IACtBP,4MAAS3B,yBAAAA,EAAuB2B;IAEhC,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4235, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4241, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/updateVersion.ts"],"sourcesContent":["import type { QueryOptions } from 'mongoose'\n\nimport { buildVersionCollectionFields, type UpdateVersion } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nimport { buildQuery } from './queries/buildQuery.js'\nimport { buildProjectionFromSelect } from './utilities/buildProjectionFromSelect.js'\nimport { getSession } from './utilities/getSession.js'\nimport { sanitizeRelationshipIDs } from './utilities/sanitizeRelationshipIDs.js'\n\nexport const updateVersion: UpdateVersion = async function updateVersion(\n  this: MongooseAdapter,\n  { id, collection, locale, options: optionsArgs = {}, req, select, versionData, where },\n) {\n  const VersionModel = this.versions[collection]\n  const whereToUse = where || { id: { equals: id } }\n  const fields = buildVersionCollectionFields(\n    this.payload.config,\n    this.payload.collections[collection].config,\n  )\n\n  const flattenedFields = buildVersionCollectionFields(\n    this.payload.config,\n    this.payload.collections[collection].config,\n    true,\n  )\n\n  const options: QueryOptions = {\n    ...optionsArgs,\n    lean: true,\n    new: true,\n    projection: buildProjectionFromSelect({\n      adapter: this,\n      fields: flattenedFields,\n      select,\n    }),\n    session: await getSession(this, req),\n  }\n\n  const query = await buildQuery({\n    adapter: this,\n    fields: flattenedFields,\n    locale,\n    where: whereToUse,\n  })\n\n  const sanitizedData = sanitizeRelationshipIDs({\n    config: this.payload.config,\n    data: versionData,\n    fields,\n  })\n\n  const doc = await VersionModel.findOneAndUpdate(query, sanitizedData, options)\n\n  if (!doc) {\n    return null\n  }\n\n  const result = JSON.parse(JSON.stringify(doc))\n\n  const verificationToken = doc._verificationToken\n\n  // custom id type reset\n  result.id = result._id\n  if (verificationToken) {\n    result._verificationToken = verificationToken\n  }\n  return result\n}\n"],"names":["buildVersionCollectionFields","buildQuery","buildProjectionFromSelect","getSession","sanitizeRelationshipIDs","updateVersion","id","collection","locale","options","optionsArgs","req","select","versionData","where","VersionModel","versions","whereToUse","equals","fields","payload","config","collections","flattenedFields","lean","new","projection","adapter","session","query","sanitizedData","data","doc","findOneAndUpdate","result","JSON","parse","stringify","verificationToken","_verificationToken","_id"],"mappings":";;;AAMA,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,yBAAyB,QAAQ,2CAA0C;AACpF,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,uBAAuB,QAAQ,yCAAwC;AAPhF,SAASJ,4BAA4B,QAA4B,UAAS;;;;;;AASnE,MAAMK,gBAA+B,eAAeA,cAEzD,EAAEC,EAAE,EAAEC,UAAU,EAAEC,MAAM,EAAEC,SAASC,cAAc,CAAC,CAAC,EAAEC,GAAG,EAAEC,MAAM,EAAEC,WAAW,EAAEC,KAAK,EAAE;IAEtF,MAAMC,eAAe,IAAI,CAACC,QAAQ,CAACT,WAAW;IAC9C,MAAMU,aAAaH,SAAS;QAAER,IAAI;YAAEY,QAAQZ;QAAG;IAAE;IACjD,MAAMa,oLAASnB,+BAAAA,EACb,IAAI,CAACoB,OAAO,CAACC,MAAM,EACnB,IAAI,CAACD,OAAO,CAACE,WAAW,CAACf,WAAW,CAACc,MAAM;IAG7C,MAAME,6LAAkBvB,+BAAAA,EACtB,IAAI,CAACoB,OAAO,CAACC,MAAM,EACnB,IAAI,CAACD,OAAO,CAACE,WAAW,CAACf,WAAW,CAACc,MAAM,EAC3C;IAGF,MAAMZ,UAAwB;QAC5B,GAAGC,WAAW;QACdc,MAAM;QACNC,KAAK;QACLC,kNAAYxB,4BAAAA,EAA0B;YACpCyB,SAAS,IAAI;YACbR,QAAQI;YACRX;QACF;QACAgB,SAAS,6LAAMzB,aAAAA,EAAW,IAAI,EAAEQ;IAClC;IAEA,MAAMkB,QAAQ,2LAAM5B,aAAAA,EAAW;QAC7B0B,SAAS,IAAI;QACbR,QAAQI;QACRf;QACAM,OAAOG;IACT;IAEA,MAAMa,oNAAgB1B,0BAAAA,EAAwB;QAC5CiB,QAAQ,IAAI,CAACD,OAAO,CAACC,MAAM;QAC3BU,MAAMlB;QACNM;IACF;IAEA,MAAMa,MAAM,MAAMjB,aAAakB,gBAAgB,CAACJ,OAAOC,eAAerB;IAEtE,IAAI,CAACuB,KAAK;QACR,OAAO;IACT;IAEA,MAAME,SAASC,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACL;IAEzC,MAAMM,oBAAoBN,IAAIO,kBAAkB;IAEhD,uBAAuB;IACvBL,OAAO5B,EAAE,GAAG4B,OAAOM,GAAG;IACtB,IAAIF,mBAAmB;QACrBJ,OAAOK,kBAAkB,GAAGD;IAC9B;IACA,OAAOJ;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4298, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4304, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/upsert.ts"],"sourcesContent":["import type { Upsert } from 'payload'\n\nimport type { MongooseAdapter } from './index.js'\n\nexport const upsert: Upsert = async function upsert(\n  this: MongooseAdapter,\n  { collection, data, locale, req, select, where },\n) {\n  return this.updateOne({ collection, data, locale, options: { upsert: true }, req, select, where })\n}\n"],"names":["upsert","collection","data","locale","req","select","where","updateOne","options"],"mappings":";;;AAIO,MAAMA,SAAiB,eAAeA,OAE3C,EAAEC,UAAU,EAAEC,IAAI,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAEhD,OAAO,IAAI,CAACC,SAAS,CAAC;QAAEN;QAAYC;QAAMC;QAAQK,SAAS;YAAER,QAAQ;QAAK;QAAGI;QAAKC;QAAQC;IAAM;AAClG,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4320, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4326, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/%40payloadcms/db-mongodb/src/index.ts"],"sourcesContent":["import type { CollationOptions, TransactionOptions } from 'mongodb'\nimport type { MongoMemoryReplSet } from 'mongodb-memory-server'\nimport type {\n  ClientSession,\n  Connection,\n  ConnectOptions,\n  QueryOptions,\n  SchemaOptions,\n} from 'mongoose'\nimport type {\n  BaseDatabaseAdapter,\n  CollectionSlug,\n  DatabaseAdapterObj,\n  Payload,\n  TypeWithID,\n  TypeWithVersion,\n  UpdateGlobalArgs,\n  UpdateGlobalVersionArgs,\n  UpdateOneArgs,\n  UpdateVersionArgs,\n} from 'payload'\n\nimport fs from 'fs'\nimport mongoose from 'mongoose'\nimport path from 'path'\nimport { createDatabaseAdapter, defaultBeginTransaction } from 'payload'\n\nimport type { CollectionModel, GlobalModel, MigrateDownArgs, MigrateUpArgs } from './types.js'\n\nimport { connect } from './connect.js'\nimport { count } from './count.js'\nimport { countGlobalVersions } from './countGlobalVersions.js'\nimport { countVersions } from './countVersions.js'\nimport { create } from './create.js'\nimport { createGlobal } from './createGlobal.js'\nimport { createGlobalVersion } from './createGlobalVersion.js'\nimport { createMigration } from './createMigration.js'\nimport { createVersion } from './createVersion.js'\nimport { deleteMany } from './deleteMany.js'\nimport { deleteOne } from './deleteOne.js'\nimport { deleteVersions } from './deleteVersions.js'\nimport { destroy } from './destroy.js'\nimport { find } from './find.js'\nimport { findGlobal } from './findGlobal.js'\nimport { findGlobalVersions } from './findGlobalVersions.js'\nimport { findOne } from './findOne.js'\nimport { findVersions } from './findVersions.js'\nimport { init } from './init.js'\nimport { migrateFresh } from './migrateFresh.js'\nimport { queryDrafts } from './queryDrafts.js'\nimport { beginTransaction } from './transactions/beginTransaction.js'\nimport { commitTransaction } from './transactions/commitTransaction.js'\nimport { rollbackTransaction } from './transactions/rollbackTransaction.js'\nimport { updateGlobal } from './updateGlobal.js'\nimport { updateGlobalVersion } from './updateGlobalVersion.js'\nimport { updateOne } from './updateOne.js'\nimport { updateVersion } from './updateVersion.js'\nimport { upsert } from './upsert.js'\n\nexport type { MigrateDownArgs, MigrateUpArgs } from './types.js'\n\nexport interface Args {\n  /** Set to false to disable auto-pluralization of collection names, Defaults to true */\n  autoPluralization?: boolean\n  /**\n   * If enabled, collation allows for language-specific rules for string comparison.\n   * This configuration can include the following options:\n   *\n   * - `strength` (number): Comparison level (1: Primary, 2: Secondary, 3: Tertiary (default), 4: Quaternary, 5: Identical)\n   * - `caseLevel` (boolean): Include case comparison at strength level 1 or 2.\n   * - `caseFirst` (string): Sort order of case differences during tertiary level comparisons (\"upper\", \"lower\", \"off\").\n   * - `numericOrdering` (boolean): Compare numeric strings as numbers.\n   * - `alternate` (string): Consider whitespace and punctuation as base characters (\"non-ignorable\", \"shifted\").\n   * - `maxVariable` (string): Characters considered ignorable when `alternate` is \"shifted\" (\"punct\", \"space\").\n   * - `backwards` (boolean): Sort strings with diacritics from back of the string.\n   * - `normalization` (boolean): Check if text requires normalization and perform normalization.\n   *\n   * Available on MongoDB version 3.4 and up.\n   * The locale that gets passed is your current project's locale but defaults to \"en\".\n   *\n   * Example:\n   * {\n   *   strength: 3\n   * }\n   *\n   * Defaults to disabled.\n   */\n  collation?: Omit<CollationOptions, 'locale'>\n  collectionsSchemaOptions?: Partial<Record<CollectionSlug, SchemaOptions>>\n\n  /** Extra configuration options */\n  connectOptions?: {\n    /** Set false to disable $facet aggregation in non-supporting databases, Defaults to true */\n    useFacet?: boolean\n  } & ConnectOptions\n  /** Set to true to disable hinting to MongoDB to use 'id' as index. This is currently done when counting documents for pagination. Disabling this optimization might fix some problems with AWS DocumentDB. Defaults to false */\n  disableIndexHints?: boolean\n  /**\n   * Set to `true` to ensure that indexes are ready before completing connection.\n   * NOTE: not recommended for production. This can slow down the initialization of Payload.\n   */\n  ensureIndexes?: boolean\n  migrationDir?: string\n  /**\n   * typed as any to avoid dependency\n   */\n  mongoMemoryServer?: MongoMemoryReplSet\n  prodMigrations?: {\n    down: (args: MigrateDownArgs) => Promise<void>\n    name: string\n    up: (args: MigrateUpArgs) => Promise<void>\n  }[]\n  transactionOptions?: false | TransactionOptions\n\n  /** The URL to connect to MongoDB or false to start payload and prevent connecting */\n  url: false | string\n}\n\nexport type MongooseAdapter = {\n  collections: {\n    [slug: string]: CollectionModel\n  }\n  connection: Connection\n  ensureIndexes: boolean\n  globals: GlobalModel\n  mongoMemoryServer: MongoMemoryReplSet\n  prodMigrations?: {\n    down: (args: MigrateDownArgs) => Promise<void>\n    name: string\n    up: (args: MigrateUpArgs) => Promise<void>\n  }[]\n  sessions: Record<number | string, ClientSession>\n  versions: {\n    [slug: string]: CollectionModel\n  }\n} & Args &\n  BaseDatabaseAdapter\n\ndeclare module 'payload' {\n  export interface DatabaseAdapter\n    extends Omit<BaseDatabaseAdapter, 'sessions'>,\n      Omit<Args, 'migrationDir'> {\n    collections: {\n      [slug: string]: CollectionModel\n    }\n    connection: Connection\n    ensureIndexes: boolean\n    globals: GlobalModel\n    mongoMemoryServer: MongoMemoryReplSet\n    prodMigrations?: {\n      down: (args: MigrateDownArgs) => Promise<void>\n      name: string\n      up: (args: MigrateUpArgs) => Promise<void>\n    }[]\n    sessions: Record<number | string, ClientSession>\n    transactionOptions: TransactionOptions\n    updateGlobal: <T extends Record<string, unknown>>(\n      args: { options?: QueryOptions } & UpdateGlobalArgs<T>,\n    ) => Promise<T>\n    updateGlobalVersion: <T extends TypeWithID = TypeWithID>(\n      args: { options?: QueryOptions } & UpdateGlobalVersionArgs<T>,\n    ) => Promise<TypeWithVersion<T>>\n    updateOne: (args: { options?: QueryOptions } & UpdateOneArgs) => Promise<Document>\n    updateVersion: <T extends TypeWithID = TypeWithID>(\n      args: { options?: QueryOptions } & UpdateVersionArgs<T>,\n    ) => Promise<TypeWithVersion<T>>\n    versions: {\n      [slug: string]: CollectionModel\n    }\n  }\n}\n\nexport function mongooseAdapter({\n  autoPluralization = true,\n  collectionsSchemaOptions = {},\n  connectOptions,\n  disableIndexHints = false,\n  ensureIndexes,\n  migrationDir: migrationDirArg,\n  mongoMemoryServer,\n  prodMigrations,\n  transactionOptions = {},\n  url,\n}: Args): DatabaseAdapterObj {\n  function adapter({ payload }: { payload: Payload }) {\n    const migrationDir = findMigrationDir(migrationDirArg)\n    mongoose.set('strictQuery', false)\n\n    return createDatabaseAdapter<MongooseAdapter>({\n      name: 'mongoose',\n\n      // Mongoose-specific\n      autoPluralization,\n      collections: {},\n      connection: undefined,\n      connectOptions: connectOptions || {},\n      disableIndexHints,\n      ensureIndexes,\n      globals: undefined,\n      mongoMemoryServer,\n      sessions: {},\n      transactionOptions: transactionOptions === false ? undefined : transactionOptions,\n      url,\n      versions: {},\n      // DatabaseAdapter\n      beginTransaction: transactionOptions === false ? defaultBeginTransaction() : beginTransaction,\n      collectionsSchemaOptions,\n      commitTransaction,\n      connect,\n      count,\n      countGlobalVersions,\n      countVersions,\n      create,\n      createGlobal,\n      createGlobalVersion,\n      createMigration,\n      createVersion,\n      defaultIDType: 'text',\n      deleteMany,\n      deleteOne,\n      deleteVersions,\n      destroy,\n      find,\n      findGlobal,\n      findGlobalVersions,\n      findOne,\n      findVersions,\n      init,\n      migrateFresh,\n      migrationDir,\n      packageName: '@payloadcms/db-mongodb',\n      payload,\n      prodMigrations,\n      queryDrafts,\n      rollbackTransaction,\n      updateGlobal,\n      updateGlobalVersion,\n      updateOne,\n      updateVersion,\n      upsert,\n    })\n  }\n\n  return {\n    defaultIDType: 'text',\n    init: adapter,\n  }\n}\n\n/**\n * Attempt to find migrations directory.\n *\n * Checks for the following directories in order:\n * - `migrationDir` argument from Payload config\n * - `src/migrations`\n * - `dist/migrations`\n * - `migrations`\n *\n * Defaults to `src/migrations`\n *\n * @param migrationDir\n * @returns\n */\nfunction findMigrationDir(migrationDir?: string): string {\n  const cwd = process.cwd()\n  const srcDir = path.resolve(cwd, 'src/migrations')\n  const distDir = path.resolve(cwd, 'dist/migrations')\n  const relativeMigrations = path.resolve(cwd, 'migrations')\n\n  // Use arg if provided\n  if (migrationDir) {\n    return migrationDir\n  }\n\n  // Check other common locations\n  if (fs.existsSync(srcDir)) {\n    return srcDir\n  }\n\n  if (fs.existsSync(distDir)) {\n    return distDir\n  }\n\n  if (fs.existsSync(relativeMigrations)) {\n    return relativeMigrations\n  }\n\n  return srcDir\n}\n"],"names":["fs","mongoose","path","createDatabaseAdapter","defaultBeginTransaction","connect","count","countGlobalVersions","countVersions","create","createGlobal","createGlobalVersion","createMigration","createVersion","deleteMany","deleteOne","deleteVersions","destroy","find","findGlobal","findGlobalVersions","findOne","findVersions","init","migrateFresh","queryDrafts","beginTransaction","commitTransaction","rollbackTransaction","updateGlobal","updateGlobalVersion","updateOne","updateVersion","upsert","mongooseAdapter","autoPluralization","collectionsSchemaOptions","connectOptions","disableIndexHints","ensureIndexes","migrationDir","migrationDirArg","mongoMemoryServer","prodMigrations","transactionOptions","url","adapter","payload","findMigrationDir","set","name","collections","connection","undefined","globals","sessions","versions","defaultIDType","packageName","cwd","process","srcDir","resolve","distDir","relativeMigrations","existsSync"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4492, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}