{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/config/types.ts"],"sourcesContent":["// @ts-strict-ignore\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { EditorProps } from '@monaco-editor/react'\nimport type { JSONSchema4 } from 'json-schema'\nimport type { CSSProperties } from 'react'\nimport type { DeepUndefinable, MarkRequired } from 'ts-essentials'\n\nimport type {\n  JoinFieldClientProps,\n  JoinFieldErrorClientComponent,\n  JoinFieldErrorServerComponent,\n  JoinFieldLabelClientComponent,\n  JoinFieldLabelServerComponent,\n} from '../../admin/fields/Join.js'\nimport type { FieldClientComponent, FieldServerComponent } from '../../admin/forms/Field.js'\nimport type { RichTextAdapter, RichTextAdapterProvider } from '../../admin/RichText.js'\nimport type {\n  ArrayFieldClientProps,\n  ArrayFieldErrorClientComponent,\n  ArrayFieldErrorServerComponent,\n  ArrayFieldLabelClientComponent,\n  ArrayFieldLabelServerComponent,\n  BlocksFieldClientProps,\n  BlocksFieldErrorClientComponent,\n  BlocksFieldErrorServerComponent,\n  BlocksFieldLabelClientComponent,\n  BlocksFieldLabelServerComponent,\n  CheckboxFieldClientProps,\n  CheckboxFieldErrorClientComponent,\n  CheckboxFieldErrorServerComponent,\n  CheckboxFieldLabelClientComponent,\n  CheckboxFieldLabelServerComponent,\n  ClientTab,\n  CodeFieldClientProps,\n  CodeFieldErrorClientComponent,\n  CodeFieldErrorServerComponent,\n  CodeFieldLabelClientComponent,\n  CodeFieldLabelServerComponent,\n  CollapsibleFieldClientProps,\n  CollapsibleFieldLabelClientComponent,\n  CollapsibleFieldLabelServerComponent,\n  ConditionalDateProps,\n  DateFieldClientProps,\n  DateFieldErrorClientComponent,\n  DateFieldErrorServerComponent,\n  DateFieldLabelClientComponent,\n  DateFieldLabelServerComponent,\n  DefaultCellComponentProps,\n  DefaultServerCellComponentProps,\n  Description,\n  EmailFieldClientProps,\n  EmailFieldErrorClientComponent,\n  EmailFieldErrorServerComponent,\n  EmailFieldLabelClientComponent,\n  EmailFieldLabelServerComponent,\n  FieldDescriptionClientProps,\n  FieldDescriptionServerProps,\n  FieldDiffClientComponent,\n  FieldDiffServerProps,\n  GroupFieldClientProps,\n  GroupFieldLabelClientComponent,\n  GroupFieldLabelServerComponent,\n  HiddenFieldProps,\n  JSONFieldClientProps,\n  JSONFieldErrorClientComponent,\n  JSONFieldErrorServerComponent,\n  JSONFieldLabelClientComponent,\n  JSONFieldLabelServerComponent,\n  NumberFieldClientProps,\n  NumberFieldErrorClientComponent,\n  NumberFieldErrorServerComponent,\n  NumberFieldLabelClientComponent,\n  NumberFieldLabelServerComponent,\n  PointFieldClientProps,\n  PointFieldErrorClientComponent,\n  PointFieldErrorServerComponent,\n  PointFieldLabelClientComponent,\n  PointFieldLabelServerComponent,\n  RadioFieldClientProps,\n  RadioFieldErrorClientComponent,\n  RadioFieldErrorServerComponent,\n  RadioFieldLabelClientComponent,\n  RadioFieldLabelServerComponent,\n  RelationshipFieldClientProps,\n  RelationshipFieldErrorClientComponent,\n  RelationshipFieldErrorServerComponent,\n  RelationshipFieldLabelClientComponent,\n  RelationshipFieldLabelServerComponent,\n  RichTextFieldClientProps,\n  RowFieldClientProps,\n  RowLabelComponent,\n  SelectFieldClientProps,\n  SelectFieldErrorClientComponent,\n  SelectFieldErrorServerComponent,\n  SelectFieldLabelClientComponent,\n  SelectFieldLabelServerComponent,\n  StaticDescription,\n  TabsFieldClientProps,\n  TextareaFieldClientProps,\n  TextareaFieldErrorClientComponent,\n  TextareaFieldErrorServerComponent,\n  TextareaFieldLabelClientComponent,\n  TextareaFieldLabelServerComponent,\n  TextFieldClientProps,\n  TextFieldErrorClientComponent,\n  TextFieldErrorServerComponent,\n  TextFieldLabelClientComponent,\n  TextFieldLabelServerComponent,\n  UploadFieldClientProps,\n} from '../../admin/types.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../collections/config/types.js'\nimport type {\n  CustomComponent,\n  LabelFunction,\n  PayloadComponent,\n  StaticLabel,\n} from '../../config/types.js'\nimport type { DBIdentifierName } from '../../database/types.js'\nimport type { SanitizedGlobalConfig } from '../../globals/config/types.js'\nimport type {\n  ArrayFieldValidation,\n  BlocksFieldValidation,\n  BlockSlug,\n  CheckboxFieldValidation,\n  CodeFieldValidation,\n  CollectionSlug,\n  DateFieldValidation,\n  EmailFieldValidation,\n  JSONFieldValidation,\n  PointFieldValidation,\n  RadioFieldValidation,\n  RequestContext,\n  Sort,\n  TextareaFieldValidation,\n} from '../../index.js'\nimport type { DocumentPreferences } from '../../preferences/types.js'\nimport type {\n  DefaultValue,\n  JsonObject,\n  Operation,\n  PayloadRequest,\n  Where,\n} from '../../types/index.js'\nimport type {\n  NumberFieldManyValidation,\n  NumberFieldSingleValidation,\n  RelationshipFieldManyValidation,\n  RelationshipFieldSingleValidation,\n  SelectFieldManyValidation,\n  SelectFieldSingleValidation,\n  TextFieldManyValidation,\n  TextFieldSingleValidation,\n  UploadFieldManyValidation,\n  UploadFieldSingleValidation,\n} from '../validations.js'\n\nexport type FieldHookArgs<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData: JsonObject | undefined\n  /** The collection which the field belongs to. If the field belongs to a global, this will be null. */\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * Only available in `afterRead` hooks\n   */\n  currentDepth?: number\n  /**\n   * Only available in `afterRead` hooks\n   */\n  /** The data passed to update the document within create and update operations, and the full document itself in the afterRead hook. */\n  data?: Partial<TData>\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  depth?: number\n  draft?: boolean\n  /** The field which the hook is running against. */\n  field: FieldAffectingData\n  /** Boolean to denote if this hook is running against finding one, or finding many within the afterRead hook. */\n  findMany?: boolean\n  /** The global which the field belongs to. If the field belongs to a collection, this will be null. */\n  global: null | SanitizedGlobalConfig\n  indexPath: number[]\n  /** A string relating to which operation the field type is currently executing within. Useful within beforeValidate, beforeChange, and afterChange hooks to differentiate between create and update operations. */\n  operation?: 'create' | 'delete' | 'read' | 'update'\n  /** The full original document in `update` operations. In the `afterChange` hook, this is the resulting document of the operation. */\n  originalDoc?: TData\n  overrideAccess?: boolean\n  /**\n   * The path of the field, e.g. [\"group\", \"myArray\", 1, \"textField\"]. The path is the schemaPath but with indexes and would be used in the context of field data, not field schemas.\n   */\n  path: (number | string)[]\n  /** The document before changes were applied, only in `afterChange` hooks. */\n  previousDoc?: TData\n  /** The sibling data of the document before changes being applied, only in `beforeChange`, `beforeValidate`, `beforeDuplicate` and `afterChange` field hooks. */\n  previousSiblingDoc?: TData\n  /** The previous value of the field, before changes, only in `beforeChange`, `afterChange`, `beforeDuplicate` and `beforeValidate` field hooks. */\n  previousValue?: TValue\n  /** The Express request object. It is mocked for Local API operations. */\n  req: PayloadRequest\n  /**\n   * The schemaPath of the field, e.g. [\"group\", \"myArray\", \"textField\"]. The schemaPath is the path but without indexes and would be used in the context of field schemas, not field data.\n   */\n  schemaPath: string[]\n  /**\n   * Only available in the `afterRead` hook.\n   */\n  showHiddenFields?: boolean\n  /** The sibling data passed to a field that the hook is running against. */\n  siblingData: Partial<TSiblingData>\n  /**\n   * The original siblingData with locales (not modified by any hooks). Only available in `beforeChange` and `beforeDuplicate` field hooks.\n   */\n  siblingDocWithLocales?: Record<string, unknown>\n  /**\n   * The sibling fields of the field which the hook is running against.\n   */\n  siblingFields: (Field | TabAsField)[]\n  /** The value of the field. */\n  value?: TValue\n}\n\nexport type FieldHook<TData extends TypeWithID = any, TValue = any, TSiblingData = any> = (\n  args: FieldHookArgs<TData, TValue, TSiblingData>,\n) => Promise<TValue> | TValue\n\nexport type FieldAccess<TData extends TypeWithID = any, TSiblingData = any> = (args: {\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData?: JsonObject | undefined\n  /**\n   * The incoming, top-level document data used to `create` or `update` the document with.\n   */\n  data?: Partial<TData>\n  /**\n   * The original data of the document before the `update` is applied. `doc` is undefined during the `create` operation.\n   */\n  doc?: TData\n  /**\n   * The `id` of the current document being read or updated. `id` is undefined during the `create` operation.\n   */\n  id?: number | string\n  /** The `payload` object to interface with the payload API */\n  req: PayloadRequest\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData?: Partial<TSiblingData>\n}) => boolean | Promise<boolean>\n\n//TODO: In 4.0, we should replace the three parameters of the condition function with a single, named parameter object\nexport type Condition<TData extends TypeWithID = any, TSiblingData = any> = (\n  /**\n   * The top-level document data\n   */\n  data: Partial<TData>,\n  /**\n   * Immediately adjacent data to this field. For example, if this is a `group` field, then `siblingData` will be the other fields within the group.\n   */\n  siblingData: Partial<TSiblingData>,\n  {\n    blockData,\n    user,\n  }: {\n    /**\n     * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n     */\n    blockData: Partial<TData>\n    user: PayloadRequest['user']\n  },\n) => boolean\n\nexport type FilterOptionsProps<TData = any> = {\n  /**\n   * The data of the nearest parent block. Will be `undefined` if the field is not within a block or when called on a `Filter` component within the list view.\n   */\n  blockData: TData\n  /**\n   * An object containing the full collection or global document currently being edited. Will be an empty object when called on a `Filter` component within the list view.\n   */\n  data: TData\n  /**\n   * The `id` of the current document being edited. Will be undefined during the `create` operation or when called on a `Filter` component within the list view.\n   */\n  id: number | string\n  /**\n   * The collection `slug` to filter against, limited to this field's `relationTo` property.\n   */\n  relationTo: CollectionSlug\n  req: PayloadRequest\n  /**\n   * An object containing document data that is scoped to only fields within the same parent of this field. Will be an empty object when called on a `Filter` component within the list view.\n   */\n  siblingData: unknown\n  /**\n   * An object containing the currently authenticated user.\n   */\n  user: Partial<PayloadRequest['user']>\n}\n\nexport type FilterOptionsFunc<TData = any> = (\n  options: FilterOptionsProps<TData>,\n) => boolean | Promise<boolean | Where> | Where\n\nexport type FilterOptions<TData = any> =\n  | ((options: FilterOptionsProps<TData>) => boolean | Promise<boolean | Where> | Where)\n  | null\n  | Where\n\ntype Admin = {\n  className?: string\n  components?: {\n    Cell?: PayloadComponent<DefaultServerCellComponentProps, DefaultCellComponentProps>\n    Description?: PayloadComponent<FieldDescriptionServerProps, FieldDescriptionClientProps>\n    Diff?: PayloadComponent<FieldDiffServerProps, FieldDiffClientComponent>\n    Field?: PayloadComponent<FieldClientComponent | FieldServerComponent>\n    /**\n     * The Filter component has to be a client component\n     */\n    Filter?: PayloadComponent\n  }\n  /**\n   * You can programmatically show / hide fields based on what other fields are doing.\n   * This is also run on the server, to determine if the field should be validated.\n   */\n  condition?: Condition\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  /**\n   * The field description will be displayed next to the field in the admin UI. Additionally,\n   * we use the field description to generate JSDoc comments for the generated TypeScript types.\n   */\n  description?: Description\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type AdminClient = {\n  className?: string\n  /** Extension point to add your custom data. Available in server and client. */\n  custom?: Record<string, any>\n  description?: StaticDescription\n  disableBulkEdit?: boolean\n  disabled?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view column selector.\n   * @type boolean\n   */\n  disableListColumn?: boolean\n  /**\n   * Shows / hides fields from appearing in the list view filter options.\n   * @type boolean\n   */\n  disableListFilter?: boolean\n  hidden?: boolean\n  position?: 'sidebar'\n  readOnly?: boolean\n  style?: { '--field-width'?: CSSProperties['width'] } & CSSProperties\n  width?: CSSProperties['width']\n}\n\nexport type Labels = {\n  plural: LabelFunction | StaticLabel\n  singular: LabelFunction | StaticLabel\n}\n\nexport type LabelsClient = {\n  plural: StaticLabel\n  singular: StaticLabel\n}\n\nexport type BaseValidateOptions<TData, TSiblingData, TValue> = {\n  /**\n  /**\n   * The data of the nearest parent block. If the field is not within a block, `blockData` will be equal to `undefined`.\n   */\n  blockData: Partial<TData>\n  collectionSlug?: string\n  data: Partial<TData>\n  event?: 'onChange' | 'submit'\n  id?: number | string\n  operation?: Operation\n  preferences: DocumentPreferences\n  previousValue?: TValue\n  req: PayloadRequest\n  required?: boolean\n  siblingData: Partial<TSiblingData>\n}\n\nexport type ValidateOptions<\n  TData,\n  TSiblingData,\n  TFieldConfig extends object,\n  TValue,\n> = BaseValidateOptions<TData, TSiblingData, TValue> & TFieldConfig\n\nexport type Validate<\n  TValue = any,\n  TData = any,\n  TSiblingData = any,\n  TFieldConfig extends object = object,\n> = (\n  value: null | TValue | undefined,\n  options: ValidateOptions<TData, TSiblingData, TFieldConfig, TValue>,\n) => Promise<string | true> | string | true\n\nexport type OptionObject = {\n  label: LabelFunction | StaticLabel\n  value: string\n}\n\nexport type Option = OptionObject | string\n\nexport type FieldGraphQLType = {\n  graphQL?: {\n    /**\n     * Complexity for the query. This is used to limit the complexity of the join query.\n     *\n     * @default 10\n     */\n    complexity?: number\n  }\n}\n\nexport interface FieldBase {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same field multiple times.\n   */\n  _sanitized?: boolean\n  access?: {\n    create?: FieldAccess\n    read?: FieldAccess\n    update?: FieldAccess\n  }\n  admin?: Admin\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  defaultValue?: DefaultValue\n  hidden?: boolean\n  hooks?: {\n    afterChange?: FieldHook[]\n    afterRead?: FieldHook[]\n    beforeChange?: FieldHook[]\n    /**\n     * Runs before a document is duplicated to prevent errors in unique fields or return null to use defaultValue.\n     */\n    beforeDuplicate?: FieldHook[]\n    beforeValidate?: FieldHook[]\n  }\n  index?: boolean\n  label?: false | LabelFunction | StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n  validate?: Validate\n  /**\n   * Pass `true` to disable field in the DB\n   * for [Virtual Fields](https://payloadcms.com/blog/learn-how-virtual-fields-can-help-solve-common-cms-challenges):\n   * A virtual field cannot be used in `admin.useAsTitle`\n   */\n  virtual?: boolean\n}\n\nexport interface FieldBaseClient {\n  admin?: AdminClient\n  hidden?: boolean\n  index?: boolean\n  label?: StaticLabel\n  localized?: boolean\n  /**\n   * The name of the field. Must be alphanumeric and cannot contain ' . '\n   *\n   * Must not be one of reserved field names: ['__v', 'salt', 'hash', 'file']\n   * @link https://payloadcms.com/docs/fields/overview#field-names\n   */\n  name: string\n  required?: boolean\n  saveToJWT?: boolean | string\n  /**\n   * Allows you to modify the base JSON schema that is generated during generate:types for this field.\n   * This JSON schema will be used to generate the TypeScript interface of this field.\n   */\n  typescriptSchema?: Array<(args: { jsonSchema: JSONSchema4 }) => JSONSchema4>\n  unique?: boolean\n}\n\nexport type NumberField = {\n  admin?: {\n    /** Set this property to a string that will be used for browser autocomplete. */\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<NumberFieldErrorClientComponent | NumberFieldErrorServerComponent>\n      Label?: CustomComponent<NumberFieldLabelClientComponent | NumberFieldLabelServerComponent>\n    } & Admin['components']\n    /** Set this property to define a placeholder string for the field. */\n    placeholder?: Record<string, string> | string\n    /** Set a value for the number field to increment / decrement using browser controls. */\n    step?: number\n  } & Admin\n  /** Maximum value accepted. Used in the default `validate` function. */\n  max?: number\n  /** Minimum value accepted. Used in the default `validate` function. */\n  min?: number\n  type: 'number'\n} & (\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany: true\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: NumberFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of numbers instead of just a single number. */\n      hasMany?: false | undefined\n      /** Maximum number of numbers in the numbers array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of numbers in the numbers array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: NumberFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type NumberFieldClient = {\n  admin?: AdminClient & Pick<NumberField['admin'], 'autoComplete' | 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<NumberField, 'hasMany' | 'max' | 'maxRows' | 'min' | 'minRows' | 'type'>\n\nexport type TextField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextFieldErrorClientComponent | TextFieldErrorServerComponent>\n      Label?: CustomComponent<TextFieldLabelClientComponent | TextFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'text'\n} & (\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany: true\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: number\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: number\n      validate?: TextFieldManyValidation\n    }\n  | {\n      /** Makes this field an ordered array of strings instead of just a single string. */\n      hasMany?: false | undefined\n      /** Maximum number of strings in the strings array, if `hasMany` is set to true. */\n      maxRows?: undefined\n      /** Minimum number of strings in the strings array, if `hasMany` is set to true. */\n      minRows?: undefined\n      validate?: TextFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type TextFieldClient = {\n  admin?: AdminClient & Pick<TextField['admin'], 'autoComplete' | 'placeholder' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextField, 'hasMany' | 'maxLength' | 'maxRows' | 'minLength' | 'minRows' | 'type'>\n\nexport type EmailField = {\n  admin?: {\n    autoComplete?: string\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<EmailFieldErrorClientComponent | EmailFieldErrorServerComponent>\n      Label?: CustomComponent<EmailFieldLabelClientComponent | EmailFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n  } & Admin\n  type: 'email'\n  validate?: EmailFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type EmailFieldClient = {\n  admin?: AdminClient & Pick<EmailField['admin'], 'autoComplete' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<EmailField, 'type'>\n\nexport type TextareaField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<TextareaFieldErrorClientComponent | TextareaFieldErrorServerComponent>\n      Label?: CustomComponent<TextareaFieldLabelClientComponent | TextareaFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    rows?: number\n    rtl?: boolean\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'textarea'\n  validate?: TextareaFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type TextareaFieldClient = {\n  admin?: AdminClient & Pick<TextareaField['admin'], 'placeholder' | 'rows' | 'rtl'>\n} & FieldBaseClient &\n  Pick<TextareaField, 'maxLength' | 'minLength' | 'type'>\n\nexport type CheckboxField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CheckboxFieldErrorClientComponent | CheckboxFieldErrorServerComponent>\n      Label?: CustomComponent<CheckboxFieldLabelClientComponent | CheckboxFieldLabelServerComponent>\n    } & Admin['components']\n  } & Admin\n  type: 'checkbox'\n  validate?: CheckboxFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type CheckboxFieldClient = {\n  admin?: AdminClient\n} & FieldBaseClient &\n  Pick<CheckboxField, 'type'>\n\nexport type DateField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<DateFieldErrorClientComponent | DateFieldErrorServerComponent>\n      Label?: CustomComponent<DateFieldLabelClientComponent | DateFieldLabelServerComponent>\n    } & Admin['components']\n    date?: ConditionalDateProps\n    placeholder?: Record<string, string> | string\n  } & Admin\n  /**\n   * Enable timezone selection in the admin interface.\n   */\n  timezone?: true\n  type: 'date'\n  validate?: DateFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type DateFieldClient = {\n  admin?: AdminClient & Pick<DateField['admin'], 'date' | 'placeholder'>\n} & FieldBaseClient &\n  Pick<DateField, 'timezone' | 'type'>\n\nexport type GroupField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Label?: CustomComponent<GroupFieldLabelClientComponent | GroupFieldLabelServerComponent>\n    } & Admin['components']\n    hideGutter?: boolean\n  } & Admin\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  type: 'group'\n  validate?: Validate<unknown, unknown, unknown, GroupField>\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type GroupFieldClient = {\n  admin?: AdminClient & Pick<GroupField['admin'], 'hideGutter'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'required'> &\n  Pick<GroupField, 'interfaceName' | 'type'>\n\nexport type RowField = {\n  admin?: Omit<Admin, 'description'>\n  fields: Field[]\n  type: 'row'\n} & Omit<FieldBase, 'admin' | 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type RowFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  fields: ClientField[]\n} & Omit<FieldBaseClient, 'admin' | 'label' | 'name'> &\n  Pick<RowField, 'type'>\n\nexport type CollapsibleField = {\n  fields: Field[]\n  type: 'collapsible'\n} & (\n  | {\n      admin: {\n        components: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label?: Required<FieldBase['label']>\n    }\n  | {\n      admin?: {\n        components?: {\n          afterInput?: CustomComponent[]\n          beforeInput?: CustomComponent[]\n          Label?: CustomComponent<\n            CollapsibleFieldLabelClientComponent | CollapsibleFieldLabelServerComponent\n          >\n        } & Admin['components']\n        initCollapsed?: boolean\n      } & Admin\n      label: Required<FieldBase['label']>\n    }\n) &\n  Omit<FieldBase, 'label' | 'localized' | 'name' | 'validate' | 'virtual'>\n\nexport type CollapsibleFieldClient = {\n  admin?: {\n    initCollapsed?: boolean\n  } & AdminClient\n  fields: ClientField[]\n  label: StaticLabel\n} & Omit<FieldBaseClient, 'label' | 'name' | 'validate'> &\n  Pick<CollapsibleField, 'type'>\n\ntype TabBase = {\n  /**\n   * @deprecated\n   * Use `admin.description` instead. This will be removed in a future major version.\n   */\n  description?: LabelFunction | StaticDescription\n  fields: Field[]\n  interfaceName?: string\n  saveToJWT?: boolean | string\n} & Omit<FieldBase, 'required' | 'validate'>\n\nexport type NamedTab = {\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n} & TabBase\n\nexport type UnnamedTab = {\n  interfaceName?: never\n  /**\n   * Can be either:\n   * - A string, which will be used as the tab's label.\n   * - An object, where the key is the language code and the value is the label.\n   */\n  label:\n    | {\n        [selectedLanguage: string]: string\n      }\n    | LabelFunction\n    | string\n  localized?: never\n} & Omit<TabBase, 'name' | 'virtual'>\n\nexport type Tab = NamedTab | UnnamedTab\n\nexport type TabsField = {\n  admin?: Omit<Admin, 'description'>\n  tabs: Tab[]\n  type: 'tabs'\n} & Omit<FieldBase, 'admin' | 'localized' | 'name' | 'saveToJWT' | 'virtual'>\n\nexport type TabsFieldClient = {\n  admin?: Omit<AdminClient, 'description'>\n  tabs: ClientTab[]\n} & Omit<FieldBaseClient, 'admin' | 'localized' | 'name' | 'saveToJWT'> &\n  Pick<TabsField, 'type'>\n\nexport type TabAsField = {\n  name?: string\n  type: 'tab'\n} & Tab\n\nexport type TabAsFieldClient = ClientTab & Pick<TabAsField, 'name' | 'type'>\n\nexport type UIField = {\n  admin: {\n    components?: {\n      /**\n       * Allow any custom components to be added to the UI field. This allows\n       * the UI field to be used as a vessel for getting components rendered.\n       */\n      [key: string]: PayloadComponent | undefined\n      Cell?: CustomComponent\n      // Can be optional, in case the UI field is just used as a vessel for custom components\n      Field?: CustomComponent\n      /**\n       * The Filter component has to be a client component\n       */\n      Filter?: PayloadComponent\n    } & Admin['components']\n    condition?: Condition\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    /**\n     * Set `false` make the UI field appear in the list view column selector. `true` by default for UI fields.\n     * @default true\n     */\n    disableBulkEdit?: boolean\n    /**\n     * Shows / hides fields from appearing in the list view column selector.\n     * @type boolean\n     */\n    disableListColumn?: boolean\n    position?: string\n    width?: CSSProperties['width']\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  label?: Record<string, string> | string\n  name: string\n  type: 'ui'\n}\n\nexport type UIFieldClient = {\n  // still include FieldBaseClient.admin (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n\n  admin: DeepUndefinable<FieldBaseClient['admin']> &\n    Pick<\n      UIField['admin'],\n      'custom' | 'disableBulkEdit' | 'disableListColumn' | 'position' | 'width'\n    >\n} & Omit<DeepUndefinable<FieldBaseClient>, 'admin'> & // still include FieldBaseClient (even if it's undefinable) so that we don't need constant type checks (e.g. if('xy' in field))\n  Pick<UIField, 'label' | 'name' | 'type'>\n\ntype SharedUploadProperties = {\n  /**\n   * Toggle the preview in the admin interface.\n   */\n  displayPreview?: boolean\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'upload'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: UploadFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: UploadFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedUploadPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedUploadProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype UploadAdmin = {\n  allowCreate?: boolean\n  components?: {\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\n\ntype UploadAdminClient = AdminClient & Pick<UploadAdmin, 'allowCreate' | 'isSortable'>\n\nexport type PolymorphicUploadField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & UploadAdmin\n  relationTo: CollectionSlug[]\n} & SharedUploadProperties\n\nexport type PolymorphicUploadFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicUploadField['admin'], 'sortOptions'>\n  } & UploadAdminClient\n} & Pick<PolymorphicUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type SingleUploadField = {\n  admin?: {\n    sortOptions?: string\n  } & UploadAdmin\n  relationTo: CollectionSlug\n} & SharedUploadProperties\n\nexport type SingleUploadFieldClient = {\n  admin?: Pick<SingleUploadField['admin'], 'sortOptions'> & UploadAdminClient\n} & Pick<SingleUploadField, 'displayPreview' | 'maxDepth' | 'relationTo' | 'type'> &\n  SharedUploadPropertiesClient\n\nexport type UploadField = /* PolymorphicUploadField | */ SingleUploadField\n\nexport type UploadFieldClient = /* PolymorphicUploadFieldClient | */ SingleUploadFieldClient\n\nexport type CodeField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<CodeFieldErrorClientComponent | CodeFieldErrorServerComponent>\n      Label?: CustomComponent<CodeFieldLabelClientComponent | CodeFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n    language?: string\n  } & Admin\n  maxLength?: number\n  minLength?: number\n  type: 'code'\n  validate?: CodeFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type CodeFieldClient = {\n  admin?: AdminClient & Pick<CodeField['admin'], 'editorOptions' | 'language'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<CodeField, 'maxLength' | 'minLength' | 'type'>\n\nexport type JSONField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JSONFieldErrorClientComponent | JSONFieldErrorServerComponent>\n      Label?: CustomComponent<JSONFieldLabelClientComponent | JSONFieldLabelServerComponent>\n    } & Admin['components']\n    editorOptions?: EditorProps['options']\n    maxHeight?: number\n  } & Admin\n\n  jsonSchema?: {\n    fileMatch: string[]\n    schema: JSONSchema4\n    uri: string\n  }\n  type: 'json'\n  validate?: JSONFieldValidation\n} & Omit<FieldBase, 'admin' | 'validate'>\n\nexport type JSONFieldClient = {\n  admin?: AdminClient & Pick<JSONField['admin'], 'editorOptions' | 'maxHeight'>\n} & Omit<FieldBaseClient, 'admin'> &\n  Pick<JSONField, 'jsonSchema' | 'type'>\n\nexport type SelectField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<SelectFieldErrorClientComponent | SelectFieldErrorServerComponent>\n      Label?: CustomComponent<SelectFieldLabelClientComponent | SelectFieldLabelServerComponent>\n    } & Admin['components']\n    isClearable?: boolean\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  hasMany?: boolean\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  options: Option[]\n  type: 'select'\n} & (\n  | {\n      hasMany: true\n      validate?: SelectFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      validate?: SelectFieldSingleValidation\n    }\n) &\n  Omit<FieldBase, 'validate'>\n\nexport type SelectFieldClient = {\n  admin?: AdminClient & Pick<SelectField['admin'], 'isClearable' | 'isSortable'>\n} & FieldBaseClient &\n  Pick<SelectField, 'hasMany' | 'interfaceName' | 'options' | 'type'>\n\ntype SharedRelationshipProperties = {\n  filterOptions?: FilterOptions\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'relationship'\n} & (\n  | {\n      hasMany: true\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: number\n      maxRows?: number\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: number\n      minRows?: number\n      validate?: RelationshipFieldManyValidation\n    }\n  | {\n      hasMany?: false | undefined\n      /**\n       * @deprecated Use 'maxRows' instead\n       */\n      max?: undefined\n      maxRows?: undefined\n      /**\n       * @deprecated Use 'minRows' instead\n       */\n      min?: undefined\n      minRows?: undefined\n      validate?: RelationshipFieldSingleValidation\n    }\n) &\n  FieldGraphQLType &\n  Omit<FieldBase, 'validate'>\n\ntype SharedRelationshipPropertiesClient = FieldBaseClient &\n  Pick<\n    SharedRelationshipProperties,\n    'hasMany' | 'max' | 'maxDepth' | 'maxRows' | 'min' | 'minRows' | 'type'\n  >\n\ntype RelationshipAdmin = {\n  allowCreate?: boolean\n  allowEdit?: boolean\n  components?: {\n    afterInput?: CustomComponent[]\n    beforeInput?: CustomComponent[]\n    Error?: CustomComponent<\n      RelationshipFieldErrorClientComponent | RelationshipFieldErrorServerComponent\n    >\n    Label?: CustomComponent<\n      RelationshipFieldLabelClientComponent | RelationshipFieldLabelServerComponent\n    >\n  } & Admin['components']\n  isSortable?: boolean\n} & Admin\n\ntype RelationshipAdminClient = AdminClient &\n  Pick<RelationshipAdmin, 'allowCreate' | 'allowEdit' | 'isSortable'>\n\nexport type PolymorphicRelationshipField = {\n  admin?: {\n    sortOptions?: Partial<Record<CollectionSlug, string>>\n  } & RelationshipAdmin\n  relationTo: CollectionSlug[]\n} & SharedRelationshipProperties\n\nexport type PolymorphicRelationshipFieldClient = {\n  admin?: {\n    sortOptions?: Pick<PolymorphicRelationshipField['admin'], 'sortOptions'>\n  } & RelationshipAdminClient\n} & Pick<PolymorphicRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type SingleRelationshipField = {\n  admin?: {\n    sortOptions?: string\n  } & RelationshipAdmin\n  relationTo: CollectionSlug\n} & SharedRelationshipProperties\n\nexport type SingleRelationshipFieldClient = {\n  admin?: Partial<Pick<SingleRelationshipField['admin'], 'sortOptions'>> & RelationshipAdminClient\n} & Pick<SingleRelationshipField, 'relationTo'> &\n  SharedRelationshipPropertiesClient\n\nexport type RelationshipField = PolymorphicRelationshipField | SingleRelationshipField\n\nexport type RelationshipFieldClient =\n  | PolymorphicRelationshipFieldClient\n  | SingleRelationshipFieldClient\n\nexport type ValueWithRelation = {\n  relationTo: CollectionSlug\n  value: number | string\n}\n\nexport function valueIsValueWithRelation(value: unknown): value is ValueWithRelation {\n  return value !== null && typeof value === 'object' && 'relationTo' in value && 'value' in value\n}\n\nexport type RelationshipValue = RelationshipValueMany | RelationshipValueSingle\n\nexport type RelationshipValueMany = (number | string)[] | ValueWithRelation[]\n\nexport type RelationshipValueSingle = number | string | ValueWithRelation\n\nexport type RichTextField<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = {\n  admin?: {\n    components?: {\n      Error?: CustomComponent\n      Label?: CustomComponent\n    } & Admin['components']\n  } & Admin\n  editor?:\n    | RichTextAdapter<TValue, TAdapterProps, TExtraProperties>\n    | RichTextAdapterProvider<TValue, TAdapterProps, TExtraProperties>\n  /**\n   * Sets a maximum population depth for this field, regardless of the remaining depth when this field is reached.\n   *\n   * {@link https://payloadcms.com/docs/getting-started/concepts#field-level-max-depth}\n   */\n  maxDepth?: number\n  type: 'richText'\n} & FieldBase &\n  TExtraProperties\n\nexport type RichTextFieldClient<\n  TValue extends object = any,\n  TAdapterProps = any,\n  TExtraProperties = object,\n> = FieldBaseClient &\n  Pick<RichTextField<TValue, TAdapterProps, TExtraProperties>, 'maxDepth' | 'type'> &\n  TExtraProperties\n\nexport type ArrayField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<ArrayFieldErrorClientComponent | ArrayFieldErrorServerComponent>\n      Label?: CustomComponent<ArrayFieldLabelClientComponent | ArrayFieldLabelServerComponent>\n      RowLabel?: RowLabelComponent\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'array'\n  validate?: ArrayFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type ArrayFieldClient = {\n  admin?: AdminClient & Pick<ArrayField['admin'], 'initCollapsed' | 'isSortable'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<ArrayField, 'interfaceName' | 'maxRows' | 'minRows' | 'type'>\n\nexport type RadioField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<RadioFieldErrorClientComponent | RadioFieldErrorServerComponent>\n      Label?: CustomComponent<RadioFieldLabelClientComponent | RadioFieldLabelServerComponent>\n    } & Admin['components']\n    layout?: 'horizontal' | 'vertical'\n  } & Admin\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  /**\n   * Customize the DB enum name\n   */\n  enumName?: DBIdentifierName\n  /** Customize generated GraphQL and Typescript schema names.\n   * By default, it is bound to the collection.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  options: Option[]\n  type: 'radio'\n  validate?: RadioFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type RadioFieldClient = {\n  admin?: AdminClient & Pick<RadioField['admin'], 'layout'>\n} & FieldBaseClient &\n  Pick<RadioField, 'interfaceName' | 'options' | 'type'>\n\ntype BlockFields = {\n  [key: string]: any\n  blockName?: string\n  blockType?: string\n}\n\nexport type BlockJSX = {\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere\n   */\n  customEndRegex?:\n    | {\n        /**\n         * Whether the end match is optional. If true, the end match is\n         * not required to match for the transformer to be triggered.\n         * The entire text from regexpStart to the end of the document will then be matched.\n         */\n        optional?: true\n        regExp: RegExp\n      }\n    | RegExp\n  /**\n   * Override the default regex used to search for the start of the block in the JSX.\n   * By default, it's <BlockSlugHere/>\n   */\n  customStartRegex?: RegExp\n  /**\n   * By default, all spaces at the beginning and end of every line of the\n   * children (text between the open and close match) are removed.\n   * Set this to true to disable this behavior.\n   */\n  doNotTrimChildren?: boolean\n  /**\n   * Function that receives the data for a given block and returns a JSX representation of it.\n   *\n   * This is used to convert Lexical => JSX\n   */\n  export: (props: {\n    fields: BlockFields\n    lexicalToMarkdown?: (props: { editorState: Record<string, any> }) => string\n  }) =>\n    | {\n        children?: string\n        props?: object\n      }\n    | false\n    | string\n  /**\n   * Function that receives the markdown string and parsed\n   * JSX props for a given matched block and returns a Lexical representation of it.\n   *\n   * This is used to convert JSX => Lexical\n   */\n  import: (props: {\n    children: string\n    closeMatch: null | RegExpMatchArray // Only available when customEndRegex is set\n    htmlToLexical?: ((props: { html: string }) => any) | null\n    markdownToLexical?: (props: { markdown: string }) => Record<string, any>\n    openMatch?: RegExpMatchArray\n    props: Record<string, any>\n  }) => BlockFields | false\n}\n\nexport type Block = {\n  /**\n   * Do not set this property manually. This is set to true during sanitization, to avoid\n   * sanitizing the same block multiple times.\n   */\n  _sanitized?: boolean\n  admin?: {\n    components?: {\n      /**\n       * This will replace the entire block component, including the block header / collapsible.\n       */\n      Block?: PayloadComponent<any, any>\n      Label?: PayloadComponent<any, any>\n    }\n    /** Extension point to add your custom data. Available in server and client. */\n    custom?: Record<string, any>\n    jsx?: PayloadComponent\n  }\n  /** Extension point to add your custom data. Server only. */\n  custom?: Record<string, any>\n  /**\n   * Customize the SQL table name\n   */\n  dbName?: DBIdentifierName\n  fields: Field[]\n  /** @deprecated - please migrate to the interfaceName property instead. */\n  graphQL?: {\n    singularName?: string\n  }\n  imageAltText?: string\n  imageURL?: string\n  /** Customize generated GraphQL and Typescript schema names.\n   * The slug is used by default.\n   *\n   * This is useful if you would like to generate a top level type to share amongst collections/fields.\n   * **Note**: Top level types can collide, ensure they are unique amongst collections, arrays, groups, blocks, tabs.\n   */\n  interfaceName?: string\n  jsx?: BlockJSX\n  labels?: Labels\n  slug: string\n}\n\nexport type ClientBlock = {\n  admin?: Pick<Block['admin'], 'custom'>\n  fields: ClientField[]\n  labels?: LabelsClient\n} & Pick<Block, 'imageAltText' | 'imageURL' | 'jsx' | 'slug'>\n\nexport type BlocksField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<BlocksFieldErrorClientComponent | BlocksFieldErrorServerComponent>\n      Label?: CustomComponent<BlocksFieldLabelClientComponent | BlocksFieldLabelServerComponent>\n    } & Admin['components']\n    initCollapsed?: boolean\n    /**\n     * Disable drag and drop sorting\n     */\n    isSortable?: boolean\n  } & Admin\n  /**\n   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.\n   *\n   * @todo `blockReferences` will be merged with `blocks` in 4.0\n   */\n  blockReferences?: (Block | BlockSlug)[]\n  blocks: Block[]\n  defaultValue?: DefaultValue\n  labels?: Labels\n  maxRows?: number\n  minRows?: number\n  type: 'blocks'\n  validate?: BlocksFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type BlocksFieldClient = {\n  admin?: AdminClient & Pick<BlocksField['admin'], 'initCollapsed' | 'isSortable'>\n  /**\n   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.\n   *\n   * @todo `blockReferences` will be merged with `blocks` in 4.0\n   */\n  blockReferences?: (ClientBlock | string)[]\n  blocks: ClientBlock[]\n  labels?: LabelsClient\n} & FieldBaseClient &\n  Pick<BlocksField, 'maxRows' | 'minRows' | 'type'>\n\nexport type PointField = {\n  admin?: {\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<PointFieldErrorClientComponent | PointFieldErrorServerComponent>\n      Label?: CustomComponent<PointFieldLabelClientComponent | PointFieldLabelServerComponent>\n    } & Admin['components']\n    placeholder?: Record<string, string> | string\n    step?: number\n  } & Admin\n  type: 'point'\n  validate?: PointFieldValidation\n} & Omit<FieldBase, 'validate'>\n\nexport type PointFieldClient = {\n  admin?: AdminClient & Pick<PointField['admin'], 'placeholder' | 'step'>\n} & FieldBaseClient &\n  Pick<PointField, 'type'>\n\n/**\n * A virtual field that loads in related collections by querying a relationship or upload field.\n */\nexport type JoinField = {\n  access?: {\n    create?: never\n    read?: FieldAccess\n    update?: never\n  }\n  admin?: {\n    allowCreate?: boolean\n    components?: {\n      afterInput?: CustomComponent[]\n      beforeInput?: CustomComponent[]\n      Error?: CustomComponent<JoinFieldErrorClientComponent | JoinFieldErrorServerComponent>\n      Label?: CustomComponent<JoinFieldLabelClientComponent | JoinFieldLabelServerComponent>\n    } & Admin['components']\n    defaultColumns?: string[]\n    disableBulkEdit?: never\n    readOnly?: never\n  } & Admin\n  /**\n   * The slug of the collection to relate with.\n   */\n  collection: CollectionSlug | CollectionSlug[]\n  defaultLimit?: number\n  defaultSort?: Sort\n  defaultValue?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's hasMany property.\n   */\n  hasMany?: boolean\n  hidden?: false\n  index?: never\n  /**\n   * This does not need to be set and will be overridden by the relationship field's localized property.\n   */\n  localized?: boolean\n  /**\n   * The maximum allowed depth to be permitted application-wide. This setting helps prevent against malicious queries.\n   *\n   * @see https://payloadcms.com/docs/getting-started/concepts#depth\n   *\n   * @default 1\n   */\n  maxDepth?: number\n  /**\n   * A string for the field in the collection being joined to.\n   */\n  on: string\n  sanitizedMany?: JoinField[]\n  type: 'join'\n  validate?: never\n  where?: Where\n} & FieldBase &\n  FieldGraphQLType\n\nexport type JoinFieldClient = {\n  admin?: AdminClient &\n    Pick<JoinField['admin'], 'allowCreate' | 'defaultColumns' | 'disableBulkEdit' | 'readOnly'>\n} & { targetField: Pick<RelationshipFieldClient, 'relationTo'> } & FieldBaseClient &\n  Pick<\n    JoinField,\n    'collection' | 'defaultLimit' | 'defaultSort' | 'index' | 'maxDepth' | 'on' | 'type' | 'where'\n  >\n\nexport type FlattenedBlock = {\n  flattenedFields: FlattenedField[]\n} & Block\n\nexport type FlattenedBlocksField = {\n  /**\n   * Like `blocks`, but allows you to also pass strings that are slugs of blocks defined in `config.blocks`.\n   *\n   * @todo `blockReferences` will be merged with `blocks` in 4.0\n   */\n  blockReferences?: (FlattenedBlock | string)[]\n  blocks: FlattenedBlock[]\n} & Omit<BlocksField, 'blockReferences' | 'blocks'>\n\nexport type FlattenedGroupField = {\n  flattenedFields: FlattenedField[]\n} & GroupField\n\nexport type FlattenedArrayField = {\n  flattenedFields: FlattenedField[]\n} & ArrayField\n\nexport type FlattenedTabAsField = {\n  flattenedFields: FlattenedField[]\n} & MarkRequired<TabAsField, 'name'>\n\nexport type FlattenedJoinField = {\n  targetField: RelationshipField | UploadField\n} & JoinField\n\nexport type FlattenedField =\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | FlattenedArrayField\n  | FlattenedBlocksField\n  | FlattenedGroupField\n  | FlattenedJoinField\n  | FlattenedTabAsField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TextareaField\n  | TextField\n  | UploadField\nexport type Field =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UIField\n  | UploadField\n\nexport type ClientField =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UIFieldClient\n  | UploadFieldClient\n\nexport type ClientFieldProps =\n  | ArrayFieldClientProps\n  | BlocksFieldClientProps\n  | CheckboxFieldClientProps\n  | CodeFieldClientProps\n  | CollapsibleFieldClientProps\n  | DateFieldClientProps\n  | EmailFieldClientProps\n  | GroupFieldClientProps\n  | HiddenFieldProps\n  | JoinFieldClientProps\n  | JSONFieldClientProps\n  | NumberFieldClientProps\n  | PointFieldClientProps\n  | RadioFieldClientProps\n  | RelationshipFieldClientProps\n  | RichTextFieldClientProps\n  | RowFieldClientProps\n  | SelectFieldClientProps\n  | TabsFieldClientProps\n  | TextareaFieldClientProps\n  | TextFieldClientProps\n  | UploadFieldClientProps\n\ntype ExtractFieldTypes<T> = T extends { type: infer U } ? U : never\n\nexport type FieldTypes = ExtractFieldTypes<Field>\n\nexport type FieldAffectingData =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | DateField\n  | EmailField\n  | GroupField\n  | JoinField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | SelectField\n  | TabAsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type FieldAffectingDataClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JoinFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | SelectFieldClient\n  | TabAsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type NonPresentationalField =\n  | ArrayField\n  | BlocksField\n  | CheckboxField\n  | CodeField\n  | CollapsibleField\n  | DateField\n  | EmailField\n  | GroupField\n  | JSONField\n  | NumberField\n  | PointField\n  | RadioField\n  | RelationshipField\n  | RichTextField\n  | RowField\n  | SelectField\n  | TabsField\n  | TextareaField\n  | TextField\n  | UploadField\n\nexport type NonPresentationalFieldClient =\n  | ArrayFieldClient\n  | BlocksFieldClient\n  | CheckboxFieldClient\n  | CodeFieldClient\n  | CollapsibleFieldClient\n  | DateFieldClient\n  | EmailFieldClient\n  | GroupFieldClient\n  | JSONFieldClient\n  | NumberFieldClient\n  | PointFieldClient\n  | RadioFieldClient\n  | RelationshipFieldClient\n  | RichTextFieldClient\n  | RowFieldClient\n  | SelectFieldClient\n  | TabsFieldClient\n  | TextareaFieldClient\n  | TextFieldClient\n  | UploadFieldClient\n\nexport type FieldWithPath = {\n  path?: string\n} & Field\n\nexport type FieldWithPathClient = {\n  path?: string\n} & ClientField\n\nexport type FieldWithSubFields = ArrayField | CollapsibleField | GroupField | RowField\n\nexport type FieldWithSubFieldsClient =\n  | ArrayFieldClient\n  | CollapsibleFieldClient\n  | GroupFieldClient\n  | RowFieldClient\n\nexport type FieldPresentationalOnly = UIField\nexport type FieldPresentationalOnlyClient = UIFieldClient\n\nexport type FieldWithMany = RelationshipField | SelectField\nexport type FieldWithManyClient = RelationshipFieldClient | SelectFieldClient\n\nexport type FieldWithMaxDepth = RelationshipField | UploadField\nexport type FieldWithMaxDepthClient = JoinFieldClient | RelationshipFieldClient | UploadFieldClient\n\nexport function fieldHasSubFields<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithSubFieldsClient : FieldWithSubFields) {\n  return (\n    field.type === 'group' ||\n    field.type === 'array' ||\n    field.type === 'row' ||\n    field.type === 'collapsible'\n  )\n}\n\nexport function fieldIsArrayType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? ArrayFieldClient : ArrayField) {\n  return field.type === 'array'\n}\n\nexport function fieldIsBlockType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? BlocksFieldClient : BlocksField) {\n  return field.type === 'blocks'\n}\n\nexport function fieldIsGroupType<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? GroupFieldClient : GroupField) {\n  return field.type === 'group'\n}\n\nexport function optionIsObject(option: Option): option is OptionObject {\n  return typeof option === 'object'\n}\n\nexport function optionsAreObjects(options: Option[]): options is OptionObject[] {\n  return Array.isArray(options) && typeof options?.[0] === 'object'\n}\n\nexport function optionIsValue(option: Option): option is string {\n  return typeof option === 'string'\n}\n\nexport function fieldSupportsMany<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithManyClient : FieldWithMany) {\n  return field.type === 'select' || field.type === 'relationship' || field.type === 'upload'\n}\n\nexport function fieldHasMaxDepth<TField extends ClientField | Field>(\n  field: TField,\n): field is TField & (TField extends ClientField ? FieldWithMaxDepthClient : FieldWithMaxDepth) {\n  return (\n    (field.type === 'upload' || field.type === 'relationship' || field.type === 'join') &&\n    typeof field.maxDepth === 'number'\n  )\n}\n\nexport function fieldIsPresentationalOnly<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField & (TField extends ClientField | TabAsFieldClient ? UIFieldClient : UIField) {\n  return field.type === 'ui'\n}\n\nexport function fieldIsSidebar<TField extends ClientField | Field | TabAsField | TabAsFieldClient>(\n  field: TField,\n): field is { admin: { position: 'sidebar' } } & TField {\n  return 'admin' in field && 'position' in field.admin && field.admin.position === 'sidebar'\n}\n\nexport function fieldIsID<TField extends ClientField | Field>(\n  field: TField,\n): field is { name: 'id' } & TField {\n  return 'name' in field && field.name === 'id'\n}\n\nexport function fieldIsHiddenOrDisabled<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(field: TField): field is { admin: { hidden: true } } & TField {\n  return (\n    ('hidden' in field && field.hidden) ||\n    ('admin' in field && 'disabled' in field.admin && field.admin.disabled)\n  )\n}\n\nexport function fieldAffectsData<\n  TField extends ClientField | Field | TabAsField | TabAsFieldClient,\n>(\n  field: TField,\n): field is TField &\n  (TField extends ClientField | TabAsFieldClient ? FieldAffectingDataClient : FieldAffectingData) {\n  return 'name' in field && !fieldIsPresentationalOnly(field)\n}\n\nexport function tabHasName<TField extends ClientTab | Tab>(tab: TField): tab is NamedTab & TField {\n  return 'name' in tab\n}\n\n/**\n * Check if a field has localized: true set. This does not check if a field *should*\n * be localized. To check if a field should be localized, use `fieldShouldBeLocalized`.\n *\n * @deprecated this will be removed or modified in v4.0, as `fieldIsLocalized` can easily lead to bugs due to\n * parent field localization not being taken into account.\n */\nexport function fieldIsLocalized(field: Field | Tab): boolean {\n  return 'localized' in field && field.localized\n}\n\n/**\n * Similar to `fieldIsLocalized`, but returns `false` if any parent field is localized.\n */\nexport function fieldShouldBeLocalized({\n  field,\n  parentIsLocalized,\n}: {\n  field: ClientField | ClientTab | Field | Tab\n  parentIsLocalized: boolean\n}): boolean {\n  return (\n    'localized' in field &&\n    field.localized &&\n    (!parentIsLocalized ||\n      process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized === 'true')\n  )\n}\n\nexport function fieldIsVirtual(field: Field | Tab): boolean {\n  return 'virtual' in field && field.virtual\n}\n\nexport type HookName =\n  | 'afterChange'\n  | 'afterRead'\n  | 'beforeChange'\n  | 'beforeRead'\n  | 'beforeValidate'\n"],"names":["valueIsValueWithRelation","value","fieldHasSubFields","field","type","fieldIsArrayType","fieldIsBlockType","fieldIsGroupType","optionIsObject","option","optionsAreObjects","options","Array","isArray","optionIsValue","fieldSupportsMany","fieldHasMaxDepth","maxDepth","fieldIsPresentationalOnly","fieldIsSidebar","admin","position","fieldIsID","name","fieldIsHiddenOrDisabled","hidden","disabled","fieldAffectsData","tabHasName","tab","fieldIsLocalized","localized","fieldShouldBeLocalized","parentIsLocalized","process","env","NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized","fieldIsVirtual","virtual"],"mappings":"AAAA,oBAAoB;AACpB,qDAAqD,GAwpCrD;;;;;;;;;;;;;;;;;;;;;AAAO,SAASA,yBAAyBC,KAAc;IACrD,OAAOA,UAAU,QAAQ,OAAOA,UAAU,YAAY,gBAAgBA,SAAS,WAAWA;AAC5F;AAklBO,SAASC,kBACdC,KAAa;IAEb,OACEA,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,WACfD,MAAMC,IAAI,KAAK,SACfD,MAAMC,IAAI,KAAK;AAEnB;AAEO,SAASC,iBACdF,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASE,iBACdH,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASG,iBACdJ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASI,eAAeC,MAAc;IAC3C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASC,kBAAkBC,OAAiB;IACjD,OAAOC,MAAMC,OAAO,CAACF,YAAY,OAAOA,SAAS,CAAC,EAAE,KAAK;AAC3D;AAEO,SAASG,cAAcL,MAAc;IAC1C,OAAO,OAAOA,WAAW;AAC3B;AAEO,SAASM,kBACdZ,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK;AACpF;AAEO,SAASY,iBACdb,KAAa;IAEb,OACGA,CAAAA,MAAMC,IAAI,KAAK,YAAYD,MAAMC,IAAI,KAAK,kBAAkBD,MAAMC,IAAI,KAAK,MAAK,KACjF,OAAOD,MAAMc,QAAQ,KAAK;AAE9B;AAEO,SAASC,0BAGdf,KAAa;IAEb,OAAOA,MAAMC,IAAI,KAAK;AACxB;AAEO,SAASe,eACdhB,KAAa;IAEb,OAAO,WAAWA,SAAS,cAAcA,MAAMiB,KAAK,IAAIjB,MAAMiB,KAAK,CAACC,QAAQ,KAAK;AACnF;AAEO,SAASC,UACdnB,KAAa;IAEb,OAAO,UAAUA,SAASA,MAAMoB,IAAI,KAAK;AAC3C;AAEO,SAASC,wBAEdrB,KAAa;IACb,OACG,YAAYA,SAASA,MAAMsB,MAAM,IACjC,WAAWtB,SAAS,cAAcA,MAAMiB,KAAK,IAAIjB,MAAMiB,KAAK,CAACM,QAAQ;AAE1E;AAEO,SAASC,iBAGdxB,KAAa;IAGb,OAAO,UAAUA,SAAS,CAACe,0BAA0Bf;AACvD;AAEO,SAASyB,WAA2CC,GAAW;IACpE,OAAO,UAAUA;AACnB;AASO,SAASC,iBAAiB3B,KAAkB;IACjD,OAAO,eAAeA,SAASA,MAAM4B,SAAS;AAChD;AAKO,SAASC,uBAAuB,EACrC7B,KAAK,EACL8B,iBAAiB,EAIlB;IACC,OACE,eAAe9B,SACfA,MAAM4B,SAAS,IACd,CAAA,CAACE,qBACAC,QAAQC,GAAG,CAACC,+DAA+D,KAAK,MAAK;AAE3F;AAEO,SAASC,eAAelC,KAAkB;IAC/C,OAAO,aAAaA,SAASA,MAAMmC,OAAO;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/baseFields/timezone/defaultTimezones.ts"],"sourcesContent":["import type { Timezone } from '../../../config/types.js'\n\n/**\n * List of supported timezones\n *\n * label: UTC offset and location\n * value: IANA timezone name\n *\n * @example\n * { label: '(UTC-12:00) International Date Line West', value: 'Dateline Standard Time' }\n */\nexport const defaultTimezones: Timezone[] = [\n  { label: '(UTC-11:00) Midway Island, Samoa', value: 'Pacific/Midway' },\n  { label: '(UTC-11:00) Niue', value: 'Pacific/Niue' },\n  { label: '(UTC-10:00) Hawaii', value: 'Pacific/Honolulu' },\n  { label: '(UTC-10:00) Cook Islands', value: 'Pacific/Rarotonga' },\n  { label: '(UTC-09:00) Alaska', value: 'America/Anchorage' },\n  { label: '(UTC-09:00) Gambier Islands', value: 'Pacific/Gambier' },\n  { label: '(UTC-08:00) Pacific Time (US & Canada)', value: 'America/Los_Angeles' },\n  { label: '(UTC-08:00) Tijuana, Baja California', value: 'America/Tijuana' },\n  { label: '(UTC-07:00) Mountain Time (US & Canada)', value: 'America/Denver' },\n  { label: '(UTC-07:00) Arizona (No DST)', value: 'America/Phoenix' },\n  { label: '(UTC-06:00) Central Time (US & Canada)', value: 'America/Chicago' },\n  { label: '(UTC-06:00) Central America', value: 'America/Guatemala' },\n  { label: '(UTC-05:00) Eastern Time (US & Canada)', value: 'America/New_York' },\n  { label: '(UTC-05:00) Bogota, Lima, Quito', value: 'America/Bogota' },\n  { label: '(UTC-04:00) Caracas', value: 'America/Caracas' },\n  { label: '(UTC-04:00) Santiago', value: 'America/Santiago' },\n  { label: '(UTC-03:00) Buenos Aires', value: 'America/Buenos_Aires' },\n  { label: '(UTC-03:00) Brasilia', value: 'America/Sao_Paulo' },\n  { label: '(UTC-02:00) South Georgia', value: 'Atlantic/South_Georgia' },\n  { label: '(UTC-01:00) Azores', value: 'Atlantic/Azores' },\n  { label: '(UTC-01:00) Cape Verde', value: 'Atlantic/Cape_Verde' },\n  { label: '(UTC+00:00) London (GMT)', value: 'Europe/London' },\n  { label: '(UTC+01:00) Berlin, Paris', value: 'Europe/Berlin' },\n  { label: '(UTC+01:00) Lagos', value: 'Africa/Lagos' },\n  { label: '(UTC+02:00) Athens, Bucharest', value: 'Europe/Athens' },\n  { label: '(UTC+02:00) Cairo', value: 'Africa/Cairo' },\n  { label: '(UTC+03:00) Moscow, St. Petersburg', value: 'Europe/Moscow' },\n  { label: '(UTC+03:00) Riyadh', value: 'Asia/Riyadh' },\n  { label: '(UTC+04:00) Dubai', value: 'Asia/Dubai' },\n  { label: '(UTC+04:00) Baku', value: 'Asia/Baku' },\n  { label: '(UTC+05:00) Islamabad, Karachi', value: 'Asia/Karachi' },\n  { label: '(UTC+05:00) Tashkent', value: 'Asia/Tashkent' },\n  { label: '(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi', value: 'Asia/Calcutta' },\n  { label: '(UTC+06:00) Dhaka', value: 'Asia/Dhaka' },\n  { label: '(UTC+06:00) Almaty', value: 'Asia/Almaty' },\n  { label: '(UTC+07:00) Jakarta', value: 'Asia/Jakarta' },\n  { label: '(UTC+07:00) Bangkok', value: 'Asia/Bangkok' },\n  { label: '(UTC+08:00) Beijing, Shanghai', value: 'Asia/Shanghai' },\n  { label: '(UTC+08:00) Singapore', value: 'Asia/Singapore' },\n  { label: '(UTC+09:00) Tokyo, Osaka, Sapporo', value: 'Asia/Tokyo' },\n  { label: '(UTC+09:00) Seoul', value: 'Asia/Seoul' },\n  { label: '(UTC+10:00) Sydney, Melbourne', value: 'Australia/Sydney' },\n  { label: '(UTC+10:00) Guam, Port Moresby', value: 'Pacific/Guam' },\n  { label: '(UTC+11:00) New Caledonia', value: 'Pacific/Noumea' },\n  { label: '(UTC+12:00) Auckland, Wellington', value: 'Pacific/Auckland' },\n  { label: '(UTC+12:00) Fiji', value: 'Pacific/Fiji' },\n]\n"],"names":["defaultTimezones","label","value"],"mappings":"AAEA;;;;;;;;CAQC,GACD;;;AAAO,MAAMA,mBAA+B;IAC1C;QAAEC,OAAO;QAAoCC,OAAO;IAAiB;IACrE;QAAED,OAAO;QAAoBC,OAAO;IAAe;IACnD;QAAED,OAAO;QAAsBC,OAAO;IAAmB;IACzD;QAAED,OAAO;QAA4BC,OAAO;IAAoB;IAChE;QAAED,OAAO;QAAsBC,OAAO;IAAoB;IAC1D;QAAED,OAAO;QAA+BC,OAAO;IAAkB;IACjE;QAAED,OAAO;QAA0CC,OAAO;IAAsB;IAChF;QAAED,OAAO;QAAwCC,OAAO;IAAkB;IAC1E;QAAED,OAAO;QAA2CC,OAAO;IAAiB;IAC5E;QAAED,OAAO;QAAgCC,OAAO;IAAkB;IAClE;QAAED,OAAO;QAA0CC,OAAO;IAAkB;IAC5E;QAAED,OAAO;QAA+BC,OAAO;IAAoB;IACnE;QAAED,OAAO;QAA0CC,OAAO;IAAmB;IAC7E;QAAED,OAAO;QAAmCC,OAAO;IAAiB;IACpE;QAAED,OAAO;QAAuBC,OAAO;IAAkB;IACzD;QAAED,OAAO;QAAwBC,OAAO;IAAmB;IAC3D;QAAED,OAAO;QAA4BC,OAAO;IAAuB;IACnE;QAAED,OAAO;QAAwBC,OAAO;IAAoB;IAC5D;QAAED,OAAO;QAA6BC,OAAO;IAAyB;IACtE;QAAED,OAAO;QAAsBC,OAAO;IAAkB;IACxD;QAAED,OAAO;QAA0BC,OAAO;IAAsB;IAChE;QAAED,OAAO;QAA4BC,OAAO;IAAgB;IAC5D;QAAED,OAAO;QAA6BC,OAAO;IAAgB;IAC7D;QAAED,OAAO;QAAqBC,OAAO;IAAe;IACpD;QAAED,OAAO;QAAiCC,OAAO;IAAgB;IACjE;QAAED,OAAO;QAAqBC,OAAO;IAAe;IACpD;QAAED,OAAO;QAAsCC,OAAO;IAAgB;IACtE;QAAED,OAAO;QAAsBC,OAAO;IAAc;IACpD;QAAED,OAAO;QAAqBC,OAAO;IAAa;IAClD;QAAED,OAAO;QAAoBC,OAAO;IAAY;IAChD;QAAED,OAAO;QAAkCC,OAAO;IAAe;IACjE;QAAED,OAAO;QAAwBC,OAAO;IAAgB;IACxD;QAAED,OAAO;QAAmDC,OAAO;IAAgB;IACnF;QAAED,OAAO;QAAqBC,OAAO;IAAa;IAClD;QAAED,OAAO;QAAsBC,OAAO;IAAc;IACpD;QAAED,OAAO;QAAuBC,OAAO;IAAe;IACtD;QAAED,OAAO;QAAuBC,OAAO;IAAe;IACtD;QAAED,OAAO;QAAiCC,OAAO;IAAgB;IACjE;QAAED,OAAO;QAAyBC,OAAO;IAAiB;IAC1D;QAAED,OAAO;QAAqCC,OAAO;IAAa;IAClE;QAAED,OAAO;QAAqBC,OAAO;IAAa;IAClD;QAAED,OAAO;QAAiCC,OAAO;IAAmB;IACpE;QAAED,OAAO;QAAkCC,OAAO;IAAe;IACjE;QAAED,OAAO;QAA6BC,OAAO;IAAiB;IAC9D;QAAED,OAAO;QAAoCC,OAAO;IAAmB;IACvE;QAAED,OAAO;QAAoBC,OAAO;IAAe;CACpD,CAAA","ignoreList":[0]}},
    {"offset": {"line": 289, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/getFieldPaths.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { ClientField, Field, Tab, TabAsFieldClient } from './config/types.js'\n\ntype Args = {\n  field: ClientField | Field | Tab | TabAsFieldClient\n  index: number\n  parentIndexPath: string\n  parentPath: string\n  parentSchemaPath: string\n}\n\ntype FieldPaths = {\n  /**\n   * A string of '-' separated indexes representing where\n   * to find this field in a given field schema array.\n   * It will always be complete and accurate.\n   */\n  indexPath: string\n  /**\n   * Path for this field relative to its position in the data.\n   */\n  path: string\n  /**\n   * Path for this field relative to its position in the schema.\n   */\n  schemaPath: string\n}\n\nexport function getFieldPaths({\n  field,\n  index,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n}: Args): FieldPaths {\n  if ('name' in field) {\n    return {\n      indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n      path: `${parentPath ? parentPath + '.' : ''}${field.name}`,\n      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,\n    }\n  }\n\n  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`\n\n  return {\n    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n    path: `${parentPath ? parentPath + '.' : ''}${indexSuffix}`,\n    schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,\n  }\n}\n\nexport function getFieldPathsModified({\n  field,\n  index,\n  parentIndexPath,\n  parentPath,\n  parentSchemaPath,\n}: Args): FieldPaths {\n  const parentPathSegments = parentPath.split('.')\n\n  const parentIsUnnamed = parentPathSegments[parentPathSegments.length - 1].startsWith('_index-')\n\n  const parentWithoutIndex = parentIsUnnamed\n    ? parentPathSegments.slice(0, -1).join('.')\n    : parentPath\n\n  const parentPathToUse = parentIsUnnamed ? parentWithoutIndex : parentPath\n\n  if ('name' in field) {\n    return {\n      indexPath: '',\n      path: `${parentPathToUse ? parentPathToUse + '.' : ''}${field.name}`,\n      schemaPath: `${parentSchemaPath ? parentSchemaPath + '.' : ''}${field.name}`,\n    }\n  }\n\n  const indexSuffix = `_index-${`${parentIndexPath ? parentIndexPath + '-' : ''}${index}`}`\n\n  return {\n    indexPath: `${parentIndexPath ? parentIndexPath + '-' : ''}${index}`,\n    path: `${parentPathToUse ? parentPathToUse + '.' : ''}${indexSuffix}`,\n    schemaPath: `${!parentIsUnnamed && parentSchemaPath ? parentSchemaPath + '.' : ''}${indexSuffix}`,\n  }\n}\n"],"names":["getFieldPaths","field","index","parentIndexPath","parentPath","parentSchemaPath","indexPath","path","name","schemaPath","indexSuffix","getFieldPathsModified","parentPathSegments","split","parentIsUnnamed","length","startsWith","parentWithoutIndex","slice","join","parentPathToUse"],"mappings":"AAAA,oBAAoB;;;;;AA4Bb,SAASA,cAAc,EAC5BC,KAAK,EACLC,KAAK,EACLC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EACX;IACL,IAAI,UAAUJ,OAAO;QACnB,OAAO;YACLK,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;YACpEK,MAAM,GAAGH,aAAaA,aAAa,MAAM,KAAKH,MAAMO,IAAI,EAAE;YAC1DC,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKJ,MAAMO,IAAI,EAAE;QAC9E;IACF;IAEA,MAAME,cAAc,CAAC,OAAO,EAAE,GAAGP,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO,EAAE;IAEzF,OAAO;QACLI,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;QACpEK,MAAM,GAAGH,aAAaA,aAAa,MAAM,KAAKM,aAAa;QAC3DD,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKK,aAAa;IAC/E;AACF;AAEO,SAASC,sBAAsB,EACpCV,KAAK,EACLC,KAAK,EACLC,eAAe,EACfC,UAAU,EACVC,gBAAgB,EACX;IACL,MAAMO,qBAAqBR,WAAWS,KAAK,CAAC;IAE5C,MAAMC,kBAAkBF,kBAAkB,CAACA,mBAAmBG,MAAM,GAAG,EAAE,CAACC,UAAU,CAAC;IAErF,MAAMC,qBAAqBH,kBACvBF,mBAAmBM,KAAK,CAAC,GAAG,CAAC,GAAGC,IAAI,CAAC,OACrCf;IAEJ,MAAMgB,kBAAkBN,kBAAkBG,qBAAqBb;IAE/D,IAAI,UAAUH,OAAO;QACnB,OAAO;YACLK,WAAW;YACXC,MAAM,GAAGa,kBAAkBA,kBAAkB,MAAM,KAAKnB,MAAMO,IAAI,EAAE;YACpEC,YAAY,GAAGJ,mBAAmBA,mBAAmB,MAAM,KAAKJ,MAAMO,IAAI,EAAE;QAC9E;IACF;IAEA,MAAME,cAAc,CAAC,OAAO,EAAE,GAAGP,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO,EAAE;IAEzF,OAAO;QACLI,WAAW,GAAGH,kBAAkBA,kBAAkB,MAAM,KAAKD,OAAO;QACpEK,MAAM,GAAGa,kBAAkBA,kBAAkB,MAAM,KAAKV,aAAa;QACrED,YAAY,GAAG,CAACK,mBAAmBT,mBAAmBA,mBAAmB,MAAM,KAAKK,aAAa;IACnG;AACF","ignoreList":[0]}},
    {"offset": {"line": 334, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/getDefaultValue.ts"],"sourcesContent":["import type { DefaultValue, JsonValue, PayloadRequest } from '../types/index.js'\n\nimport { deepCopyObjectSimple } from '../utilities/deepCopyObject.js'\n\ntype Args = {\n  defaultValue: DefaultValue\n  locale: string | undefined\n  req: PayloadRequest\n  user: PayloadRequest['user']\n  value?: JsonValue\n}\n\nexport const getDefaultValue = async ({\n  defaultValue,\n  locale,\n  req,\n  user,\n  value,\n}: Args): Promise<JsonValue> => {\n  if (typeof value !== 'undefined') {\n    return value\n  }\n\n  if (defaultValue && typeof defaultValue === 'function') {\n    return await defaultValue({ locale, req, user })\n  }\n\n  if (typeof defaultValue === 'object') {\n    return deepCopyObjectSimple(defaultValue)\n  }\n\n  return defaultValue\n}\n"],"names":["deepCopyObjectSimple","getDefaultValue","defaultValue","locale","req","user","value"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,iCAAgC;;AAU9D,MAAMC,kBAAkB,OAAO,EACpCC,YAAY,EACZC,MAAM,EACNC,GAAG,EACHC,IAAI,EACJC,KAAK,EACA;IACL,IAAI,OAAOA,UAAU,aAAa;QAChC,OAAOA;IACT;IAEA,IAAIJ,gBAAgB,OAAOA,iBAAiB,YAAY;QACtD,OAAO,MAAMA,aAAa;YAAEC;YAAQC;YAAKC;QAAK;IAChD;IAEA,IAAI,OAAOH,iBAAiB,UAAU;QACpC,4KAAOF,uBAAAA,EAAqBE;IAC9B;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/afterRead/relationshipPopulationPromise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { PayloadRequest, PopulateType } from '../../../types/index.js'\nimport type { JoinField, RelationshipField, UploadField } from '../../config/types.js'\n\nimport { createDataloaderCacheKey } from '../../../collections/dataloader.js'\nimport { fieldHasMaxDepth, fieldShouldBeLocalized, fieldSupportsMany } from '../../config/types.js'\n\ntype PopulateArgs = {\n  currentDepth: number\n  data: Record<string, unknown>\n  dataReference: Record<string, any>\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  index?: number\n  key?: string\n  locale: null | string\n  overrideAccess: boolean\n  populateArg?: PopulateType\n  req: PayloadRequest\n  showHiddenFields: boolean\n}\n\n// TODO: this function is mess, refactor logic\nconst populate = async ({\n  currentDepth,\n  data,\n  dataReference,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  index,\n  key,\n  locale,\n  overrideAccess,\n  populateArg,\n  req,\n  showHiddenFields,\n}: PopulateArgs) => {\n  const dataToUpdate = dataReference\n  let relation\n  if (field.type === 'join') {\n    relation = Array.isArray(field.collection) ? data.relationTo : field.collection\n  } else {\n    relation = Array.isArray(field.relationTo) ? (data.relationTo as string) : field.relationTo\n  }\n\n  const relatedCollection = req.payload.collections[relation]\n\n  if (relatedCollection) {\n    let id: unknown\n\n    if (field.type === 'join' && Array.isArray(field.collection)) {\n      id = data.value\n    } else if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n      id = data.value\n    } else {\n      id = data\n    }\n\n    let relationshipValue\n    const shouldPopulate = depth && currentDepth <= depth\n\n    if (\n      typeof id !== 'string' &&\n      typeof id !== 'number' &&\n      typeof id?.toString === 'function' &&\n      typeof id !== 'object'\n    ) {\n      id = id.toString()\n    }\n\n    if (shouldPopulate) {\n      relationshipValue = await req.payloadDataLoader.load(\n        createDataloaderCacheKey({\n          collectionSlug: relatedCollection.config.slug,\n          currentDepth: currentDepth + 1,\n          depth,\n          docID: id as string,\n          draft,\n          fallbackLocale,\n          locale,\n          overrideAccess,\n          populate: populateArg,\n          select:\n            populateArg?.[relatedCollection.config.slug] ??\n            relatedCollection.config.defaultPopulate,\n          showHiddenFields,\n          transactionID: req.transactionID,\n        }),\n      )\n    }\n\n    if (!relationshipValue) {\n      // ids are visible regardless of access controls\n      relationshipValue = id\n    }\n    if (typeof index === 'number' && typeof key === 'string') {\n      if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][key][index].value = relationshipValue\n      } else {\n        if (field.type === 'join' && Array.isArray(field.collection)) {\n          dataToUpdate[field.name][key][index].value = relationshipValue\n        } else {\n          dataToUpdate[field.name][key][index] = relationshipValue\n        }\n      }\n    } else if (typeof index === 'number' || typeof key === 'string') {\n      if (field.type === 'join') {\n        if (!Array.isArray(field.collection)) {\n          dataToUpdate[field.name].docs[index ?? key] = relationshipValue\n        } else {\n          dataToUpdate[field.name].docs[index ?? key].value = relationshipValue\n        }\n      } else if (Array.isArray(field.relationTo)) {\n        dataToUpdate[field.name][index ?? key].value = relationshipValue\n      } else {\n        dataToUpdate[field.name][index ?? key] = relationshipValue\n      }\n    } else if (field.type !== 'join' && Array.isArray(field.relationTo)) {\n      dataToUpdate[field.name].value = relationshipValue\n    } else {\n      if (field.type === 'join' && Array.isArray(field.collection)) {\n        dataToUpdate[field.name].value = relationshipValue\n      } else {\n        dataToUpdate[field.name] = relationshipValue\n      }\n    }\n  }\n}\n\ntype PromiseArgs = {\n  currentDepth: number\n  depth: number\n  draft: boolean\n  fallbackLocale: null | string\n  field: JoinField | RelationshipField | UploadField\n  locale: null | string\n  overrideAccess: boolean\n  parentIsLocalized: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  showHiddenFields: boolean\n  siblingDoc: Record<string, any>\n}\n\nexport const relationshipPopulationPromise = async ({\n  currentDepth,\n  depth,\n  draft,\n  fallbackLocale,\n  field,\n  locale,\n  overrideAccess,\n  parentIsLocalized,\n  populate: populateArg,\n  req,\n  showHiddenFields,\n  siblingDoc,\n}: PromiseArgs): Promise<void> => {\n  const resultingDoc = siblingDoc\n  const populateDepth = fieldHasMaxDepth(field) && field.maxDepth < depth ? field.maxDepth : depth\n  const rowPromises = []\n\n  if (field.type === 'join' || (fieldSupportsMany(field) && field.hasMany)) {\n    if (\n      fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n      locale === 'all' &&\n      typeof siblingDoc[field.name] === 'object' &&\n      siblingDoc[field.name] !== null\n    ) {\n      Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n        if (Array.isArray(siblingDoc[field.name][localeKey])) {\n          siblingDoc[field.name][localeKey].forEach((relatedDoc, index) => {\n            const rowPromise = async () => {\n              await populate({\n                currentDepth,\n                data: siblingDoc[field.name][localeKey][index],\n                dataReference: resultingDoc,\n                depth: populateDepth,\n                draft,\n                fallbackLocale,\n                field,\n                index,\n                key: localeKey,\n                locale,\n                overrideAccess,\n                populateArg,\n                req,\n                showHiddenFields,\n              })\n            }\n            rowPromises.push(rowPromise())\n          })\n        }\n      })\n    } else if (\n      Array.isArray(siblingDoc[field.name]) ||\n      Array.isArray(siblingDoc[field.name]?.docs)\n    ) {\n      ;(Array.isArray(siblingDoc[field.name])\n        ? siblingDoc[field.name]\n        : siblingDoc[field.name].docs\n      ).forEach((relatedDoc, index) => {\n        const rowPromise = async () => {\n          if (relatedDoc) {\n            await populate({\n              currentDepth,\n              data:\n                !(field.type === 'join' && Array.isArray(field.collection)) && relatedDoc?.id\n                  ? relatedDoc.id\n                  : relatedDoc,\n              dataReference: resultingDoc,\n              depth: populateDepth,\n              draft,\n              fallbackLocale,\n              field,\n              index,\n              locale,\n              overrideAccess,\n              populateArg,\n              req,\n              showHiddenFields,\n            })\n          }\n        }\n\n        rowPromises.push(rowPromise())\n      })\n    }\n  } else if (\n    field.localized &&\n    locale === 'all' &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null\n  ) {\n    Object.keys(siblingDoc[field.name]).forEach((localeKey) => {\n      const rowPromise = async () => {\n        await populate({\n          currentDepth,\n          data: siblingDoc[field.name][localeKey],\n          dataReference: resultingDoc,\n          depth: populateDepth,\n          draft,\n          fallbackLocale,\n          field,\n          key: localeKey,\n          locale,\n          overrideAccess,\n          populateArg,\n          req,\n          showHiddenFields,\n        })\n      }\n      rowPromises.push(rowPromise())\n    })\n\n    await Promise.all(rowPromises)\n  } else if (siblingDoc[field.name]) {\n    await populate({\n      currentDepth,\n      data: siblingDoc[field.name],\n      dataReference: resultingDoc,\n      depth: populateDepth,\n      draft,\n      fallbackLocale,\n      field,\n      locale,\n      overrideAccess,\n      populateArg,\n      req,\n      showHiddenFields,\n    })\n  }\n  await Promise.all(rowPromises)\n}\n"],"names":["createDataloaderCacheKey","fieldHasMaxDepth","fieldShouldBeLocalized","fieldSupportsMany","populate","currentDepth","data","dataReference","depth","draft","fallbackLocale","field","index","key","locale","overrideAccess","populateArg","req","showHiddenFields","dataToUpdate","relation","type","Array","isArray","collection","relationTo","relatedCollection","payload","collections","id","value","relationshipValue","shouldPopulate","toString","payloadDataLoader","load","collectionSlug","config","slug","docID","select","defaultPopulate","transactionID","name","docs","relationshipPopulationPromise","parentIsLocalized","siblingDoc","resultingDoc","populateDepth","maxDepth","rowPromises","hasMany","Object","keys","forEach","localeKey","relatedDoc","rowPromise","push","localized","Promise","all"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 557, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldIndex,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  siblingFields,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (\n    fieldAffectsData(field) &&\n    field.hidden &&\n    typeof siblingDoc[field.name] !== 'undefined' &&\n    !showHiddenFields\n  ) {\n    delete siblingDoc[field.name]\n  }\n\n  // Strip unselected fields\n  if (fieldAffectsData(field) && select && selectMode) {\n    if (selectMode === 'include') {\n      if (!select[field.name]) {\n        delete siblingDoc[field.name]\n        return\n      }\n    }\n\n    if (selectMode === 'exclude') {\n      if (select[field.name] === false) {\n        delete siblingDoc[field.name]\n        return\n      }\n    }\n  }\n\n  const shouldHoistLocalizedValue =\n    flattenLocales &&\n    fieldAffectsData(field) &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null &&\n    fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n    locale !== 'all' &&\n    req.payload.config.localization\n\n  if (shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name][locale]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      const fallbackValue = siblingDoc[field.name][fallbackLocale]\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (triggerHooks && field.hooks?.afterRead) {\n      await field.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const shouldRunHookOnAllLocales =\n          fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n          (locale === 'all' || !flattenLocales) &&\n          typeof siblingDoc[field.name] === 'object'\n\n        if (shouldRunHookOnAllLocales) {\n          const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n            (async () => {\n              const hookedValue = await currentHook({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                data: doc,\n                depth,\n                draft,\n                field,\n                findMany,\n                global,\n                indexPath: indexPathSegments,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: pathSegments,\n                req,\n                schemaPath: schemaPathSegments,\n                showHiddenFields,\n                siblingData: siblingDoc,\n                siblingFields,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name][locale] = hookedValue\n              }\n            })(),\n          )\n\n          await Promise.all(hookPromises)\n        } else {\n          const hookedValue = await currentHook({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            data: doc,\n            depth,\n            draft,\n            field,\n            findMany,\n            global,\n            indexPath: indexPathSegments,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: pathSegments,\n            req,\n            schemaPath: schemaPathSegments,\n            showHiddenFields,\n            siblingData: siblingDoc,\n            siblingFields,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const result = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            blockData,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!result) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default\n    if (\n      allowDefaultValue &&\n      typeof siblingDoc[field.name] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name] = await getDefaultValue({\n        defaultValue: field.defaultValue,\n        locale,\n        req,\n        user: req.user,\n        value: siblingDoc[field.name],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          parentIsLocalized,\n          populate,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name] as JsonObject\n\n      let arraySelect = select?.[field.name]\n\n      if (selectMode === 'include' && typeof arraySelect === 'object') {\n        arraySelect = {\n          ...arraySelect,\n          id: true,\n        }\n      }\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, rowIndex) => {\n          traverseFields({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path + '.' + rowIndex,\n            parentSchemaPath: schemaPath,\n            populate,\n            populationPromises,\n            req,\n            select: typeof arraySelect === 'object' ? arraySelect : undefined,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              traverseFields({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath,\n                populate,\n                populationPromises,\n                req,\n                showHiddenFields,\n                siblingDoc: (row as JsonObject) || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      let blocksSelect = select?.[field.name]\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, rowIndex) => {\n          const blockTypeToMatch = (row as JsonObject).blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          let blockSelectMode = selectMode\n\n          if (typeof blocksSelect === 'object') {\n            blocksSelect = {\n              ...blocksSelect,\n            }\n\n            // sanitize blocks: {cta: false} to blocks: {cta: {id: true, blockType: true}}\n            if (selectMode === 'exclude' && blocksSelect[block.slug] === false) {\n              blockSelectMode = 'include'\n              blocksSelect[block.slug] = {\n                id: true,\n                blockType: true,\n              }\n            } else if (selectMode === 'include') {\n              if (!blocksSelect[block.slug]) {\n                blocksSelect[block.slug] = {}\n              }\n\n              if (typeof blocksSelect[block.slug] === 'object') {\n                blocksSelect[block.slug] = {\n                  ...(blocksSelect[block.slug] as object),\n                }\n\n                blocksSelect[block.slug]['id'] = true\n                blocksSelect[block.slug]['blockType'] = true\n              }\n            }\n          }\n\n          const blockSelect = blocksSelect?.[block.slug]\n\n          if (block) {\n            traverseFields({\n              blockData: row,\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath + '.' + block.slug,\n              populate,\n              populationPromises,\n              req,\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              showHiddenFields,\n              siblingDoc: (row as JsonObject) || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              const blockTypeToMatch = row.blockType\n\n              const block: Block | undefined =\n                req.payload.blocks[blockTypeToMatch] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                ) as Block | undefined)\n\n              if (block) {\n                traverseFields({\n                  blockData: row,\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  populate,\n                  populationPromises,\n                  req,\n                  showHiddenFields,\n                  siblingDoc: (row as JsonObject) || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'group': {\n      let groupDoc = siblingDoc[field.name] as JsonObject\n\n      if (typeof siblingDoc[field.name] !== 'object') {\n        groupDoc = {}\n      }\n\n      const groupSelect = select?.[field.name]\n\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: '',\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select: typeof groupSelect === 'object' ? groupSelect : undefined,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: groupDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        await editor.hooks.afterRead.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const shouldRunHookOnAllLocales =\n            fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n            (locale === 'all' || !flattenLocales) &&\n            typeof siblingDoc[field.name] === 'object'\n\n          if (shouldRunHookOnAllLocales) {\n            const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value]) =>\n              (async () => {\n                const hookedValue = await currentHook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  indexPath: indexPathSegments,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  parentIsLocalized,\n                  path: pathSegments,\n                  populate,\n                  populationPromises,\n                  req,\n                  schemaPath: schemaPathSegments,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              })(),\n            )\n\n            await Promise.all(hookPromises)\n          } else {\n            const hookedValue = await currentHook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath: indexPathSegments,\n              locale,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              parentIsLocalized,\n              path: pathSegments,\n              populate,\n              populationPromises,\n              req,\n              schemaPath: schemaPathSegments,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabDoc = siblingDoc\n      let tabSelect: SelectType | undefined\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabDoc = siblingDoc[field.name] as JsonObject\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          tabDoc = {}\n        }\n\n        if (typeof select?.[field.name] === 'object') {\n          tabSelect = select?.[field.name] as SelectType\n        }\n      } else {\n        tabSelect = select\n      }\n\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select: tabSelect,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: tabDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getDefaultValue","getFieldPathsModified","getFieldPaths","relationshipPopulationPromise","traverseFields","promise","blockData","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldIndex","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","siblingFields","triggerAccessControl","triggerHooks","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","hidden","name","shouldHoistLocalizedValue","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","type","pointDoc","Array","isArray","coordinates","length","undefined","editor","Error","tabs","forEach","tab","hooks","afterRead","reduce","priorHook","currentHook","shouldRunHookOnAllLocales","hookPromises","Object","entries","hookedValue","data","operation","originalDoc","siblingData","Promise","all","resolve","allowDefaultValue","access","read","result","id","defaultValue","user","push","rows","arraySelect","row","rowIndex","fields","localized","values","localeRows","blocksSelect","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","slug","blockSelectMode","blockSelect","groupDoc","groupSelect","tabDoc","tabSelect","isNamedTab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1248, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1254, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/afterRead/traverseFields.ts"],"sourcesContent":["import type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  fields: (Field | TabAsField)[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\nexport const traverseFields = ({\n  blockData,\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  fieldPromises,\n  fields,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): void => {\n  fields.forEach((field, fieldIndex) => {\n    fieldPromises.push(\n      promise({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        field,\n        fieldIndex,\n        fieldPromises,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        siblingFields: fields,\n        triggerAccessControl,\n        triggerHooks,\n      }),\n    )\n  })\n}\n"],"names":["promise","traverseFields","blockData","collection","context","currentDepth","depth","doc","draft","fallbackLocale","fieldPromises","fields","findMany","flattenLocales","global","locale","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","triggerAccessControl","triggerHooks","forEach","field","fieldIndex","push","siblingFields"],"mappings":";;;AAYA,SAASA,OAAO,QAAQ,eAAc;;AA0C/B,MAAMC,iBAAiB,CAAC,EAC7BC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,YAAY,EACZC,KAAK,EACLC,GAAG,EACHC,KAAK,EACLC,cAAc,EACdC,aAAa,EACbC,MAAM,EACNC,QAAQ,EACRC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,eAAe,EACfC,iBAAiB,EACjBC,UAAU,EACVC,gBAAgB,EAChBC,QAAQ,EACRC,kBAAkB,EAClBC,GAAG,EACHC,MAAM,EACNC,UAAU,EACVC,gBAAgB,EAChBC,UAAU,EACVC,uBAAuB,IAAI,EAC3BC,eAAe,IAAI,EACd;IACLlB,OAAOmB,OAAO,CAAC,CAACC,OAAOC;QACrBtB,cAAcuB,IAAI,kLAChBjC,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAsB;YACAC;YACAtB;YACAE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAO,eAAevB;YACfiB;YACAC;QACF;IAEJ;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 1295, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1301, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/afterRead/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest, PopulateType, SelectType } from '../../../types/index.js'\n\nimport { getSelectMode } from '../../../utilities/getSelectMode.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth?: number\n  depth: number\n  doc: T\n  draft: boolean\n  fallbackLocale: null | string\n  findMany?: boolean\n  flattenLocales?: boolean\n  global: null | SanitizedGlobalConfig\n  locale: string\n  overrideAccess: boolean\n  populate?: PopulateType\n  req: PayloadRequest\n  select?: SelectType\n  showHiddenFields: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Remove hidden fields from response\n * - Flatten locales into requested locale. If the input doc contains all locales, the output doc after this function will only contain the requested locale.\n * - Sanitize outgoing data (point field, etc.)\n * - Execute field hooks\n * - Execute read access control\n * - Populate relationships\n */\n\nexport async function afterRead<T extends JsonObject>(args: Args<T>): Promise<T> {\n  const {\n    collection,\n    context,\n    currentDepth: incomingCurrentDepth,\n    depth: incomingDepth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    findMany,\n    flattenLocales = true,\n    global,\n    locale,\n    overrideAccess,\n    populate,\n    req,\n    select,\n    showHiddenFields,\n  } = args\n\n  const fieldPromises = []\n  const populationPromises = []\n\n  let depth =\n    incomingDepth || incomingDepth === 0\n      ? parseInt(String(incomingDepth), 10)\n      : req.payload.config.defaultDepth\n  if (depth > req.payload.config.maxDepth) {\n    depth = req.payload.config.maxDepth\n  }\n\n  const currentDepth = incomingCurrentDepth || 1\n\n  traverseFields({\n    collection,\n    context,\n    currentDepth,\n    depth,\n    doc: incomingDoc,\n    draft,\n    fallbackLocale,\n    fieldPromises,\n    fields: collection?.fields || global?.fields,\n    findMany,\n    flattenLocales,\n    global,\n    locale,\n    overrideAccess,\n    parentIndexPath: '',\n    parentIsLocalized: false,\n    parentPath: '',\n    parentSchemaPath: '',\n    populate,\n    populationPromises,\n    req,\n    select,\n    selectMode: select ? getSelectMode(select) : undefined,\n    showHiddenFields,\n    siblingDoc: incomingDoc,\n  })\n\n  /**\n   * Await all field and population promises in parallel.\n   * A field promise is able to add more field promises to the fieldPromises array, which will not be\n   * awaited in the first run.\n   * This is why we need to loop again to process the new field promises, until there are no more field promises left.\n   */\n  let iterations = 0\n  while (fieldPromises.length > 0 || populationPromises.length > 0) {\n    const currentFieldPromises = fieldPromises.splice(0, fieldPromises.length)\n    const currentPopulationPromises = populationPromises.splice(0, populationPromises.length)\n\n    await Promise.all(currentFieldPromises)\n    await Promise.all(currentPopulationPromises)\n\n    iterations++\n    if (iterations >= 100) {\n      throw new Error(\n        'Infinite afterRead promise loop detected. A hook is likely adding field promises in an infinitely recursive way.',\n      )\n    }\n  }\n  return incomingDoc\n}\n"],"names":["getSelectMode","traverseFields","afterRead","args","collection","context","currentDepth","incomingCurrentDepth","depth","incomingDepth","doc","incomingDoc","draft","fallbackLocale","findMany","flattenLocales","global","locale","overrideAccess","populate","req","select","showHiddenFields","fieldPromises","populationPromises","parseInt","String","payload","config","defaultDepth","maxDepth","fields","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","selectMode","undefined","siblingDoc","iterations","length","currentFieldPromises","splice","currentPopulationPromises","Promise","all","Error"],"mappings":"AAAA,oBAAoB;;;;AAOpB,SAASC,cAAc,QAAQ,sBAAqB;AADpD,SAASD,aAAa,QAAQ,sCAAqC;;;AAgC5D,eAAeE,UAAgCC,IAAa;IACjE,MAAM,EACJC,UAAU,EACVC,OAAO,EACPC,cAAcC,oBAAoB,EAClCC,OAAOC,aAAa,EACpBC,KAAKC,WAAW,EAChBC,KAAK,EACLC,cAAc,EACdC,QAAQ,EACRC,iBAAiB,IAAI,EACrBC,MAAM,EACNC,MAAM,EACNC,cAAc,EACdC,QAAQ,EACRC,GAAG,EACHC,MAAM,EACNC,gBAAgB,EACjB,GAAGnB;IAEJ,MAAMoB,gBAAgB,EAAE;IACxB,MAAMC,qBAAqB,EAAE;IAE7B,IAAIhB,QACFC,iBAAiBA,kBAAkB,IAC/BgB,SAASC,OAAOjB,gBAAgB,MAChCW,IAAIO,OAAO,CAACC,MAAM,CAACC,YAAY;IACrC,IAAIrB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ,EAAE;QACvCtB,QAAQY,IAAIO,OAAO,CAACC,MAAM,CAACE,QAAQ;IACrC;IAEA,MAAMxB,eAAeC,wBAAwB;4LAE7CN,iBAAAA,EAAe;QACbG;QACAC;QACAC;QACAE;QACAE,KAAKC;QACLC;QACAC;QACAU;QACAQ,QAAQ3B,YAAY2B,UAAUf,QAAQe;QACtCjB;QACAC;QACAC;QACAC;QACAC;QACAc,iBAAiB;QACjBC,mBAAmB;QACnBC,YAAY;QACZC,kBAAkB;QAClBhB;QACAK;QACAJ;QACAC;QACAe,YAAYf,6KAASrB,gBAAAA,EAAcqB,UAAUgB;QAC7Cf;QACAgB,YAAY3B;IACd;IAEA;;;;;GAKC,GACD,IAAI4B,aAAa;IACjB,MAAOhB,cAAciB,MAAM,GAAG,KAAKhB,mBAAmBgB,MAAM,GAAG,EAAG;QAChE,MAAMC,uBAAuBlB,cAAcmB,MAAM,CAAC,GAAGnB,cAAciB,MAAM;QACzE,MAAMG,4BAA4BnB,mBAAmBkB,MAAM,CAAC,GAAGlB,mBAAmBgB,MAAM;QAExF,MAAMI,QAAQC,GAAG,CAACJ;QAClB,MAAMG,QAAQC,GAAG,CAACF;QAElBJ;QACA,IAAIA,cAAc,KAAK;YACrB,MAAM,IAAIO,MACR;QAEJ;IACF;IACA,OAAOnC;AACT","ignoreList":[0]}},
    {"offset": {"line": 1363, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1369, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/validations.ts"],"sourcesContent":["// @ts-strict-ignore\nimport Ajv from 'ajv'\nimport ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nimport type { RichTextAdapter } from '../admin/types.js'\nimport type { CollectionSlug } from '../index.js'\nimport type { Where } from '../types/index.js'\nimport type {\n  ArrayField,\n  BlocksField,\n  CheckboxField,\n  CodeField,\n  DateField,\n  EmailField,\n  JSONField,\n  NumberField,\n  PointField,\n  RadioField,\n  RelationshipField,\n  RelationshipValue,\n  RelationshipValueMany,\n  RelationshipValueSingle,\n  RichTextField,\n  SelectField,\n  TextareaField,\n  TextField,\n  UploadField,\n  Validate,\n} from './config/types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport { isValidID } from '../utilities/isValidID.js'\n\nexport type TextFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport type TextFieldManyValidation = Validate<string[], unknown, unknown, TextField>\n\nexport type TextFieldSingleValidation = Validate<string, unknown, unknown, TextField>\n\nexport const text: TextFieldValidation = (\n  value,\n  {\n    hasMany,\n    maxLength: fieldMaxLength,\n    maxRows,\n    minLength,\n    minRows,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (!required) {\n    if (!value) {\n      return true\n    }\n  }\n\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  const stringsToValidate: string[] = Array.isArray(value) ? value : [value]\n\n  for (const stringValue of stringsToValidate) {\n    const length = stringValue?.length || 0\n\n    if (typeof maxLength === 'number' && length > maxLength) {\n      return t('validation:shorterThanMax', { label: t('general:value'), maxLength, stringValue })\n    }\n\n    if (typeof minLength === 'number' && length < minLength) {\n      return t('validation:longerThanMin', { label: t('general:value'), minLength, stringValue })\n    }\n  }\n\n  if (required) {\n    if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {\n      return t('validation:required')\n    }\n  }\n\n  return true\n}\n\nexport type PasswordFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport const password: PasswordFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength = 3,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type ConfirmPasswordFieldValidation = Validate<\n  string,\n  unknown,\n  { password: string },\n  TextField\n>\n\nexport const confirmPassword: ConfirmPasswordFieldValidation = (\n  value,\n  { req: { t }, required, siblingData },\n) => {\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (value && value !== siblingData.password) {\n    return t('fields:passwordsDoNotMatch')\n  }\n\n  return true\n}\n\nexport type EmailFieldValidation = Validate<string, unknown, { username?: string }, EmailField>\n\nexport const email: EmailFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.username) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if ((value && !/\\S[^\\s@]*@\\S+\\.\\S+/.test(value)) || (!value && required)) {\n    return t('validation:emailAddress')\n  }\n\n  return true\n}\n\nexport type UsernameFieldValidation = Validate<string, unknown, { email?: string }, TextField>\n\nexport const username: UsernameFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  let maxLength: number\n\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.email) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (!value && required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type TextareaFieldValidation = Validate<string, unknown, unknown, TextareaField>\n\nexport const textarea: TextareaFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type CodeFieldValidation = Validate<string, unknown, unknown, CodeField>\n\nexport const code: CodeFieldValidation = (value, { req: { t }, required }) => {\n  if (required && value === undefined) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type JSONFieldValidation = Validate<\n  string,\n  unknown,\n  unknown,\n  { jsonError?: string } & JSONField\n>\n\nexport const json: JSONFieldValidation = async (\n  value,\n  { jsonError, jsonSchema, req: { t }, required },\n) => {\n  const isNotEmpty = (value) => {\n    if (value === undefined || value === null) {\n      return false\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false\n    }\n\n    if (typeof value === 'object' && Object.keys(value).length === 0) {\n      return false\n    }\n\n    return true\n  }\n\n  const fetchSchema = ({ schema, uri }: Record<string, unknown>) => {\n    if (uri && schema) {\n      return schema\n    }\n    // @ts-expect-error\n    return fetch(uri)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok')\n        }\n        return response.json()\n      })\n      .then((json) => {\n        const jsonSchemaSanitizations = {\n          id: undefined,\n          $id: json.id,\n          $schema: 'http://json-schema.org/draft-07/schema#',\n        }\n\n        return Object.assign(json, jsonSchemaSanitizations)\n      })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (jsonError !== undefined) {\n    return t('validation:invalidInput')\n  }\n\n  if (jsonSchema && isNotEmpty(value)) {\n    try {\n      jsonSchema.schema = await fetchSchema(jsonSchema)\n      const { schema } = jsonSchema\n      // @ts-expect-error\n      const ajv = new Ajv()\n\n      if (!ajv.validate(schema, value)) {\n        return t(ajv.errorsText())\n      }\n    } catch (error) {\n      return t(error.message)\n    }\n  }\n  return true\n}\n\nexport type CheckboxFieldValidation = Validate<boolean, unknown, unknown, CheckboxField>\n\nexport const checkbox: CheckboxFieldValidation = (value, { req: { t }, required }) => {\n  if ((value && typeof value !== 'boolean') || (required && typeof value !== 'boolean')) {\n    return t('validation:trueOrFalse')\n  }\n\n  return true\n}\n\nexport type DateFieldValidation = Validate<Date, unknown, unknown, DateField>\n\nexport const date: DateFieldValidation = (\n  value,\n  { name, req: { t }, required, siblingData, timezone },\n) => {\n  const validDate = value && !isNaN(Date.parse(value.toString()))\n\n  // We need to also check for the timezone data based on this field's config\n  // We cannot do this inside the timezone field validation as it's visually hidden\n  const hasRequiredTimezone = timezone && required\n  const selectedTimezone: string = siblingData?.[`${name}_tz`]\n  // Always resolve to true if the field is not required, as timezone may be optional too then\n  const validTimezone = hasRequiredTimezone ? Boolean(selectedTimezone) : true\n\n  if (validDate && validTimezone) {\n    return true\n  }\n\n  if (validDate && !validTimezone) {\n    return t('validation:timezoneRequired')\n  }\n\n  if (value) {\n    return t('validation:notValidDate', { value })\n  }\n\n  if (required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RichTextFieldValidation = Validate<object, unknown, unknown, RichTextField>\n\nexport const richText: RichTextFieldValidation = async (value, options) => {\n  if (!options?.editor) {\n    throw new Error('richText field has no editor property.')\n  }\n  if (typeof options?.editor === 'function') {\n    throw new Error('Attempted to access unsanitized rich text editor.')\n  }\n\n  const editor: RichTextAdapter = options?.editor\n\n  return editor.validate(value, options)\n}\n\nconst validateArrayLength = (\n  value,\n  options: {\n    maxRows?: number\n    minRows?: number\n    required?: boolean\n    t: (key: string, options?: { [key: string]: number | string }) => string\n  },\n) => {\n  const { maxRows, minRows, required, t } = options\n\n  const arrayLength = Array.isArray(value) ? value.length : value || 0\n\n  if (!required && arrayLength === 0) {\n    return true\n  }\n\n  if (minRows && arrayLength < minRows) {\n    return t('validation:requiresAtLeast', { count: minRows, label: t('general:rows') })\n  }\n\n  if (maxRows && arrayLength > maxRows) {\n    return t('validation:requiresNoMoreThan', { count: maxRows, label: t('general:rows') })\n  }\n\n  if (required && !arrayLength) {\n    return t('validation:requiresAtLeast', { count: 1, label: t('general:row') })\n  }\n\n  return true\n}\n\nexport type NumberFieldValidation = Validate<number | number[], unknown, unknown, NumberField>\n\nexport type NumberFieldManyValidation = Validate<number[], unknown, unknown, NumberField>\n\nexport type NumberFieldSingleValidation = Validate<number, unknown, unknown, NumberField>\n\nexport const number: NumberFieldValidation = (\n  value,\n  { hasMany, max, maxRows, min, minRows, req: { t }, required },\n) => {\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (!value && !isNumber(value)) {\n    // if no value is present, validate based on required\n    if (required) {\n      return t('validation:required')\n    }\n    if (!required) {\n      return true\n    }\n  }\n\n  const numbersToValidate: number[] = Array.isArray(value) ? value : [value]\n\n  for (const number of numbersToValidate) {\n    if (!isNumber(number)) {\n      return t('validation:enterNumber')\n    }\n\n    const numberValue = parseFloat(number as unknown as string)\n\n    if (typeof max === 'number' && numberValue > max) {\n      return t('validation:greaterThanMax', { label: t('general:value'), max, value })\n    }\n\n    if (typeof min === 'number' && numberValue < min) {\n      return t('validation:lessThanMin', { label: t('general:value'), min, value })\n    }\n  }\n\n  return true\n}\n\nexport type ArrayFieldValidation = Validate<unknown[], unknown, unknown, ArrayField>\n\nexport const array: ArrayFieldValidation = (value, { maxRows, minRows, req: { t }, required }) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nexport type BlocksFieldValidation = Validate<unknown, unknown, unknown, BlocksField>\n\nexport const blocks: BlocksFieldValidation = (\n  value,\n  { maxRows, minRows, req: { t }, required },\n) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nconst validateFilterOptions: Validate<\n  unknown,\n  unknown,\n  unknown,\n  RelationshipField | UploadField\n> = async (\n  value,\n  { id, blockData, data, filterOptions, relationTo, req, req: { payload, t, user }, siblingData },\n) => {\n  if (typeof filterOptions !== 'undefined' && value) {\n    const options: {\n      [collection: string]: (number | string)[]\n    } = {}\n\n    const falseCollections: CollectionSlug[] = []\n    const collections = !Array.isArray(relationTo) ? [relationTo] : relationTo\n    const values = Array.isArray(value) ? value : [value]\n\n    for (const collection of collections) {\n      try {\n        let optionFilter =\n          typeof filterOptions === 'function'\n            ? await filterOptions({\n                id,\n                blockData,\n                data,\n                relationTo: collection,\n                req,\n                siblingData,\n                user,\n              })\n            : filterOptions\n\n        if (optionFilter === true) {\n          optionFilter = null\n        }\n\n        const valueIDs: (number | string)[] = []\n\n        values.forEach((val) => {\n          if (typeof val === 'object') {\n            if (val?.value) {\n              valueIDs.push(val.value)\n            } else if (ObjectId.isValid(val)) {\n              valueIDs.push(new ObjectId(val).toHexString())\n            }\n          }\n\n          if (typeof val === 'string' || typeof val === 'number') {\n            valueIDs.push(val)\n          }\n        })\n\n        if (valueIDs.length > 0) {\n          const findWhere: Where = {\n            and: [{ id: { in: valueIDs } }],\n          }\n\n          if (optionFilter && optionFilter !== true) {\n            findWhere.and.push(optionFilter)\n          }\n\n          if (optionFilter === false) {\n            falseCollections.push(collection)\n          }\n\n          const result = await payload.find({\n            collection,\n            depth: 0,\n            limit: 0,\n            pagination: false,\n            req,\n            where: findWhere,\n          })\n\n          options[collection] = result.docs.map((doc) => doc.id)\n        } else {\n          options[collection] = []\n        }\n      } catch (err) {\n        req.payload.logger.error({\n          err,\n          msg: `Error validating filter options for collection ${collection}`,\n        })\n        options[collection] = []\n      }\n    }\n\n    const invalidRelationships = values.filter((val) => {\n      let collection: string\n      let requestedID: number | string\n\n      if (typeof relationTo === 'string') {\n        collection = relationTo\n\n        if (typeof val === 'string' || typeof val === 'number') {\n          requestedID = val\n        }\n\n        if (typeof val === 'object' && ObjectId.isValid(val)) {\n          requestedID = new ObjectId(val).toHexString()\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collection = val.relationTo\n        requestedID = val.value\n      }\n\n      if (falseCollections.find((slug) => relationTo === slug)) {\n        return true\n      }\n\n      if (!options[collection]) {\n        return true\n      }\n\n      return options[collection].indexOf(requestedID) === -1\n    })\n\n    if (invalidRelationships.length > 0) {\n      return invalidRelationships.reduce((err, invalid, i) => {\n        return `${err} ${JSON.stringify(invalid)}${\n          invalidRelationships.length === i + 1 ? ',' : ''\n        } `\n      }, t('validation:invalidSelections')) as string\n    }\n\n    return true\n  }\n\n  return true\n}\n\nexport type UploadFieldValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport type UploadFieldManyValidation = Validate<unknown[], unknown, unknown, UploadField>\n\nexport type UploadFieldSingleValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport const upload: UploadFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type RelationshipFieldValidation = Validate<\n  RelationshipValue,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldManyValidation = Validate<\n  RelationshipValueMany,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldSingleValidation = Validate<\n  RelationshipValueSingle,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport const relationship: RelationshipFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type SelectFieldValidation = Validate<string | string[], unknown, unknown, SelectField>\n\nexport type SelectFieldManyValidation = Validate<string[], unknown, unknown, SelectField>\n\nexport type SelectFieldSingleValidation = Validate<string, unknown, unknown, SelectField>\n\nexport const select: SelectFieldValidation = (\n  value,\n  { hasMany, options, req: { t }, required },\n) => {\n  if (\n    Array.isArray(value) &&\n    value.some(\n      (input) =>\n        !options.some(\n          (option) => option === input || (typeof option !== 'string' && option?.value === input),\n        ),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    typeof value === 'string' &&\n    !options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    required &&\n    (typeof value === 'undefined' ||\n      value === null ||\n      (hasMany && Array.isArray(value) && (value as [])?.length === 0))\n  ) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RadioFieldValidation = Validate<unknown, unknown, unknown, RadioField>\n\nexport const radio: RadioFieldValidation = (value, { options, req: { t }, required }) => {\n  if (value) {\n    const valueMatchesOption = options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n    return valueMatchesOption || t('validation:invalidSelection')\n  }\n\n  return required ? t('validation:required') : true\n}\n\nexport type PointFieldValidation = Validate<\n  [number | string, number | string],\n  unknown,\n  unknown,\n  PointField\n>\n\nexport const point: PointFieldValidation = (value = ['', ''], { req: { t }, required }) => {\n  const lng = parseFloat(String(value[0]))\n  const lat = parseFloat(String(value[1]))\n  if (\n    required &&\n    ((value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number') ||\n      Number.isNaN(lng) ||\n      Number.isNaN(lat) ||\n      (Array.isArray(value) && value.length !== 2))\n  ) {\n    return t('validation:requiresTwoNumbers')\n  }\n\n  if ((value[1] && Number.isNaN(lng)) || (value[0] && Number.isNaN(lat))) {\n    return t('validation:invalidInput')\n  }\n\n  return true\n}\n\n/**\n * Built-in field validations used by Payload\n *\n * These can be re-used in custom validations\n */\nexport const validations = {\n  array,\n  blocks,\n  checkbox,\n  code,\n  confirmPassword,\n  date,\n  email,\n  json,\n  number,\n  password,\n  point,\n  radio,\n  relationship,\n  richText,\n  select,\n  text,\n  textarea,\n  upload,\n}\n"],"names":["Ajv","ObjectIdImport","ObjectId","default","isNumber","isValidID","text","value","hasMany","maxLength","fieldMaxLength","maxRows","minLength","minRows","req","payload","config","t","required","lengthValidationResult","validateArrayLength","defaultMaxTextLength","stringsToValidate","Array","isArray","stringValue","length","label","password","confirmPassword","siblingData","email","collectionSlug","collections","collection","find","slug","auth","loginWithUsername","requireUsername","requireEmail","username","test","textarea","code","undefined","json","jsonError","jsonSchema","isNotEmpty","Object","keys","fetchSchema","schema","uri","fetch","then","response","ok","Error","jsonSchemaSanitizations","id","$id","$schema","assign","ajv","validate","errorsText","error","message","checkbox","date","name","timezone","validDate","isNaN","Date","parse","toString","hasRequiredTimezone","selectedTimezone","validTimezone","Boolean","richText","options","editor","arrayLength","count","number","max","min","numbersToValidate","numberValue","parseFloat","array","blocks","validateFilterOptions","blockData","data","filterOptions","relationTo","user","falseCollections","values","optionFilter","valueIDs","forEach","val","push","isValid","toHexString","findWhere","and","in","result","depth","limit","pagination","where","docs","map","doc","err","logger","msg","invalidRelationships","filter","requestedID","indexOf","reduce","invalid","i","JSON","stringify","upload","event","idType","customIDType","db","defaultIDType","join","relationship","select","some","input","option","radio","valueMatchesOption","point","lng","String","lat","Number","validations"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2004, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2010, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/baseFields/baseIDField.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { TextField } from '../config/types.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport const baseIDField: TextField = {\n  name: 'id',\n  type: 'text',\n  admin: {\n    hidden: true,\n  },\n  defaultValue: () => new ObjectId().toHexString(),\n  hooks: {\n    beforeChange: [({ value }) => value || new ObjectId().toHexString()],\n    beforeDuplicate: [() => new ObjectId().toHexString()],\n  },\n  label: 'ID',\n}\n"],"names":["ObjectIdImport","ObjectId","default","baseIDField","name","type","admin","hidden","defaultValue","toHexString","hooks","beforeChange","value","beforeDuplicate","label"],"mappings":";;;AAAA,OAAOA,oBAAoB,gBAAe;;AAI1C,MAAMC,0JAAYD,UAAAA,CAAeE,OAAO,mJACtCF,UAAAA;AAEK,MAAMG,cAAyB;IACpCC,MAAM;IACNC,MAAM;IACNC,OAAO;QACLC,QAAQ;IACV;IACAC,cAAc,IAAM,IAAIP,WAAWQ,WAAW;IAC9CC,OAAO;QACLC,cAAc;YAAC,CAAC,EAAEC,KAAK,EAAE,GAAKA,SAAS,IAAIX,WAAWQ,WAAW;SAAG;QACpEI,iBAAiB;YAAC,IAAM,IAAIZ,WAAWQ,WAAW;SAAG;IACvD;IACAK,OAAO;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2033, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2039, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/baseFields/baseBlockFields.ts"],"sourcesContent":["import type { Field } from '../config/types.js'\n\nimport { baseIDField } from './baseIDField.js'\n\nexport const baseBlockFields: Field[] = [\n  baseIDField,\n  {\n    name: 'blockName',\n    type: 'text',\n    admin: {\n      disabled: true,\n    },\n    label: 'Block Name',\n    required: false,\n  },\n]\n"],"names":["baseIDField","baseBlockFields","name","type","admin","disabled","label","required"],"mappings":";;;AAEA,SAASA,WAAW,QAAQ,mBAAkB;;AAEvC,MAAMC,kBAA2B;6KACtCD,cAAAA;IACA;QACEE,MAAM;QACNC,MAAM;QACNC,OAAO;YACLC,UAAU;QACZ;QACAC,OAAO;QACPC,UAAU;IACZ;CACD,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2056, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/config/sanitizeJoinField.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedJoin, SanitizedJoins } from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\n\nimport { APIError } from '../../errors/index.js'\nimport { InvalidFieldJoin } from '../../errors/InvalidFieldJoin.js'\nimport { traverseFields } from '../../utilities/traverseFields.js'\nimport {\n  fieldShouldBeLocalized,\n  type FlattenedJoinField,\n  type JoinField,\n  type RelationshipField,\n  type UploadField,\n} from './types.js'\nexport const sanitizeJoinField = ({\n  config,\n  field,\n  joinPath,\n  joins,\n  parentIsLocalized,\n  polymorphicJoins,\n  validateOnly,\n}: {\n  config: Config\n  field: FlattenedJoinField | JoinField\n  joinPath?: string\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n  polymorphicJoins?: SanitizedJoin[]\n  validateOnly?: boolean\n}) => {\n  // the `joins` arg is not passed for globals or when recursing on fields that do not allow a join field\n  if (typeof joins === 'undefined') {\n    throw new APIError('Join fields cannot be added to arrays, blocks or globals.')\n  }\n  if (typeof field.maxDepth === 'undefined') {\n    field.maxDepth = 1\n  }\n  const join: SanitizedJoin = {\n    field,\n    joinPath: `${joinPath ? joinPath + '.' : ''}${field.name}`,\n    parentIsLocalized,\n    targetField: undefined,\n  }\n\n  if (Array.isArray(field.collection)) {\n    for (const collection of field.collection) {\n      const sanitizedField = {\n        ...field,\n        collection,\n      } as FlattenedJoinField\n\n      sanitizeJoinField({\n        config,\n        field: sanitizedField,\n        joinPath,\n        joins,\n        parentIsLocalized,\n        polymorphicJoins,\n        validateOnly: true,\n      })\n    }\n\n    if (Array.isArray(polymorphicJoins)) {\n      polymorphicJoins.push(join)\n    }\n\n    return\n  }\n\n  const joinCollection = config.collections.find(\n    (collection) => collection.slug === field.collection,\n  )\n  if (!joinCollection) {\n    throw new InvalidFieldJoin(field)\n  }\n  let joinRelationship: RelationshipField | UploadField\n\n  const pathSegments = field.on.split('.') // Split the schema path into segments\n  let currentSegmentIndex = 0\n\n  let localized = false\n  // Traverse fields and match based on the schema path\n  traverseFields({\n    callback: ({ field, next, parentIsLocalized }) => {\n      if (!('name' in field) || !field.name) {\n        return\n      }\n      const currentSegment = pathSegments[currentSegmentIndex]\n      // match field on path segments\n      if ('name' in field && field.name === currentSegment) {\n        if (fieldShouldBeLocalized({ field, parentIsLocalized })) {\n          localized = true\n          const fieldIndex = currentSegmentIndex\n\n          join.getForeignPath = ({ locale }) => {\n            return pathSegments.reduce((acc, segment, index) => {\n              let result = `${acc}${segment}`\n\n              if (index === fieldIndex) {\n                result = `${result}.${locale}`\n              }\n\n              if (index !== pathSegments.length - 1) {\n                result = `${result}.`\n              }\n\n              return result\n            }, '')\n          }\n        }\n\n        // Check if this is the last segment in the path\n        if (\n          (currentSegmentIndex === pathSegments.length - 1 &&\n            'type' in field &&\n            field.type === 'relationship') ||\n          field.type === 'upload'\n        ) {\n          joinRelationship = field // Return the matched field\n          next()\n          return true\n        } else {\n          // Move to the next path segment and continue traversal\n          currentSegmentIndex++\n        }\n      } else {\n        // skip fields in non-matching path segments\n        next()\n        return\n      }\n    },\n    config: config as unknown as SanitizedConfig,\n    fields: joinCollection.fields,\n    parentIsLocalized: false,\n  })\n\n  if (!joinRelationship) {\n    throw new InvalidFieldJoin(join.field)\n  }\n\n  if (validateOnly) {\n    return\n  }\n\n  join.targetField = joinRelationship\n\n  // override the join field localized property to use whatever the relationship field has\n  // or if it's nested to a localized array / blocks / tabs / group\n  field.localized = localized\n  // override the join field hasMany property to use whatever the relationship field has\n  field.hasMany = joinRelationship.hasMany\n\n  // @ts-expect-error converting JoinField to FlattenedJoinField to track targetField\n  field.targetField = join.targetField\n\n  if (!joins[field.collection]) {\n    joins[field.collection] = [join]\n  } else {\n    joins[field.collection].push(join)\n  }\n}\n"],"names":["APIError","InvalidFieldJoin","traverseFields","fieldShouldBeLocalized","sanitizeJoinField","config","field","joinPath","joins","parentIsLocalized","polymorphicJoins","validateOnly","maxDepth","join","name","targetField","undefined","Array","isArray","collection","sanitizedField","push","joinCollection","collections","find","slug","joinRelationship","pathSegments","on","split","currentSegmentIndex","localized","callback","next","currentSegment","fieldIndex","getForeignPath","locale","reduce","acc","segment","index","result","length","type","fields","hasMany"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2194, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/setDefaultBeforeDuplicate.ts"],"sourcesContent":["// @ts-strict-ignore\n// default beforeDuplicate hook for required and unique fields\nimport { type FieldAffectingData, type FieldHook, fieldShouldBeLocalized } from './config/types.js'\n\nconst unique: FieldHook = ({ value }) => (typeof value === 'string' ? `${value} - Copy` : undefined)\nconst localizedUnique: FieldHook = ({ req, value }) =>\n  value ? `${value} - ${req?.t('general:copy') ?? 'Copy'}` : undefined\nconst uniqueRequired: FieldHook = ({ value }) => `${value} - Copy`\nconst localizedUniqueRequired: FieldHook = ({ req, value }) =>\n  `${value} - ${req?.t('general:copy') ?? 'Copy'}`\n\nexport const setDefaultBeforeDuplicate = (\n  field: FieldAffectingData,\n  parentIsLocalized: boolean,\n) => {\n  if (\n    (('required' in field && field.required) || field.unique) &&\n    (!field.hooks?.beforeDuplicate ||\n      (Array.isArray(field.hooks.beforeDuplicate) && field.hooks.beforeDuplicate.length === 0))\n  ) {\n    if ((field.type === 'text' || field.type === 'textarea') && field.required && field.unique) {\n      field.hooks.beforeDuplicate = [\n        fieldShouldBeLocalized({ field, parentIsLocalized })\n          ? localizedUniqueRequired\n          : uniqueRequired,\n      ]\n    } else if (field.unique) {\n      field.hooks.beforeDuplicate = [\n        fieldShouldBeLocalized({ field, parentIsLocalized }) ? localizedUnique : unique,\n      ]\n    }\n  }\n}\n"],"names":["fieldShouldBeLocalized","unique","value","undefined","localizedUnique","req","t","uniqueRequired","localizedUniqueRequired","setDefaultBeforeDuplicate","field","parentIsLocalized","required","hooks","beforeDuplicate","Array","isArray","length","type"],"mappings":"AAAA,oBAAoB;AACpB,8DAA8D;;;;AAC9D,SAAkDA,sBAAsB,QAAQ,oBAAmB;;AAEnG,MAAMC,SAAoB,CAAC,EAAEC,KAAK,EAAE,GAAM,OAAOA,UAAU,WAAW,GAAGA,MAAM,OAAO,CAAC,GAAGC;AAC1F,MAAMC,kBAA6B,CAAC,EAAEC,GAAG,EAAEH,KAAK,EAAE,GAChDA,QAAQ,GAAGA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,QAAQ,GAAGH;AAC7D,MAAMI,iBAA4B,CAAC,EAAEL,KAAK,EAAE,GAAK,GAAGA,MAAM,OAAO,CAAC;AAClE,MAAMM,0BAAqC,CAAC,EAAEH,GAAG,EAAEH,KAAK,EAAE,GACxD,GAAGA,MAAM,GAAG,EAAEG,KAAKC,EAAE,mBAAmB,QAAQ;AAE3C,MAAMG,4BAA4B,CACvCC,OACAC;IAEA,IACG,CAAC,cAAcD,SAASA,MAAME,QAAQ,IAAKF,MAAMT,MAAK,KACtD,CAAA,CAACS,MAAMG,KAAK,EAAEC,mBACZC,MAAMC,OAAO,CAACN,MAAMG,KAAK,CAACC,eAAe,KAAKJ,MAAMG,KAAK,CAACC,eAAe,CAACG,MAAM,KAAK,CAAC,GACzF;QACA,IAAKP,CAAAA,MAAMQ,IAAI,KAAK,UAAUR,MAAMQ,IAAI,KAAK,UAAS,KAAMR,MAAME,QAAQ,IAAIF,MAAMT,MAAM,EAAE;YAC1FS,MAAMG,KAAK,CAACC,eAAe,GAAG;mLAC5Bd,yBAAAA,EAAuB;oBAAEU;oBAAOC;gBAAkB,KAC9CH,0BACAD;aACL;QACH,OAAO,IAAIG,MAAMT,MAAM,EAAE;YACvBS,MAAMG,KAAK,CAACC,eAAe,GAAG;mLAC5Bd,yBAAAA,EAAuB;oBAAEU;oBAAOC;gBAAkB,KAAKP,kBAAkBH;aAC1E;QACH;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2224, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2230, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/baseFields/timezone/baseField.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SelectField } from '../../config/types.js'\n\nexport const baseTimezoneField: (args: Partial<SelectField>) => SelectField = ({\n  name,\n  defaultValue,\n  options,\n  required,\n}) => {\n  return {\n    name,\n    type: 'select',\n    admin: {\n      hidden: true,\n    },\n    defaultValue,\n    options,\n    required,\n  }\n}\n"],"names":["baseTimezoneField","name","defaultValue","options","required","type","admin","hidden"],"mappings":"AAAA,oBAAoB;;;;AAGb,MAAMA,oBAAiE,CAAC,EAC7EC,IAAI,EACJC,YAAY,EACZC,OAAO,EACPC,QAAQ,EACT;IACC,OAAO;QACLH;QACAI,MAAM;QACNC,OAAO;YACLC,QAAQ;QACV;QACAL;QACAC;QACAC;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2246, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2252, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/config/sanitize.ts"],"sourcesContent":["// @ts-strict-ignore\nimport { deepMergeSimple } from '@payloadcms/translations/utilities'\n\nimport type {\n  CollectionConfig,\n  SanitizedJoin,\n  SanitizedJoins,\n} from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { Field } from './types.js'\n\nimport {\n  DuplicateFieldName,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingEditorProp,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { baseTimezoneField } from '../baseFields/timezone/baseField.js'\nimport { defaultTimezones } from '../baseFields/timezone/defaultTimezones.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport { validations } from '../validations.js'\nimport { sanitizeJoinField } from './sanitizeJoinField.js'\nimport { fieldAffectsData, fieldIsLocalized, tabHasName } from './types.js'\n\ntype Args = {\n  collectionConfig?: CollectionConfig\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  joinPath?: string\n  /**\n   * When not passed in, assume that join are not supported (globals, arrays, blocks)\n   */\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n  polymorphicJoins?: SanitizedJoin[]\n\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nexport const sanitizeFields = async ({\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  joinPath = '',\n  joins,\n  parentIsLocalized,\n  polymorphicJoins,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) {\n    return []\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    if ('_sanitized' in field && field._sanitized === true) {\n      continue\n    }\n\n    if (!field.type) {\n      throw new MissingFieldType(field)\n    }\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData(field) && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'join') {\n      sanitizeJoinField({ config, field, joinPath, joins, parentIsLocalized, polymorphicJoins })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.min && !field.minRows) {\n        console.warn(\n          `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n        )\n        field.minRows = field.min\n      }\n      if (field.max && !field.maxRows) {\n        console.warn(\n          `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n        )\n        field.maxRows = field.max\n      }\n    }\n\n    if (field.type === 'upload') {\n      if (!field.admin || !('isSortable' in field.admin)) {\n        field.admin = {\n          isSortable: true,\n          ...field.admin,\n        }\n      }\n    }\n\n    if (field.type === 'array' && field.fields) {\n      field.fields.push(baseIDField)\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData(field)) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (typeof field.localized !== 'undefined') {\n        let shouldDisableLocalized = !config.localization\n\n        if (\n          process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized !== 'true' &&\n          parentIsLocalized &&\n          // @todo PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY=true will be the default in 4.0\n          process.env.PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY !== 'true'\n        ) {\n          shouldDisableLocalized = true\n        }\n\n        if (shouldDisableLocalized) {\n          delete field.localized\n        }\n      }\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type]\n        if (defaultValidate) {\n          field.validate = (val, options) => defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = (): true => true\n        }\n      }\n\n      if (!field.hooks) {\n        field.hooks = {}\n      }\n      if (!field.access) {\n        field.access = {}\n      }\n\n      setDefaultBeforeDuplicate(field, parentIsLocalized)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n            parentIsLocalized: parentIsLocalized || field.localized,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n.translations = deepMergeSimple(config.i18n.translations, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      if (field.blockReferences && field.blocks?.length) {\n        throw new Error('You cannot have both blockReferences and blocks in the same blocks field')\n      }\n\n      for (const block of field.blockReferences ?? field.blocks) {\n        if (typeof block === 'string') {\n          continue\n        }\n        if (block._sanitized === true) {\n          continue\n        }\n        block._sanitized = true\n        block.fields = block.fields.concat(baseBlockFields)\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n        block.fields = await sanitizeFields({\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        config,\n        existingFieldNames: fieldAffectsData(field) ? new Set() : existingFieldNames,\n        fields: field.fields,\n        joinPath: fieldAffectsData(field)\n          ? `${joinPath ? joinPath + '.' : ''}${field.name}`\n          : joinPath,\n        joins,\n        parentIsLocalized: parentIsLocalized || fieldIsLocalized(field),\n        polymorphicJoins,\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]\n        if (tabHasName(tab) && typeof tab.label === 'undefined') {\n          tab.label = toWords(tab.name)\n        }\n\n        tab.fields = await sanitizeFields({\n          config,\n          existingFieldNames: tabHasName(tab) ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          joinPath: tabHasName(tab) ? `${joinPath ? joinPath + '.' : ''}${tab.name}` : joinPath,\n          joins,\n          parentIsLocalized: parentIsLocalized || (tabHasName(tab) && tab.localized),\n          polymorphicJoins,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n        field.tabs[j] = tab\n      }\n    }\n\n    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {\n      field.admin.disableBulkEdit = true\n    }\n\n    if ('_sanitized' in field) {\n      field._sanitized = true\n    }\n\n    fields[i] = field\n\n    // Insert our field after assignment\n    if (field.type === 'date' && field.timezone) {\n      const name = field.name + '_tz'\n      const defaultTimezone = config.admin.timezones.defaultTimezone\n\n      const supportedTimezones = config.admin.timezones.supportedTimezones\n\n      const options =\n        typeof supportedTimezones === 'function'\n          ? supportedTimezones({ defaultTimezones })\n          : supportedTimezones\n\n      // Need to set the options here manually so that any database enums are generated correctly\n      // The UI component will import the options from the config\n      const timezoneField = baseTimezoneField({\n        name,\n        defaultValue: defaultTimezone,\n        options,\n        required: field.required,\n      })\n\n      fields.splice(++i, 0, timezoneField)\n    }\n  }\n\n  return fields\n}\n"],"names":["deepMergeSimple","DuplicateFieldName","InvalidFieldName","InvalidFieldRelationship","MissingEditorProp","MissingFieldType","formatLabels","toWords","baseBlockFields","baseIDField","baseTimezoneField","defaultTimezones","setDefaultBeforeDuplicate","validations","sanitizeJoinField","fieldAffectsData","fieldIsLocalized","tabHasName","sanitizeFields","config","existingFieldNames","Set","fields","joinPath","joins","parentIsLocalized","polymorphicJoins","requireFieldLevelRichTextEditor","richTextSanitizationPromises","validRelationships","i","length","field","_sanitized","type","name","includes","label","defaultValue","required","relationships","Array","isArray","relationTo","forEach","relationship","min","minRows","console","warn","max","maxRows","admin","isSortable","push","labels","has","add","localized","shouldDisableLocalized","localization","process","env","NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized","PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY","validate","defaultValidate","val","options","hooks","access","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","blocks","blockReferences","Error","block","concat","slug","j","tabs","tab","disableBulkEdit","timezone","defaultTimezone","timezones","supportedTimezones","timezoneField","splice"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2508, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2514, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeDuplicate/runHook.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { FieldHookArgs } from '../../config/types.js'\n\nexport const runBeforeDuplicateHooks = async (args: FieldHookArgs) =>\n  await args.field.hooks.beforeDuplicate.reduce(async (priorHook, currentHook) => {\n    await priorHook\n    return await currentHook(args)\n  }, Promise.resolve())\n"],"names":["runBeforeDuplicateHooks","args","field","hooks","beforeDuplicate","reduce","priorHook","currentHook","Promise","resolve"],"mappings":"AAAA,oBAAoB;;;;AAGb,MAAMA,0BAA0B,OAAOC,OAC5C,MAAMA,KAAKC,KAAK,CAACC,KAAK,CAACC,eAAe,CAACC,MAAM,CAAC,OAAOC,WAAWC;QAC9D,MAAMD;QACN,OAAO,MAAMC,YAAYN;IAC3B,GAAGO,QAAQC,OAAO,IAAG","ignoreList":[0]}},
    {"offset": {"line": 2522, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2528, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeDuplicate/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, FieldHookArgs, TabAsField } from '../../config/types.js'\n\nimport { fieldAffectsData, fieldShouldBeLocalized } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { runBeforeDuplicateHooks } from './runHook.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  id?: number | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\nexport const promise = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  doc,\n  field,\n  fieldIndex,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingDoc,\n  siblingFields,\n}: Args<T>): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const { localization } = req.payload.config\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    let fieldData = siblingDoc?.[field.name]\n    const fieldIsLocalized = localization && fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    // Run field beforeDuplicate hooks\n    if (Array.isArray(field.hooks?.beforeDuplicate)) {\n      if (fieldIsLocalized) {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n\n            const beforeDuplicateArgs: FieldHookArgs = {\n              blockData,\n              collection,\n              context,\n              data: doc,\n              field,\n              global: undefined,\n              indexPath: indexPathSegments,\n              path: pathSegments,\n              previousSiblingDoc: siblingDoc,\n              previousValue: siblingDoc[field.name]?.[locale],\n              req,\n              schemaPath: schemaPathSegments,\n              siblingData: siblingDoc,\n              siblingDocWithLocales: siblingDoc,\n              siblingFields,\n              value: siblingDoc[field.name]?.[locale],\n            }\n\n            const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n\n            if (typeof hookResult !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: hookResult,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        siblingDoc[field.name] = localeData\n      } else {\n        const beforeDuplicateArgs: FieldHookArgs = {\n          blockData,\n          collection,\n          context,\n          data: doc,\n          field,\n          global: undefined,\n          indexPath: indexPathSegments,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData: siblingDoc,\n          siblingDocWithLocales: siblingDoc,\n          siblingFields,\n          value: siblingDoc[field.name],\n        }\n\n        const hookResult = await runBeforeDuplicateHooks(beforeDuplicateArgs)\n        if (typeof hookResult !== 'undefined') {\n          siblingDoc[field.name] = hookResult\n        }\n      }\n    }\n\n    // First, for any localized fields, we will loop over locales\n    // and if locale data is present, traverse the sub fields.\n    // There are only a few different fields where this is possible.\n    if (fieldIsLocalized) {\n      if (typeof fieldData !== 'object' || fieldData === null) {\n        siblingDoc[field.name] = {}\n        fieldData = siblingDoc[field.name]\n      }\n\n      const promises = []\n\n      localization.localeCodes.forEach((locale) => {\n        if (fieldData[locale]) {\n          switch (field.type) {\n            case 'array': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n\n                rows.forEach((row, rowIndex) => {\n                  promises.push(\n                    traverseFields({\n                      id,\n                      blockData,\n                      collection,\n                      context,\n                      doc,\n                      fields: field.fields,\n                      overrideAccess,\n                      parentIndexPath: '',\n                      parentIsLocalized: parentIsLocalized || field.localized,\n                      parentPath: path + '.' + rowIndex,\n                      parentSchemaPath: schemaPath,\n                      req,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n\n              break\n            }\n\n            case 'blocks': {\n              const rows = fieldData[locale]\n\n              if (Array.isArray(rows)) {\n                const promises = []\n\n                rows.forEach((row, rowIndex) => {\n                  const blockTypeToMatch = row.blockType\n\n                  const block: Block | undefined =\n                    req.payload.blocks[blockTypeToMatch] ??\n                    ((field.blockReferences ?? field.blocks).find(\n                      (curBlock) =>\n                        typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                    ) as Block | undefined)\n\n                  promises.push(\n                    traverseFields({\n                      id,\n                      blockData: row,\n                      collection,\n                      context,\n                      doc,\n                      fields: block.fields,\n                      overrideAccess,\n                      parentIndexPath: '',\n                      parentIsLocalized: parentIsLocalized || field.localized,\n                      parentPath: path + '.' + rowIndex,\n                      parentSchemaPath: schemaPath + '.' + block.slug,\n                      req,\n                      siblingDoc: row,\n                    }),\n                  )\n                })\n              }\n              break\n            }\n\n            case 'group':\n            case 'tab': {\n              promises.push(\n                traverseFields({\n                  id,\n                  blockData,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  parentPath: path,\n                  parentSchemaPath: schemaPath,\n                  req,\n                  siblingDoc: fieldData[locale],\n                }),\n              )\n\n              break\n            }\n          }\n        }\n      })\n\n      await Promise.all(promises)\n    } else {\n      // If the field is not localized, but it affects data,\n      // we need to further traverse its children\n      // so the child fields can run beforeDuplicate hooks\n      switch (field.type) {\n        case 'array': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n\n            rows.forEach((row, rowIndex) => {\n              promises.push(\n                traverseFields({\n                  id,\n                  blockData,\n                  collection,\n                  context,\n                  doc,\n                  fields: field.fields,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath,\n                  req,\n                  siblingDoc: row,\n                }),\n              )\n            })\n\n            await Promise.all(promises)\n          }\n\n          break\n        }\n\n        case 'blocks': {\n          const rows = siblingDoc[field.name]\n\n          if (Array.isArray(rows)) {\n            const promises = []\n\n            rows.forEach((row, rowIndex) => {\n              const blockTypeToMatch = row.blockType\n\n              const block: Block | undefined =\n                req.payload.blocks[blockTypeToMatch] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                ) as Block | undefined)\n\n              if (block) {\n                ;(row as JsonObject).blockType = blockTypeToMatch\n\n                promises.push(\n                  traverseFields({\n                    id,\n                    blockData: row,\n                    collection,\n                    context,\n                    doc,\n                    fields: block.fields,\n                    overrideAccess,\n                    parentIndexPath: '',\n                    parentIsLocalized: parentIsLocalized || field.localized,\n                    parentPath: path + '.' + rowIndex,\n                    parentSchemaPath: schemaPath + '.' + block.slug,\n                    req,\n                    siblingDoc: row,\n                  }),\n                )\n              }\n            })\n\n            await Promise.all(promises)\n          }\n\n          break\n        }\n\n        case 'group': {\n          if (typeof siblingDoc[field.name] !== 'object') {\n            siblingDoc[field.name] = {}\n          }\n\n          const groupDoc = siblingDoc[field.name] as JsonObject\n\n          await traverseFields({\n            id,\n            blockData,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            req,\n            siblingDoc: groupDoc,\n          })\n\n          break\n        }\n\n        case 'tab': {\n          if (typeof siblingDoc[field.name] !== 'object') {\n            siblingDoc[field.name] = {}\n          }\n\n          const tabDoc = siblingDoc[field.name] as JsonObject\n\n          await traverseFields({\n            id,\n            blockData,\n            collection,\n            context,\n            doc,\n            fields: field.fields,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path,\n            parentSchemaPath: schemaPath,\n            req,\n            siblingDoc: tabDoc,\n          })\n\n          break\n        }\n      }\n    }\n  } else {\n    // Finally, we traverse fields which do not affect data here\n    switch (field.type) {\n      case 'collapsible':\n      case 'row': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          fields: field.fields,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      // Unnamed Tab\n      // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField\n      case 'tab': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          // @ts-expect-error `fieldAffectsData` inferred return type doesn't account for TabAsField\n          fields: field.fields,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      case 'tabs': {\n        await traverseFields({\n          id,\n          blockData,\n          collection,\n          context,\n          doc,\n          fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          req,\n          siblingDoc,\n        })\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n  }\n}\n"],"names":["fieldAffectsData","fieldShouldBeLocalized","getFieldPathsModified","getFieldPaths","runBeforeDuplicateHooks","traverseFields","promise","id","blockData","collection","context","doc","field","fieldIndex","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingDoc","siblingFields","indexPath","path","schemaPath","index","localization","payload","config","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","fieldData","name","fieldIsLocalized","Array","isArray","hooks","beforeDuplicate","localeData","localeCodes","reduce","localizedValuesPromise","locale","localizedValues","beforeDuplicateArgs","data","global","undefined","previousSiblingDoc","previousValue","siblingData","siblingDocWithLocales","value","hookResult","Promise","resolve","promises","forEach","type","rows","row","rowIndex","push","fields","localized","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","slug","all","groupDoc","tabDoc","tabs","tab"],"mappings":"AAAA,oBAAoB;;;;AAOpB,SAASE,yBAAyBC,aAAa,QAAQ,yBAAwB;AAD/E,SAASH,gBAAgB,EAAEC,sBAAsB,QAAQ,wBAAuB;AAGhF,SAASI,cAAc,QAAQ,sBAAqB;AADpD,SAASD,uBAAuB,QAAQ,eAAc;;;;;AAwB/C,MAAME,UAAU,OAAU,EAC/BC,EAAE,EACFC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,KAAK,EACLC,UAAU,EACVC,cAAc,EACdC,eAAe,EACfC,iBAAiB,EACjBC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,UAAU,EACVC,aAAa,EACL;IACR,MAAM,EAAEC,SAAS,EAAEC,IAAI,EAAEC,UAAU,EAAE,oKAAGrB,wBAAAA,EAAc;QACpDS;QACAa,OAAOZ;QACPE;QACAE;QACAC;IACF;IAEA,MAAM,EAAEQ,YAAY,EAAE,GAAGP,IAAIQ,OAAO,CAACC,MAAM;IAE3C,MAAMC,eAAeN,OAAOA,KAAKO,KAAK,CAAC,OAAO,EAAE;IAChD,MAAMC,qBAAqBP,aAAaA,WAAWM,KAAK,CAAC,OAAO,EAAE;IAClE,MAAME,oBAAoBV,YAAYA,UAAUQ,KAAK,CAAC,KAAKG,MAAM,CAACC,UAAUC,IAAIC,UAAU,EAAE;IAE5F,IAAIpC,sLAAAA,EAAiBY,QAAQ;QAC3B,IAAIyB,YAAYjB,YAAY,CAACR,MAAM0B,IAAI,CAAC;QACxC,MAAMC,mBAAmBb,mLAAgBzB,yBAAAA,EAAuB;YAAEW;YAAOI;QAAkB;QAE3F,kCAAkC;QAClC,IAAIwB,MAAMC,OAAO,CAAC7B,MAAM8B,KAAK,EAAEC,kBAAkB;YAC/C,IAAIJ,kBAAkB;gBACpB,MAAMK,aAAa,MAAMlB,aAAamB,WAAW,CAACC,MAAM,CACtD,OAAOC,wBAA6CC;oBAClD,MAAMC,kBAAkB,MAAMF;oBAE9B,MAAMG,sBAAqC;wBACzC1C;wBACAC;wBACAC;wBACAyC,MAAMxC;wBACNC;wBACAwC,QAAQC;wBACR/B,WAAWU;wBACXT,MAAMM;wBACNyB,oBAAoBlC;wBACpBmC,eAAenC,UAAU,CAACR,MAAM0B,IAAI,CAAC,EAAE,CAACU,OAAO;wBAC/C7B;wBACAK,YAAYO;wBACZyB,aAAapC;wBACbqC,uBAAuBrC;wBACvBC;wBACAqC,OAAOtC,UAAU,CAACR,MAAM0B,IAAI,CAAC,EAAE,CAACU,OAAO;oBACzC;oBAEA,MAAMW,aAAa,6LAAMvD,0BAAAA,EAAwB8C;oBAEjD,IAAI,OAAOS,eAAe,aAAa;wBACrC,OAAO;4BACL,GAAGV,eAAe;4BAClB,CAACD,OAAO,EAAEW;wBACZ;oBACF;oBAEA,OAAOZ;gBACT,GACAa,QAAQC,OAAO,CAAC,CAAC;gBAGnBzC,UAAU,CAACR,MAAM0B,IAAI,CAAC,GAAGM;YAC3B,OAAO;gBACL,MAAMM,sBAAqC;oBACzC1C;oBACAC;oBACAC;oBACAyC,MAAMxC;oBACNC;oBACAwC,QAAQC;oBACR/B,WAAWU;oBACXT,MAAMM;oBACNyB,oBAAoBlC;oBACpBmC,eAAenC,UAAU,CAACR,MAAM0B,IAAI,CAAC;oBACrCnB;oBACAK,YAAYO;oBACZyB,aAAapC;oBACbqC,uBAAuBrC;oBACvBC;oBACAqC,OAAOtC,UAAU,CAACR,MAAM0B,IAAI,CAAC;gBAC/B;gBAEA,MAAMqB,aAAa,6LAAMvD,0BAAAA,EAAwB8C;gBACjD,IAAI,OAAOS,eAAe,aAAa;oBACrCvC,UAAU,CAACR,MAAM0B,IAAI,CAAC,GAAGqB;gBAC3B;YACF;QACF;QAEA,6DAA6D;QAC7D,0DAA0D;QAC1D,gEAAgE;QAChE,IAAIpB,kBAAkB;YACpB,IAAI,OAAOF,cAAc,YAAYA,cAAc,MAAM;gBACvDjB,UAAU,CAACR,MAAM0B,IAAI,CAAC,GAAG,CAAC;gBAC1BD,YAAYjB,UAAU,CAACR,MAAM0B,IAAI,CAAC;YACpC;YAEA,MAAMwB,WAAW,EAAE;YAEnBpC,aAAamB,WAAW,CAACkB,OAAO,CAAC,CAACf;gBAChC,IAAIX,SAAS,CAACW,OAAO,EAAE;oBACrB,OAAQpC,MAAMoD,IAAI;wBAChB,KAAK;4BAAS;gCACZ,MAAMC,OAAO5B,SAAS,CAACW,OAAO;gCAE9B,IAAIR,MAAMC,OAAO,CAACwB,OAAO;oCACvB,MAAMH,WAAW,EAAE;oCAEnBG,KAAKF,OAAO,CAAC,CAACG,KAAKC;wCACjBL,SAASM,IAAI,+LACX/D,iBAAAA,EAAe;4CACbE;4CACAC;4CACAC;4CACAC;4CACAC;4CACA0D,QAAQzD,MAAMyD,MAAM;4CACpBvD;4CACAC,iBAAiB;4CACjBC,mBAAmBA,qBAAqBJ,MAAM0D,SAAS;4CACvDrD,YAAYM,OAAO,MAAM4C;4CACzBjD,kBAAkBM;4CAClBL;4CACAC,YAAY8C;wCACd;oCAEJ;gCACF;gCAEA;4BACF;wBAEA,KAAK;4BAAU;gCACb,MAAMD,OAAO5B,SAAS,CAACW,OAAO;gCAE9B,IAAIR,MAAMC,OAAO,CAACwB,OAAO;oCACvB,MAAMH,WAAW,EAAE;oCAEnBG,KAAKF,OAAO,CAAC,CAACG,KAAKC;wCACjB,MAAMI,mBAAmBL,IAAIM,SAAS;wCAEtC,MAAMC,QACJtD,IAAIQ,OAAO,CAAC+C,MAAM,CAACH,iBAAiB,IAClC3D,CAAAA,MAAM+D,eAAe,IAAI/D,MAAM8D,MAAK,EAAGE,IAAI,CAC3C,CAACC,WACC,OAAOA,aAAa,YAAYA,SAASC,IAAI,KAAKP;wCAGxDT,SAASM,IAAI,+LACX/D,iBAAAA,EAAe;4CACbE;4CACAC,WAAW0D;4CACXzD;4CACAC;4CACAC;4CACA0D,QAAQI,MAAMJ,MAAM;4CACpBvD;4CACAC,iBAAiB;4CACjBC,mBAAmBA,qBAAqBJ,MAAM0D,SAAS;4CACvDrD,YAAYM,OAAO,MAAM4C;4CACzBjD,kBAAkBM,aAAa,MAAMiD,MAAMK,IAAI;4CAC/C3D;4CACAC,YAAY8C;wCACd;oCAEJ;gCACF;gCACA;4BACF;wBAEA,KAAK;wBACL,KAAK;4BAAO;gCACVJ,SAASM,IAAI,+LACX/D,iBAAAA,EAAe;oCACbE;oCACAC;oCACAC;oCACAC;oCACAC;oCACA0D,QAAQzD,MAAMyD,MAAM;oCACpBvD;oCACAC,iBAAiB;oCACjBC,mBAAmBA,qBAAqBJ,MAAM0D,SAAS;oCACvDrD,YAAYM;oCACZL,kBAAkBM;oCAClBL;oCACAC,YAAYiB,SAAS,CAACW,OAAO;gCAC/B;gCAGF;4BACF;oBACF;gBACF;YACF;YAEA,MAAMY,QAAQmB,GAAG,CAACjB;QACpB,OAAO;YACL,sDAAsD;YACtD,2CAA2C;YAC3C,oDAAoD;YACpD,OAAQlD,MAAMoD,IAAI;gBAChB,KAAK;oBAAS;wBACZ,MAAMC,OAAO7C,UAAU,CAACR,MAAM0B,IAAI,CAAC;wBAEnC,IAAIE,MAAMC,OAAO,CAACwB,OAAO;4BACvB,MAAMH,WAAW,EAAE;4BAEnBG,KAAKF,OAAO,CAAC,CAACG,KAAKC;gCACjBL,SAASM,IAAI,+LACX/D,iBAAAA,EAAe;oCACbE;oCACAC;oCACAC;oCACAC;oCACAC;oCACA0D,QAAQzD,MAAMyD,MAAM;oCACpBvD;oCACAC,iBAAiB;oCACjBC,mBAAmBA,qBAAqBJ,MAAM0D,SAAS;oCACvDrD,YAAYM,OAAO,MAAM4C;oCACzBjD,kBAAkBM;oCAClBL;oCACAC,YAAY8C;gCACd;4BAEJ;4BAEA,MAAMN,QAAQmB,GAAG,CAACjB;wBACpB;wBAEA;oBACF;gBAEA,KAAK;oBAAU;wBACb,MAAMG,OAAO7C,UAAU,CAACR,MAAM0B,IAAI,CAAC;wBAEnC,IAAIE,MAAMC,OAAO,CAACwB,OAAO;4BACvB,MAAMH,WAAW,EAAE;4BAEnBG,KAAKF,OAAO,CAAC,CAACG,KAAKC;gCACjB,MAAMI,mBAAmBL,IAAIM,SAAS;gCAEtC,MAAMC,QACJtD,IAAIQ,OAAO,CAAC+C,MAAM,CAACH,iBAAiB,IAClC3D,CAAAA,MAAM+D,eAAe,IAAI/D,MAAM8D,MAAK,EAAGE,IAAI,CAC3C,CAACC,WAAa,OAAOA,aAAa,YAAYA,SAASC,IAAI,KAAKP;gCAGpE,IAAIE,OAAO;;oCACPP,IAAmBM,SAAS,GAAGD;oCAEjCT,SAASM,IAAI,CACX/D,+MAAAA,EAAe;wCACbE;wCACAC,WAAW0D;wCACXzD;wCACAC;wCACAC;wCACA0D,QAAQI,MAAMJ,MAAM;wCACpBvD;wCACAC,iBAAiB;wCACjBC,mBAAmBA,qBAAqBJ,MAAM0D,SAAS;wCACvDrD,YAAYM,OAAO,MAAM4C;wCACzBjD,kBAAkBM,aAAa,MAAMiD,MAAMK,IAAI;wCAC/C3D;wCACAC,YAAY8C;oCACd;gCAEJ;4BACF;4BAEA,MAAMN,QAAQmB,GAAG,CAACjB;wBACpB;wBAEA;oBACF;gBAEA,KAAK;oBAAS;wBACZ,IAAI,OAAO1C,UAAU,CAACR,MAAM0B,IAAI,CAAC,KAAK,UAAU;4BAC9ClB,UAAU,CAACR,MAAM0B,IAAI,CAAC,GAAG,CAAC;wBAC5B;wBAEA,MAAM0C,WAAW5D,UAAU,CAACR,MAAM0B,IAAI,CAAC;wBAEvC,OAAMjC,8MAAAA,EAAe;4BACnBE;4BACAC;4BACAC;4BACAC;4BACAC;4BACA0D,QAAQzD,MAAMyD,MAAM;4BACpBvD;4BACAC,iBAAiB;4BACjBC,mBAAmBA,qBAAqBJ,MAAM0D,SAAS;4BACvDrD,YAAYM;4BACZL,kBAAkBM;4BAClBL;4BACAC,YAAY4D;wBACd;wBAEA;oBACF;gBAEA,KAAK;oBAAO;wBACV,IAAI,OAAO5D,UAAU,CAACR,MAAM0B,IAAI,CAAC,KAAK,UAAU;4BAC9ClB,UAAU,CAACR,MAAM0B,IAAI,CAAC,GAAG,CAAC;wBAC5B;wBAEA,MAAM2C,SAAS7D,UAAU,CAACR,MAAM0B,IAAI,CAAC;wBAErC,oMAAMjC,iBAAAA,EAAe;4BACnBE;4BACAC;4BACAC;4BACAC;4BACAC;4BACA0D,QAAQzD,MAAMyD,MAAM;4BACpBvD;4BACAC,iBAAiB;4BACjBC,mBAAmBA,qBAAqBJ,MAAM0D,SAAS;4BACvDrD,YAAYM;4BACZL,kBAAkBM;4BAClBL;4BACAC,YAAY6D;wBACd;wBAEA;oBACF;YACF;QACF;IACF,OAAO;QACL,4DAA4D;QAC5D,OAAQrE,MAAMoD,IAAI;YAChB,KAAK;YACL,KAAK;gBAAO;oBACV,OAAM3D,8MAAAA,EAAe;wBACnBE;wBACAC;wBACAC;wBACAC;wBACAC;wBACA0D,QAAQzD,MAAMyD,MAAM;wBACpBvD;wBACAC,iBAAiBO;wBACjBN;wBACAC;wBACAC,kBAAkBM;wBAClBL;wBACAC;oBACF;oBAEA;gBACF;YAEA,cAAc;YACd,0FAA0F;YAC1F,KAAK;gBAAO;oBACV,oMAAMf,iBAAAA,EAAe;wBACnBE;wBACAC;wBACAC;wBACAC;wBACAC;wBACA,0FAA0F;wBAC1F0D,QAAQzD,MAAMyD,MAAM;wBACpBvD;wBACAC,iBAAiBO;wBACjBN;wBACAC;wBACAC,kBAAkBM;wBAClBL;wBACAC;oBACF;oBAEA;gBACF;YAEA,KAAK;gBAAQ;oBACX,oMAAMf,iBAAAA,EAAe;wBACnBE;wBACAC;wBACAC;wBACAC;wBACAC;wBACA0D,QAAQzD,MAAMsE,IAAI,CAAC/C,GAAG,CAAC,CAACgD,MAAS,CAAA;gCAAE,GAAGA,GAAG;gCAAEnB,MAAM;4BAAM,CAAA;wBACvDlD;wBACAC,iBAAiBO;wBACjBN;wBACAC,YAAYM;wBACZL,kBAAkBM;wBAClBL;wBACAC;oBACF;oBAEA;gBACF;YAEA;gBAAS;oBACP;gBACF;QACF;IACF;AACF,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2895, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeDuplicate/traverseFields.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc: T\n  fields: (Field | TabAsField)[]\n  id?: number | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  doc,\n  fields,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        blockData,\n        collection,\n        context,\n        doc,\n        field,\n        fieldIndex,\n        overrideAccess,\n        parentIndexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath,\n        req,\n        siblingDoc,\n        siblingFields: fields,\n      }),\n    )\n  })\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","blockData","collection","context","doc","fields","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingDoc","promises","forEach","field","fieldIndex","push","siblingFields","Promise","all"],"mappings":"AAAA,oBAAoB;;;;AAMpB,SAASA,OAAO,QAAQ,eAAc;;AAqB/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,MAAM,EACNC,cAAc,EACdC,eAAe,EACfC,iBAAiB,EACjBC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IAEnBR,OAAOS,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,wLACXnB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAW;YACAC;YACAV;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAM,eAAeb;QACjB;IAEJ;IACA,MAAMc,QAAQC,GAAG,CAACP;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2924, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2930, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeDuplicate/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  doc?: T\n  id?: number | string\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for running beforeDuplicate hooks\n * against a document including all locale data.\n * It will run each field's beforeDuplicate hook\n * and return the resulting docWithLocales.\n */\nexport const beforeDuplicate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  doc,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  await traverseFields({\n    id,\n    collection,\n    context,\n    doc,\n    fields: collection?.fields,\n    overrideAccess,\n    parentIndexPath: '',\n    parentIsLocalized: false,\n    parentPath: '',\n    parentSchemaPath: '',\n    req,\n    siblingDoc: doc,\n  })\n\n  return doc\n}\n"],"names":["traverseFields","beforeDuplicate","id","collection","context","doc","overrideAccess","req","fields","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","siblingDoc"],"mappings":"AAAA,oBAAoB;;;;AAKpB,SAASA,cAAc,QAAQ,sBAAqB;;AAiB7C,MAAMC,kBAAkB,OAA6B,EAC1DC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,GAAG,EACHC,cAAc,EACdC,GAAG,EACK;IACR,oMAAMP,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAG,QAAQL,YAAYK;QACpBF;QACAG,iBAAiB;QACjBC,mBAAmB;QACnBC,YAAY;QACZC,kBAAkB;QAClBL;QACAM,YAAYR;IACd;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2953, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2959, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeChange/cloneDataFromOriginalDoc.ts"],"sourcesContent":["import type { JsonArray, JsonObject } from '../../../types/index.js'\n\nexport const cloneDataFromOriginalDoc = (\n  originalDocData: JsonArray | JsonObject,\n): JsonArray | JsonObject => {\n  if (Array.isArray(originalDocData)) {\n    return originalDocData.map((row) => {\n      if (typeof row === 'object' && row != null) {\n        return {\n          ...row,\n        }\n      }\n\n      return row\n    })\n  }\n\n  if (typeof originalDocData === 'object' && originalDocData !== null) {\n    return { ...originalDocData }\n  }\n\n  return originalDocData\n}\n"],"names":["cloneDataFromOriginalDoc","originalDocData","Array","isArray","map","row"],"mappings":";;;AAEO,MAAMA,2BAA2B,CACtCC;IAEA,IAAIC,MAAMC,OAAO,CAACF,kBAAkB;QAClC,OAAOA,gBAAgBG,GAAG,CAAC,CAACC;YAC1B,IAAI,OAAOA,QAAQ,YAAYA,OAAO,MAAM;gBAC1C,OAAO;oBACL,GAAGA,GAAG;gBACR;YACF;YAEA,OAAOA;QACT;IACF;IAEA,IAAI,OAAOJ,oBAAoB,YAAYA,oBAAoB,MAAM;QACnE,OAAO;YAAE,GAAGA,eAAe;QAAC;IAC9B;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 2980, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2986, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeChange/getExistingRowDoc.ts"],"sourcesContent":["/**\n * If there is an incoming row id,\n * and it matches the existing sibling doc id,\n * this is an existing row, so it should be merged.\n * Otherwise, return an empty object.\n */\nimport type { JsonObject } from '../../../types/index.js'\n\nexport const getExistingRowDoc = (incomingRow: JsonObject, existingRows?: unknown): JsonObject => {\n  if (incomingRow.id && Array.isArray(existingRows)) {\n    const matchedExistingRow = existingRows.find((existingRow) => {\n      if (typeof existingRow === 'object' && 'id' in existingRow) {\n        if (existingRow.id === incomingRow.id) {\n          return existingRow\n        }\n      }\n\n      return false\n    })\n\n    if (matchedExistingRow) {\n      return matchedExistingRow\n    }\n  }\n\n  return {}\n}\n"],"names":["getExistingRowDoc","incomingRow","existingRows","id","Array","isArray","matchedExistingRow","find","existingRow"],"mappings":"AAAA;;;;;CAKC,GAGD;;;AAAO,MAAMA,oBAAoB,CAACC,aAAyBC;IACzD,IAAID,YAAYE,EAAE,IAAIC,MAAMC,OAAO,CAACH,eAAe;QACjD,MAAMI,qBAAqBJ,aAAaK,IAAI,CAAC,CAACC;YAC5C,IAAI,OAAOA,gBAAgB,YAAY,QAAQA,aAAa;gBAC1D,IAAIA,YAAYL,EAAE,KAAKF,YAAYE,EAAE,EAAE;oBACrC,OAAOK;gBACT;YACF;YAEA,OAAO;QACT;QAEA,IAAIF,oBAAoB;YACtB,OAAOA;QACT;IACF;IAEA,OAAO,CAAC;AACV,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3010, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3016, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeValidate/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig, TypeWithID } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, JsonValue, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName, valueIsValueWithRelation } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { cloneDataFromOriginalDoc } from '../beforeChange/cloneDataFromOriginalDoc.js'\nimport { getExistingRowDoc } from '../beforeChange/getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\n// This function is responsible for the following actions, in order:\n// - Sanitize incoming data\n// - Execute field hooks\n// - Execute field access control\n// - Merge original document data into incoming data\n// - Compute default values for undefined fields\n\nexport const promise = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingFields,\n}: Args<T>): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    if (field.name === 'id') {\n      if (field.type === 'number' && typeof siblingData[field.name] === 'string') {\n        const value = siblingData[field.name] as string\n\n        siblingData[field.name] = parseFloat(value)\n      }\n\n      if (\n        field.type === 'text' &&\n        typeof siblingData[field.name]?.toString === 'function' &&\n        typeof siblingData[field.name] !== 'string'\n      ) {\n        siblingData[field.name] = siblingData[field.name].toString()\n      }\n    }\n\n    // Sanitize incoming data\n    switch (field.type) {\n      case 'array':\n      case 'blocks': {\n        // Handle cases of arrays being intentionally set to 0\n        if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {\n          siblingData[field.name] = []\n        }\n\n        break\n      }\n\n      case 'checkbox': {\n        if (siblingData[field.name] === 'true') {\n          siblingData[field.name] = true\n        }\n        if (siblingData[field.name] === 'false') {\n          siblingData[field.name] = false\n        }\n        if (siblingData[field.name] === '') {\n          siblingData[field.name] = false\n        }\n\n        break\n      }\n\n      case 'number': {\n        if (typeof siblingData[field.name] === 'string') {\n          const value = siblingData[field.name] as string\n          const trimmed = value.trim()\n          siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed)\n        }\n\n        break\n      }\n\n      case 'point': {\n        if (Array.isArray(siblingData[field.name])) {\n          siblingData[field.name] = (siblingData[field.name] as string[]).map((coordinate, i) => {\n            if (typeof coordinate === 'string') {\n              const value = siblingData[field.name][i] as string\n              const trimmed = value.trim()\n              return trimmed.length === 0 ? null : parseFloat(trimmed)\n            }\n            return coordinate\n          })\n        }\n\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        if (\n          siblingData[field.name] === '' ||\n          siblingData[field.name] === 'none' ||\n          siblingData[field.name] === 'null' ||\n          siblingData[field.name] === null\n        ) {\n          if (field.hasMany === true) {\n            siblingData[field.name] = []\n          } else {\n            siblingData[field.name] = null\n          }\n        }\n\n        const value = siblingData[field.name]\n\n        if (Array.isArray(field.relationTo)) {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: { relationTo: string; value: JsonValue }, i) => {\n              const relatedCollection = req.payload.collections?.[relatedDoc.relationTo]?.config\n\n              if (\n                typeof relatedDoc.value === 'object' &&\n                relatedDoc.value &&\n                'id' in relatedDoc.value\n              ) {\n                relatedDoc.value = relatedDoc.value.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = {\n                    ...relatedDoc,\n                    value: parseFloat(relatedDoc.value as string),\n                  }\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && valueIsValueWithRelation(value)) {\n            const relatedCollection = req.payload.collections?.[value.relationTo]?.config\n\n            if (typeof value.value === 'object' && value.value && 'id' in value.value) {\n              value.value = (value.value as TypeWithID).id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = { ...value, value: parseFloat(value.value as string) }\n              }\n            }\n          }\n        } else {\n          if (Array.isArray(value)) {\n            value.forEach((relatedDoc: unknown, i) => {\n              const relatedCollection = Array.isArray(field.relationTo)\n                ? undefined\n                : req.payload.collections?.[field.relationTo]?.config\n\n              if (typeof relatedDoc === 'object' && relatedDoc && 'id' in relatedDoc) {\n                value[i] = relatedDoc.id\n              }\n\n              if (relatedCollection?.fields) {\n                const relationshipIDField = relatedCollection.fields.find(\n                  (collectionField) =>\n                    fieldAffectsData(collectionField) && collectionField.name === 'id',\n                )\n                if (relationshipIDField?.type === 'number') {\n                  siblingData[field.name][i] = parseFloat(relatedDoc as string)\n                }\n              }\n            })\n          }\n          if (field.hasMany !== true && value) {\n            const relatedCollection = req.payload.collections?.[field.relationTo]?.config\n\n            if (typeof value === 'object' && value && 'id' in value) {\n              siblingData[field.name] = value.id\n            }\n\n            if (relatedCollection?.fields) {\n              const relationshipIDField = relatedCollection.fields.find(\n                (collectionField) =>\n                  fieldAffectsData(collectionField) && collectionField.name === 'id',\n              )\n              if (relationshipIDField?.type === 'number') {\n                siblingData[field.name] = parseFloat(value as string)\n              }\n            }\n          }\n        }\n        break\n      }\n      case 'richText': {\n        if (typeof siblingData[field.name] === 'string') {\n          try {\n            const richTextJSON = JSON.parse(siblingData[field.name] as string)\n            siblingData[field.name] = richTextJSON\n          } catch {\n            // Disregard this data as it is not valid.\n            // Will be reported to user by field validation\n          }\n        }\n\n        break\n      }\n\n      default: {\n        break\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeValidate) {\n      await field.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          overrideAccess,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingFields,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Execute access control\n    if (field.access && field.access[operation]) {\n      const result = overrideAccess\n        ? true\n        : await field.access[operation]({ id, blockData, data, doc, req, siblingData })\n\n      if (!result) {\n        delete siblingData[field.name]\n      }\n    }\n\n    if (typeof siblingData[field.name] === 'undefined') {\n      // If no incoming data, but existing document data is found, merge it in\n      if (typeof siblingDoc[field.name] !== 'undefined') {\n        siblingData[field.name] = cloneDataFromOriginalDoc(siblingDoc[field.name])\n\n        // Otherwise compute default value\n      } else if (typeof field.defaultValue !== 'undefined') {\n        siblingData[field.name] = await getDefaultValue({\n          defaultValue: field.defaultValue,\n          locale: req.locale,\n          req,\n          user: req.user,\n          value: siblingData[field.name],\n        })\n      }\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            ;(row as JsonObject).blockType = blockTypeToMatch\n\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n\n      const groupData = siblingData[field.name] as Record<string, unknown>\n      const groupDoc = siblingDoc[field.name] as Record<string, unknown>\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: '',\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: groupData as JsonObject,\n        siblingDoc: groupDoc as JsonObject,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeValidate?.length) {\n        await editor.hooks.beforeValidate.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            parentIsLocalized,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingData[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData\n      let tabSiblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as Record<string, unknown>\n        tabSiblingDoc = siblingDoc[field.name] as Record<string, unknown>\n      } else {\n        tabSiblingData = siblingData\n        tabSiblingDoc = siblingDoc\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","valueIsValueWithRelation","getDefaultValue","getFieldPathsModified","getFieldPaths","cloneDataFromOriginalDoc","getExistingRowDoc","traverseFields","promise","id","blockData","collection","context","data","doc","field","fieldIndex","global","operation","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingFields","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","name","type","value","parseFloat","toString","trimmed","trim","length","Array","isArray","coordinate","i","hasMany","relationTo","forEach","relatedDoc","relatedCollection","payload","collections","config","fields","relationshipIDField","find","collectionField","undefined","richTextJSON","JSON","parse","hooks","beforeValidate","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","Promise","resolve","access","result","defaultValue","locale","user","rows","promises","row","rowIndex","push","localized","all","rowSiblingDoc","blockTypeToMatch","blockType","block","blocks","blockReferences","curBlock","slug","groupData","groupDoc","editor","Error","tabSiblingData","tabSiblingDoc","isNamedTab","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3487, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3493, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeValidate/traverseFields.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args<T> = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: T\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n}\n\nexport const traverseFields = async <T>({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n}: Args<T>): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        fieldIndex,\n        global,\n        operation,\n        overrideAccess,\n        parentIndexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingFields: fields,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","blockData","collection","context","data","doc","fields","global","operation","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","promises","forEach","field","fieldIndex","push","siblingFields","Promise","all"],"mappings":"AAAA,oBAAoB;;;;AAOpB,SAASA,OAAO,QAAQ,eAAc;;AAkC/B,MAAMC,iBAAiB,OAAU,EACtCC,EAAE,EACFC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,eAAe,EACfC,iBAAiB,EACjBC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,WAAW,EACXC,UAAU,EACF;IACR,MAAMC,WAAW,EAAE;IAEnBX,OAAOY,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,uLACXvB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAc;YACAC;YACAb;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAM,eAAehB;QACjB;IAEJ;IAEA,MAAMiB,QAAQC,GAAG,CAACP;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3526, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3532, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeValidate/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { type RequestContext } from '../../../index.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc?: T\n  duplicate?: boolean\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: 'create' | 'update'\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Sanitize incoming data\n * - Execute field hooks\n * - Execute field access control\n * - Merge original document data into incoming data\n * - Compute default values for undefined fields\n */\nexport const beforeValidate = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  global,\n  operation,\n  overrideAccess,\n  req,\n}: Args<T>): Promise<T> => {\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data: incomingData,\n    doc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    overrideAccess,\n    parentIndexPath: '',\n    parentIsLocalized: false,\n    parentPath: '',\n    parentSchemaPath: '',\n    req,\n    siblingData: incomingData,\n    siblingDoc: doc,\n  })\n\n  return incomingData\n}\n"],"names":["traverseFields","beforeValidate","id","collection","context","data","incomingData","doc","global","operation","overrideAccess","req","fields","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","siblingData","siblingDoc"],"mappings":"AAAA,oBAAoB;;;;AAMpB,SAASA,cAAc,QAAQ,sBAAqB;;AAuB7C,MAAMC,iBAAiB,OAA6B,EACzDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,GAAG,EACK;IACR,mMAAMX,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC,MAAMC;QACNC;QACAK,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAC;QACAG,iBAAiB;QACjBC,mBAAmB;QACnBC,YAAY;QACZC,kBAAkB;QAClBL;QACAM,aAAaX;QACbY,YAAYX;IACd;IAEA,OAAOD;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 3559, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3565, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField, Validate } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'\nimport { getLabelFromPath } from '../../../utilities/getLabelFromPath.js'\nimport { getTranslatedLabel } from '../../../utilities/getTranslatedLabel.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingDocWithLocales?: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  field,\n  fieldIndex,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  siblingFields,\n  skipValidation,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const passesCondition = field.admin?.condition\n    ? Boolean(field.admin.condition(data, siblingData, { blockData, user: req.user }))\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeChange) {\n      await field.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingDocWithLocales,\n          siblingFields,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n\n    // Validate\n    if (!skipValidationFromHere && 'validate' in field && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      const validateFn: Validate<object, object, object, object> = field.validate as Validate<\n        object,\n        object,\n        object,\n        object\n      >\n      const validationResult = await validateFn(valueToValidate as never, {\n        ...field,\n        id,\n        blockData,\n        collectionSlug: collection?.slug,\n        data: deepMergeWithSourceArrays(doc, data),\n        event: 'submit',\n        // @ts-expect-error\n        jsonError,\n        operation,\n        preferences: { fields: {} },\n        previousValue: siblingDoc[field.name],\n        req,\n        siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),\n      })\n\n      if (typeof validationResult === 'string') {\n        const label = getTranslatedLabel(field?.label || field?.name, req.i18n)\n        const parentPathSegments = parentPath ? parentPath.split('.') : []\n\n        const fieldLabel =\n          Array.isArray(parentPathSegments) && parentPathSegments.length > 0\n            ? getLabelFromPath(parentPathSegments.concat(label))\n            : label\n\n        errors.push({\n          label: fieldLabel,\n          message: validationResult,\n          path,\n        })\n      }\n    }\n\n    // Push merge locale action if applicable\n    if (localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n      mergeLocaleActions.push(async () => {\n        const localeData = await localization.localeCodes.reduce(\n          async (localizedValuesPromise: Promise<JsonObject>, locale) => {\n            const localizedValues = await localizedValuesPromise\n            const fieldValue =\n              locale === req.locale\n                ? siblingData[field.name]\n                : siblingDocWithLocales?.[field.name]?.[locale]\n\n            // const result = await localizedValues\n            // update locale value if it's not undefined\n            if (typeof fieldValue !== 'undefined') {\n              return {\n                ...localizedValues,\n                [locale]: fieldValue,\n              }\n            }\n\n            return localizedValuesPromise\n          },\n          Promise.resolve({}),\n        )\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name] = localeData\n        }\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              errors,\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(\n                row as JsonObject,\n                siblingDocWithLocales[field.name],\n              ),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n\n          const rowSiblingDocWithLocales = getExistingRowDoc(\n            row as JsonObject,\n            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},\n          )\n\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                errors,\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n\n      if (typeof siblingDocWithLocales[field.name] !== 'object') {\n        siblingDocWithLocales[field.name] = {}\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: '',\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: siblingData[field.name] as JsonObject,\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n        siblingDocWithLocales: siblingDocWithLocales[field.name] as JsonObject,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        await editor.hooks.beforeChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            errors,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            parentIsLocalized,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","deepMergeWithSourceArrays","getLabelFromPath","getTranslatedLabel","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getFieldPathsModified","getFieldPaths","getExistingRowDoc","traverseFields","promise","id","blockData","collection","context","data","doc","docWithLocales","errors","field","fieldIndex","global","mergeLocaleActions","operation","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","siblingFields","skipValidation","indexPath","path","schemaPath","index","passesCondition","admin","condition","Boolean","user","skipValidationFromHere","localization","payload","config","defaultLocale","operationLocale","locale","pathSegments","split","schemaPathSegments","indexPathSegments","filter","map","Number","includes","type","name","hooks","beforeChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","Promise","resolve","validate","valueToValidate","jsonError","JSON","parse","e","validateFn","validationResult","collectionSlug","slug","event","preferences","fields","label","i18n","parentPathSegments","fieldLabel","Array","isArray","length","concat","push","message","localeData","localeCodes","localizedValuesPromise","localizedValues","fieldValue","Object","keys","rows","promises","forEach","row","rowIndex","localized","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","coordinates","parseFloat","editor","Error","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","isNamedTab","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3989, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3995, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeChange/traverseFields.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  /**\n   * The original data (not modified by any hooks)\n   */\n  doc: JsonObject\n  /**\n   * The original data with locales (not modified by any hooks)\n   */\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void>)[]\n  operation: Operation\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  /**\n   * The original siblingData (not modified by any hooks)\n   */\n  siblingDoc: JsonObject\n  /**\n   * The original siblingData with locales (not modified by any hooks)\n   */\n  siblingDocWithLocales: JsonObject\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\nexport const traverseFields = async ({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  fields,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  skipValidation,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        field,\n        fieldIndex,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        siblingFields: fields,\n        skipValidation,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","id","blockData","collection","context","data","doc","docWithLocales","errors","fields","global","mergeLocaleActions","operation","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","skipValidation","promises","forEach","field","fieldIndex","push","siblingFields","Promise","all"],"mappings":"AAAA,oBAAoB;;;;AAQpB,SAASA,OAAO,QAAQ,eAAc;;AAoD/B,MAAMC,iBAAiB,OAAO,EACnCC,EAAE,EACFC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,kBAAkB,EAClBC,SAAS,EACTC,eAAe,EACfC,iBAAiB,EACjBC,UAAU,EACVC,gBAAgB,EAChBC,GAAG,EACHC,WAAW,EACXC,UAAU,EACVC,qBAAqB,EACrBC,cAAc,EACT;IACL,MAAMC,WAAW,EAAE;IAEnBb,OAAOc,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,qLACX3B,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAgB;YACAC;YACAf;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAO,eAAelB;YACfY;QACF;IAEJ;IAEA,MAAMO,QAAQC,GAAG,CAACP;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4032, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4038, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/beforeChange/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\n\nimport { ValidationError } from '../../../errors/index.js'\nimport { deepCopyObjectSimple } from '../../../utilities/deepCopyObject.js'\nimport { traverseFields } from './traverseFields.js'\nexport type Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: T\n  doc: T\n  docWithLocales: JsonObject\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  operation: Operation\n  req: PayloadRequest\n  skipValidation?: boolean\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Run condition\n * - Execute field hooks\n * - Validate data\n * - Transform data for storage\n * - Unflatten locales. The input `data` is the normal document for one locale. The output result will become the document with locales.\n */\n\nexport const beforeChange = async <T extends JsonObject>({\n  id,\n  collection,\n  context,\n  data: incomingData,\n  doc,\n  docWithLocales,\n  global,\n  operation,\n  req,\n  skipValidation,\n}: Args<T>): Promise<T> => {\n  const data = deepCopyObjectSimple(incomingData)\n  const mergeLocaleActions = []\n  const errors: ValidationFieldError[] = []\n\n  await traverseFields({\n    id,\n    collection,\n    context,\n    data,\n    doc,\n    docWithLocales,\n    errors,\n    fields: collection?.fields || global?.fields,\n    global,\n    mergeLocaleActions,\n    operation,\n    parentIndexPath: '',\n    parentIsLocalized: false,\n    parentPath: '',\n    parentSchemaPath: '',\n    req,\n    siblingData: data,\n    siblingDoc: doc,\n    siblingDocWithLocales: docWithLocales,\n    skipValidation,\n  })\n\n  if (errors.length > 0) {\n    throw new ValidationError(\n      {\n        id,\n        collection: collection?.slug,\n        errors,\n        global: global?.slug,\n      },\n      req.t,\n    )\n  }\n\n  await mergeLocaleActions.reduce(async (priorAction, action) => {\n    await priorAction\n    await action()\n  }, Promise.resolve())\n\n  return data\n}\n"],"names":["ValidationError","deepCopyObjectSimple","traverseFields","beforeChange","id","collection","context","data","incomingData","doc","docWithLocales","global","operation","req","skipValidation","mergeLocaleActions","errors","fields","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","siblingData","siblingDoc","siblingDocWithLocales","length","slug","t","reduce","priorAction","action","Promise","resolve"],"mappings":"AAAA,oBAAoB;;;;AAQpB,SAASC,oBAAoB,QAAQ,uCAAsC;AAC3E,SAASC,cAAc,QAAQ,sBAAqB;AAFpD,SAASF,eAAe,QAAQ,2BAA0B;;;;AAyBnD,MAAMG,eAAe,OAA6B,EACvDC,EAAE,EACFC,UAAU,EACVC,OAAO,EACPC,MAAMC,YAAY,EAClBC,GAAG,EACHC,cAAc,EACdC,MAAM,EACNC,SAAS,EACTC,GAAG,EACHC,cAAc,EACN;IACR,MAAMP,4KAAON,uBAAAA,EAAqBO;IAClC,MAAMO,qBAAqB,EAAE;IAC7B,MAAMC,SAAiC,EAAE;IAEzC,iMAAMd,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC;QACAE;QACAC;QACAM;QACAC,QAAQZ,YAAYY,UAAUN,QAAQM;QACtCN;QACAI;QACAH;QACAM,iBAAiB;QACjBC,mBAAmB;QACnBC,YAAY;QACZC,kBAAkB;QAClBR;QACAS,aAAaf;QACbgB,YAAYd;QACZe,uBAAuBd;QACvBI;IACF;IAEA,IAAIE,OAAOS,MAAM,GAAG,GAAG;QACrB,MAAM,mKAAIzB,kBAAAA,CACR;YACEI;YACAC,YAAYA,YAAYqB;YACxBV;YACAL,QAAQA,QAAQe;QAClB,GACAb,IAAIc,CAAC;IAET;IAEA,MAAMZ,mBAAmBa,MAAM,CAAC,OAAOC,aAAaC;QAClD,MAAMD;QACN,MAAMC;IACR,GAAGC,QAAQC,OAAO;IAElB,OAAOzB;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4088, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4094, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/afterChange/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { fieldAffectsData, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  field: Field | TabAsField\n  fieldIndex: number\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\n// This function is responsible for the following actions, in order:\n// - Execute field hooks\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  field,\n  fieldIndex,\n  global,\n  operation,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingFields,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (field.hooks?.afterChange) {\n      await field.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n        await priorHook\n\n        const hookedValue = await currentHook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousDoc,\n          previousSiblingDoc,\n          previousValue: previousDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingFields,\n          value: siblingDoc[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingDoc[field.name] = hookedValue\n        }\n      }, Promise.resolve())\n    }\n  }\n\n  // Traverse subfields\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              fields: field.fields,\n              global,\n              operation,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              previousDoc,\n              previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),\n              req,\n              siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n              siblingDoc: row ? { ...row } : {},\n            }),\n          )\n        })\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const blockTypeToMatch = (row as JsonObject).blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                blockData: siblingData?.[field.name]?.[rowIndex],\n                collection,\n                context,\n                data,\n                doc,\n                fields: block.fields,\n                global,\n                operation,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                previousDoc,\n                previousSiblingDoc: previousDoc?.[field.name]?.[rowIndex] || ({} as JsonObject),\n                req,\n                siblingData: siblingData?.[field.name]?.[rowIndex] || {},\n                siblingDoc: row ? { ...row } : {},\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    case 'group': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: '',\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: previousDoc[field.name] as JsonObject,\n        req,\n        siblingData: (siblingData?.[field.name] as JsonObject) || {},\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n      })\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterChange?.length) {\n        await editor.hooks.afterChange.reduce(async (priorHook, currentHook) => {\n          await priorHook\n\n          const hookedValue = await currentHook({\n            collection,\n            context,\n            data,\n            field,\n            global,\n            indexPath: indexPathSegments,\n            operation,\n            originalDoc: doc,\n            parentIsLocalized,\n            path: pathSegments,\n            previousDoc,\n            previousSiblingDoc,\n            previousValue: previousDoc[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }, Promise.resolve())\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabPreviousSiblingDoc = siblingDoc\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabSiblingData = (siblingData[field.name] as JsonObject) ?? {}\n        tabSiblingDoc = (siblingDoc[field.name] as JsonObject) ?? {}\n        tabPreviousSiblingDoc = (previousDoc[field.name] as JsonObject) ?? {}\n      }\n\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.fields,\n        global,\n        operation,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: tabPreviousSiblingDoc,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        previousDoc,\n        previousSiblingDoc: { ...previousSiblingDoc },\n        req,\n        siblingData: siblingData || {},\n        siblingDoc: { ...siblingDoc },\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","fieldAffectsData","tabHasName","getFieldPathsModified","getFieldPaths","traverseFields","promise","blockData","collection","context","data","doc","field","fieldIndex","global","operation","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","siblingFields","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","hooks","afterChange","reduce","priorHook","currentHook","hookedValue","originalDoc","previousValue","name","value","undefined","Promise","resolve","type","rows","Array","isArray","promises","forEach","row","rowIndex","push","fields","localized","all","blockTypeToMatch","blockType","block","payload","blocks","blockReferences","find","curBlock","slug","editor","Error","length","tabSiblingData","tabSiblingDoc","tabPreviousSiblingDoc","isNamedTab","tabs","tab"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4376, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4382, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/afterChange/traverseFields.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\nimport type { Field, TabAsField } from '../../config/types.js'\n\nimport { promise } from './promise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  fields: (Field | TabAsField)[]\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  previousDoc: JsonObject\n  previousSiblingDoc: JsonObject\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n}\n\nexport const traverseFields = async ({\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  fields,\n  global,\n  operation,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  previousDoc,\n  previousSiblingDoc,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingFields,\n}: Args): Promise<void> => {\n  const promises = []\n\n  fields.forEach((field, fieldIndex) => {\n    promises.push(\n      promise({\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        field,\n        fieldIndex,\n        global,\n        operation,\n        parentIndexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath,\n        previousDoc,\n        previousSiblingDoc,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingFields,\n      }),\n    )\n  })\n\n  await Promise.all(promises)\n}\n"],"names":["promise","traverseFields","blockData","collection","context","data","doc","fields","global","operation","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","previousDoc","previousSiblingDoc","req","siblingData","siblingDoc","siblingFields","promises","forEach","field","fieldIndex","push","Promise","all"],"mappings":"AAAA,oBAAoB;;;;AAOpB,SAASA,OAAO,QAAQ,eAAc;;AA6B/B,MAAMC,iBAAiB,OAAO,EACnCC,SAAS,EACTC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,GAAG,EACHC,MAAM,EACNC,MAAM,EACNC,SAAS,EACTC,eAAe,EACfC,iBAAiB,EACjBC,UAAU,EACVC,gBAAgB,EAChBC,WAAW,EACXC,kBAAkB,EAClBC,GAAG,EACHC,WAAW,EACXC,UAAU,EACVC,aAAa,EACR;IACL,MAAMC,WAAW,EAAE;IAEnBb,OAAOc,OAAO,CAAC,CAACC,OAAOC;QACrBH,SAASI,IAAI,oLACXxB,UAAAA,EAAQ;YACNE;YACAC;YACAC;YACAC;YACAC;YACAgB;YACAC;YACAf;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;YACAC;QACF;IAEJ;IAEA,MAAMM,QAAQC,GAAG,CAACN;AACpB,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4415, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4421, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/hooks/afterChange/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, PayloadRequest } from '../../../types/index.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args<T extends JsonObject> = {\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  /**\n   * The data before hooks\n   */\n  data: T\n  /**\n   * The data after hooks\n   */\n  doc: T\n  global: null | SanitizedGlobalConfig\n  operation: 'create' | 'update'\n  previousDoc: T\n  req: PayloadRequest\n}\n\n/**\n * This function is responsible for the following actions, in order:\n * - Execute field hooks\n */\nexport const afterChange = async <T extends JsonObject>({\n  collection,\n  context,\n  data,\n  doc: incomingDoc,\n  global,\n  operation,\n  previousDoc,\n  req,\n}: Args<T>): Promise<T> => {\n  await traverseFields({\n    collection,\n    context,\n    data,\n    doc: incomingDoc,\n    fields: collection?.fields || global?.fields,\n    global,\n    operation,\n    parentIndexPath: '',\n    parentIsLocalized: false,\n    parentPath: '',\n    parentSchemaPath: '',\n    previousDoc,\n    previousSiblingDoc: previousDoc,\n    req,\n    siblingData: data,\n    siblingDoc: incomingDoc,\n  })\n\n  return incomingDoc\n}\n"],"names":["traverseFields","afterChange","collection","context","data","doc","incomingDoc","global","operation","previousDoc","req","fields","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","previousSiblingDoc","siblingData","siblingDoc"],"mappings":"AAAA,oBAAoB;;;;AAMpB,SAASA,cAAc,QAAQ,sBAAqB;;AAuB7C,MAAMC,cAAc,OAA6B,EACtDC,UAAU,EACVC,OAAO,EACPC,IAAI,EACJC,KAAKC,WAAW,EAChBC,MAAM,EACNC,SAAS,EACTC,WAAW,EACXC,GAAG,EACK;IACR,gMAAMV,iBAAAA,EAAe;QACnBE;QACAC;QACAC;QACAC,KAAKC;QACLK,QAAQT,YAAYS,UAAUJ,QAAQI;QACtCJ;QACAC;QACAI,iBAAiB;QACjBC,mBAAmB;QACnBC,YAAY;QACZC,kBAAkB;QAClBN;QACAO,oBAAoBP;QACpBC;QACAO,aAAab;QACbc,YAAYZ;IACd;IAEA,OAAOA;AACT,EAAC","ignoreList":[0]}},
    {"offset": {"line": 4448, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4454, "column": 0}, "map": {"version":3,"sources":["file:///home/pro/ByteForce/ali_zayed/node_modules/payload/src/fields/mergeBaseFields.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { Field, FieldWithSubFields } from './config/types.js'\n\nimport { deepMergeWithReactComponents } from '../utilities/deepMerge.js'\nimport { fieldAffectsData, fieldHasSubFields } from './config/types.js'\n\nconst mergeBaseFields = (fields: Field[], baseFields: Field[]): Field[] => {\n  const mergedFields = [...(fields || [])]\n\n  baseFields.forEach((baseField) => {\n    let matchedIndex = null\n\n    if (fieldAffectsData(baseField)) {\n      const match = mergedFields.find((field, i) => {\n        if (fieldAffectsData(field) && field.name === baseField.name) {\n          matchedIndex = i\n          return true\n        }\n\n        return false\n      })\n\n      if (match) {\n        const matchCopy: Field = { ...match }\n        mergedFields.splice(matchedIndex, 1)\n\n        const mergedField = deepMergeWithReactComponents<Field>(baseField, matchCopy)\n\n        if (fieldHasSubFields(baseField) && fieldHasSubFields(matchCopy)) {\n          ;(mergedField as FieldWithSubFields).fields = mergeBaseFields(\n            matchCopy.fields,\n            baseField.fields,\n          )\n        }\n\n        mergedFields.push(mergedField)\n      } else {\n        mergedFields.push(baseField)\n      }\n    }\n  })\n\n  return mergedFields\n}\n\nexport default mergeBaseFields\n"],"names":["deepMergeWithReactComponents","fieldAffectsData","fieldHasSubFields","mergeBaseFields","fields","baseFields","mergedFields","forEach","baseField","matchedIndex","match","find","field","i","name","matchCopy","splice","mergedField","push"],"mappings":"AAAA,oBAAoB;;;;AAIpB,SAASC,gBAAgB,EAAEC,iBAAiB,QAAQ,oBAAmB;AADvE,SAASF,4BAA4B,QAAQ,4BAA2B;;;AAGxE,MAAMG,kBAAkB,CAACC,QAAiBC;IACxC,MAAMC,eAAe;WAAKF,UAAU,EAAE;KAAE;IAExCC,WAAWE,OAAO,CAAC,CAACC;QAClB,IAAIC,eAAe;QAEnB,uKAAIR,mBAAAA,EAAiBO,YAAY;YAC/B,MAAME,QAAQJ,aAAaK,IAAI,CAAC,CAACC,OAAOC;gBACtC,IAAIZ,sLAAAA,EAAiBW,UAAUA,MAAME,IAAI,KAAKN,UAAUM,IAAI,EAAE;oBAC5DL,eAAeI;oBACf,OAAO;gBACT;gBAEA,OAAO;YACT;YAEA,IAAIH,OAAO;gBACT,MAAMK,YAAmB;oBAAE,GAAGL,KAAK;gBAAC;gBACpCJ,aAAaU,MAAM,CAACP,cAAc;gBAElC,MAAMQ,8LAAcjB,+BAAAA,EAAoCQ,WAAWO;gBAEnE,uKAAIb,oBAAAA,EAAkBM,eAAcN,sLAAAA,EAAkBa,YAAY;;oBAC9DE,YAAmCb,MAAM,GAAGD,gBAC5CY,UAAUX,MAAM,EAChBI,UAAUJ,MAAM;gBAEpB;gBAEAE,aAAaY,IAAI,CAACD;YACpB,OAAO;gBACLX,aAAaY,IAAI,CAACV;YACpB;QACF;IACF;IAEA,OAAOF;AACT;uCAEeH,gBAAe","ignoreList":[0]}},
    {"offset": {"line": 4496, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}